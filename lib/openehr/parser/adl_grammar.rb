# Autogenerated from a Treetop grammar. Edits may be lost.


require 'openehr/assumed_library_types'
require 'openehr/rm/data_types/quantity'
require 'openehr/am/archetype/constraint_model'
require 'openehr/am/openehr_profile/data_types/text'
require 'openehr/am/openehr_profile/data_types/quantity'
require 'openehr/parser/adl_helper'

module OpenEHR
  module Parser
    module ADLGrammar
      include Treetop::Runtime

      def root
        @root ||= :archetype
      end

      module Archetype0
        def arch_identification
          elements[0]
        end

        def spec
          elements[1]
        end

        def arch_concept
          elements[2]
        end

        def lang
          elements[3]
        end

        def desc
          elements[4]
        end

        def arch_definition
          elements[5]
        end

        def arch_ontology
          elements[7]
        end
      end

      module Archetype1
        def archetype_id
          arch_identification.archetype_id
        end

        def adl_version
          arch_identification.adl_version
        end

	  def concept
	    arch_concept.value
	  end

	  def original_language
          lang.value.original_language unless lang.empty?
        end

        def translations
          lang.value.translations unless lang.empty?
        end

        def description
          desc.value unless desc.empty?
        end

        def definition
          arch_definition.value
        end

        def ontology
          arch_ontology.value
        end
      end

      def _nt_archetype
        start_index = index
        if node_cache[:archetype].has_key?(index)
          cached = node_cache[:archetype][index]
          if cached
            node_cache[:archetype][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_arch_identification
        s0 << r1
        if r1
          r3 = _nt_arch_specialisation
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_arch_concept
            s0 << r4
            if r4
              r6 = _nt_arch_language
              if r6
                r5 = r6
              else
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
              if r5
                r8 = _nt_arch_description
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r9 = _nt_arch_definition
                  s0 << r9
                  if r9
                    r11 = _nt_arch_invariant
                    if r11
                      r10 = r11
                    else
                      r10 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r10
                    if r10
                      r12 = _nt_arch_ontology
                      s0 << r12
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Archetype0)
          r0.extend(Archetype1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:archetype][start_index] = r0

        r0
      end

      module ArchIdentification0
        def head
          elements[0]
        end

        def id
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchIdentification1
	  def archetype_id
        id.value
	  end

	  def adl_version
	    head.value[:adl_version]
	  end

      def is_controlled?
        head.value[:is_controlled?]
      end
      end

      def _nt_arch_identification
        start_index = index
        if node_cache[:arch_identification].has_key?(index)
          cached = node_cache[:arch_identification][index]
          if cached
            node_cache[:arch_identification][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_arch_head
        s0 << r1
        if r1
          r2 = _nt_V_ARCHETYPE_ID
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchIdentification0)
          r0.extend(ArchIdentification1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_identification][start_index] = r0

        r0
      end

      module ArchHead0
        def SYM_ARCHETYPE
          elements[0]
        end

        def m
          elements[1]
        end
      end

      module ArchHead1
	  def value
        m.value
	  end
      end

      module ArchHead2
        def value
          Hash.new
        end
      end

      def _nt_arch_head
        start_index = index
        if node_cache[:arch_head].has_key?(index)
          cached = node_cache[:arch_head][index]
          if cached
            node_cache[:arch_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_ARCHETYPE
        s1 << r2
        if r2
          r3 = _nt_arch_meta_data
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArchHead0)
          r1.extend(ArchHead1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r4 = _nt_SYM_ARCHETYPE
          r4.extend(ArchHead2)
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:arch_head][start_index] = r0

        r0
      end

      module ArchMetaData0
        def arch_meta_data_items
          elements[1]
        end

        def space
          elements[3]
        end
      end

      module ArchMetaData1
	   def value
        arch_meta_data_items.value
      end
      end

      def _nt_arch_meta_data
        start_index = index
        if node_cache[:arch_meta_data].has_key?(index)
          cached = node_cache[:arch_meta_data][index]
          if cached
            node_cache[:arch_meta_data][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_arch_meta_data_items
          s0 << r2
          if r2
            if (match_len = has_terminal?(')', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure(')')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_space
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchMetaData0)
          r0.extend(ArchMetaData1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_meta_data][start_index] = r0

        r0
      end

      module ArchMetaDataItems0
        def arch_meta_data_item
          elements[1]
        end
      end

      module ArchMetaDataItems1
        def item
          elements[0]
        end

        def other_item
          elements[1]
        end
      end

      module ArchMetaDataItems2
        def value
	    v = item.value
          other_item.elements.map {|i| i.arch_meta_data_item.value}
          v
	  end
      end

      def _nt_arch_meta_data_items
        start_index = index
        if node_cache[:arch_meta_data_items].has_key?(index)
          cached = node_cache[:arch_meta_data_items][index]
          if cached
            node_cache[:arch_meta_data_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_arch_meta_data_item
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?(';', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(';')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_arch_meta_data_item
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(ArchMetaDataItems0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchMetaDataItems1)
          r0.extend(ArchMetaDataItems2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_meta_data_items][start_index] = r0

        r0
      end

      module ArchMetaDataItem0
        def SYM_ADL_VERSION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def ver
          elements[2]
        end

        def space
          elements[3]
        end
      end

      module ArchMetaDataItem1
	  def value
        {:adl_version => ver.value}
      end
      end

      module ArchMetaDataItem2
        def SYM_IS_CONTROLED
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module ArchMetaDataItem3
        def value
	    {:is_controled? => true} # if elements[0]
        end
      end

      def _nt_arch_meta_data_item
        start_index = index
        if node_cache[:arch_meta_data_item].has_key?(index)
          cached = node_cache[:arch_meta_data_item][index]
          if cached
            node_cache[:arch_meta_data_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_ADL_VERSION
        s1 << r2
        if r2
          r3 = _nt_SYM_EQ
          s1 << r3
          if r3
            r4 = _nt_V_VERSION_STRING
            s1 << r4
            if r4
              r5 = _nt_space
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArchMetaDataItem0)
          r1.extend(ArchMetaDataItem1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_SYM_IS_CONTROLED
          s6 << r7
          if r7
            r8 = _nt_space
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(ArchMetaDataItem2)
            r6.extend(ArchMetaDataItem3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:arch_meta_data_item][start_index] = r0

        r0
      end

      module ArchSpecialisation0
        def SYM_SPECIALIZE
          elements[0]
        end

        def arch_id
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchSpecialisation1
	  def specialised?
	    true if elements[0]
        end

	  def archetype_id
	    arch_id.value
	  end
      end

      def _nt_arch_specialisation
        start_index = index
        if node_cache[:arch_specialisation].has_key?(index)
          cached = node_cache[:arch_specialisation][index]
          if cached
            node_cache[:arch_specialisation][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_SPECIALIZE
        s0 << r1
        if r1
          r2 = _nt_V_ARCHETYPE_ID
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchSpecialisation0)
          r0.extend(ArchSpecialisation1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_specialisation][start_index] = r0

        r0
      end

      module ArchConcept0
        def SYM_CONCEPT
          elements[0]
        end

        def conc
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchConcept1
	  def value
        conc.text_value[1..-2]
      end
      end

      def _nt_arch_concept
        start_index = index
        if node_cache[:arch_concept].has_key?(index)
          cached = node_cache[:arch_concept][index]
          if cached
            node_cache[:arch_concept][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_CONCEPT
        s0 << r1
        if r1
          r2 = _nt_V_LOCAL_TERM_CODE_REF
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchConcept0)
          r0.extend(ArchConcept1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_concept][start_index] = r0

        r0
      end

      module ArchLanguage0
        def SYM_LANGUAGE
          elements[0]
        end

        def lang
          elements[1]
        end
      end

      def _nt_arch_language
        start_index = index
        if node_cache[:arch_language].has_key?(index)
          cached = node_cache[:arch_language][index]
          if cached
            node_cache[:arch_language][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_LANGUAGE
        s0 << r1
        if r1
          r2 = _nt_V_DADL_TEXT
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(ArchLanguage,input, i0...index, s0)
          r0.extend(ArchLanguage0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_language][start_index] = r0

        r0
      end

      module ArchDescription0
        def SYM_DESCRIPTION
          elements[0]
        end

        def desc
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchDescription1
        def value
          params = desc.value
          details = { }
          params['details'].each do |lang, attrs|
            misuse = attrs['misuse']
            misuse = nil if misuse.nil? or misuse.empty?
            use = attrs['use']
            use = nil if use.nil? or use.empty?
            purpose = attrs['purpose'] || '__unknown__' # for backward compat.
            item =
              OpenEHR::RM::Common::Resource::ResourceDescriptionItem.new(
                :language => attrs['language'],
                :purpose => purpose,
                :keywords => attrs["keywords"],
                :use => use,
                :misuse => misuse,
                :copyright => attrs['copyright'],
                :original_resource_uri => attrs['original_resource_uri'],
                :other_details => attrs['other_details'])
            details[lang] = item
          end
          oc = params['other_contributors']
          if oc.instance_of? Hash
            oc = oc.values
          end
          OpenEHR::RM::Common::Resource::ResourceDescription.new(
            :original_author => params['original_author'],
            :other_contributors => oc,
            :lifecycle_state => params['lifecycle_state'],
            :details => details,
            :resource_package_uri => params['archetype_package_uri'],
            :other_details => params['other_details'])
        end
      end

      def _nt_arch_description
        start_index = index
        if node_cache[:arch_description].has_key?(index)
          cached = node_cache[:arch_description][index]
          if cached
            node_cache[:arch_description][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_DESCRIPTION
        s0 << r1
        if r1
          r2 = _nt_V_DADL_TEXT
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchDescription0)
          r0.extend(ArchDescription1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_description][start_index] = r0

        r0
      end

      module ArchDefinition0
        def SYM_DEFINITION
          elements[0]
        end

        def definition
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchDefinition1
        def value
          definition.value
        end
      end

      def _nt_arch_definition
        start_index = index
        if node_cache[:arch_definition].has_key?(index)
          cached = node_cache[:arch_definition][index]
          if cached
            node_cache[:arch_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_DEFINITION
        s0 << r1
        if r1
          r2 = _nt_V_CADL_TEXT
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchDefinition0)
          r0.extend(ArchDefinition1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_definition][start_index] = r0

        r0
      end

      module ArchInvariant0
        def SYM_INVARIANT
          elements[0]
        end

        def V_ASSERTION_TEXT
          elements[1]
        end

        def space
          elements[2]
        end
      end

      def _nt_arch_invariant
        start_index = index
        if node_cache[:arch_invariant].has_key?(index)
          cached = node_cache[:arch_invariant][index]
          if cached
            node_cache[:arch_invariant][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_INVARIANT
        s0 << r1
        if r1
          r2 = _nt_V_ASSERTION_TEXT
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchInvariant0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_invariant][start_index] = r0

        r0
      end

      module ArchOntology0
        def SYM_ONTOLOGY
          elements[0]
        end

        def ontology
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module ArchOntology1
        def value
          ao = ontology.value
          arc_term = Proc.new do |code, item|
            OpenEHR::AM::Archetype::Ontology::ArchetypeTerm.new(
                     :code => code, :items => item)
          end
          td = itemizer(ao['term_definitions'], arc_term)
          cd = ao['constraint_definitions']
          if cd
            cd = itemizer(cd , arc_term)
          end
          tb = ao['term_bindings'] || ao['term_binding']
          term_bind = Proc.new do |code, item|
            unless item.class == Array
              [item]
            else
              item
            end
          end
          if tb
            tb = itemizer(tb, term_bind)
          end
          cons_bind = Proc.new do |code, item|
	      OpenEHR::RM::DataTypes::URI::DvUri.new(:value => item)
          end
          cb = ao['constraint_bindings'] || ao['constraint_binding']
          if cb
            cb = itemizer(cb, cons_bind)
          end
          OpenEHR::AM::Archetype::Ontology::ArchetypeOntology.new(
            :primary_language => ao['primary_language'],
            :languages_available => ao['languages_available'],
            :terminologies_available => ao['terminologies_available'],
            :term_definitions => td,
            :constraint_definitions => cd,
            :term_bindings => tb,
            :constraint_bindings => cb)
        end

         def itemizer(defs, itemize)
           defs.inject({ }) do |term_defs, langs|
             lang, items = langs
             terms = items['items'].inject({ }) do |items, term|
               code, item = term
               item = itemize.call code, item
               items.update Hash[code => item]
             end
             term_defs.update Hash[lang => terms]
           end
         end
      end

      def _nt_arch_ontology
        start_index = index
        if node_cache[:arch_ontology].has_key?(index)
          cached = node_cache[:arch_ontology][index]
          if cached
            node_cache[:arch_ontology][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_ONTOLOGY
        s0 << r1
        if r1
          r2 = _nt_V_DADL_TEXT
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ArchOntology0)
          r0.extend(ArchOntology1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:arch_ontology][start_index] = r0

        r0
      end

      module VCADLTEXT0
        def c_complex_object
          elements[0]
        end

      end

      module VCADLTEXT1
        def value
          c_complex_object.value
        end
      end

      module VCADLTEXT2
        def assertions
          elements[0]
        end

      end

      module VCADLTEXT3
        def value
          assertions.value
        end
      end

      def _nt_V_CADL_TEXT
        start_index = index
        if node_cache[:V_CADL_TEXT].has_key?(index)
          cached = node_cache[:V_CADL_TEXT][index]
          if cached
            node_cache[:V_CADL_TEXT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_complex_object
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VCADLTEXT0)
          r1.extend(VCADLTEXT1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_assertions
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(VCADLTEXT2)
            r4.extend(VCADLTEXT3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:V_CADL_TEXT][start_index] = r0

        r0
      end

      module CComplexObject0
        def head
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def body
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module CComplexObject1
        def value(node = ArchetypeNode.new)
          args = head.value
          args[:occurrences] ||= OpenEHR::AssumedLibraryTypes::Interval.new(
            :lower => 1, :upper => 1, :lower_included => true, :upper_included => true)
          node.id = args[:node_id]
          if node.root? or node.id.nil?
            args[:path] = node.path
          else
            args[:path] = node.path + '[' + node.id + ']'
          end
          args.update body.value(node)
          OpenEHR::AM::Archetype::ConstraintModel::CComplexObject.new(args)
        end
      end

      module CComplexObject2
        def c_complex_object_head
          elements[0]
        end

      end

      module CComplexObject3
        def value(node = ArchetypeNode.new)
          args = c_complex_object_head.value
          args[:occurrences] ||= OpenEHR::AssumedLibraryTypes::Interval.new(
            :lower => 1, :upper => 1, :lower_included => true, :upper_included => true)
          node.id = args[:node_id]
          args[:path] = node.path
          OpenEHR::AM::Archetype::ConstraintModel::CComplexObject.new(args)
        end
      end

      def _nt_c_complex_object
        start_index = index
        if node_cache[:c_complex_object].has_key?(index)
          cached = node_cache[:c_complex_object][index]
          if cached
            node_cache[:c_complex_object][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_complex_object_head
        s1 << r2
        if r2
          r3 = _nt_SYM_MATCHES
          s1 << r3
          if r3
            r4 = _nt_SYM_START_CBLOCK
            s1 << r4
            if r4
              r5 = _nt_c_complex_object_body
              s1 << r5
              if r5
                r6 = _nt_SYM_END_CBLOCK
                s1 << r6
                if r6
                  r7 = _nt_space
                  s1 << r7
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CComplexObject0)
          r1.extend(CComplexObject1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_c_complex_object_head
          s8 << r9
          if r9
            if (match_len = has_terminal?('', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r10 = nil
            end
            s8 << r10
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(CComplexObject2)
            r8.extend(CComplexObject3)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_complex_object][start_index] = r0

        r0
      end

      module CComplexObjectHead0
        def c_complex_object_id
          elements[0]
        end

        def c_occurrences
          elements[1]
        end
      end

      module CComplexObjectHead1
        def value
          args = c_complex_object_id.value
          args[:occurrences] = c_occurrences.value
          args
        end
      end

      module CComplexObjectHead2
        def c_complex_object_id
          elements[0]
        end

      end

      module CComplexObjectHead3
        def value
          c_complex_object_id.value
        end
      end

      def _nt_c_complex_object_head
        start_index = index
        if node_cache[:c_complex_object_head].has_key?(index)
          cached = node_cache[:c_complex_object_head][index]
          if cached
            node_cache[:c_complex_object_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_complex_object_id
        s1 << r2
        if r2
          r3 = _nt_c_occurrences
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CComplexObjectHead0)
          r1.extend(CComplexObjectHead1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_c_complex_object_id
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CComplexObjectHead2)
            r4.extend(CComplexObjectHead3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_complex_object_head][start_index] = r0

        r0
      end

      module CComplexObjectId0
        def ti
          elements[0]
        end

        def lo
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module CComplexObjectId1
        def value
          {:rm_type_name => ti.value,
           :node_id => lo.value}
        end
      end

      module CComplexObjectId2
        def ti
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module CComplexObjectId3
        def value
          {:rm_type_name => ti.value}
        end
      end

      def _nt_c_complex_object_id
        start_index = index
        if node_cache[:c_complex_object_id].has_key?(index)
          cached = node_cache[:c_complex_object_id][index]
          if cached
            node_cache[:c_complex_object_id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_type_identifier
        s1 << r2
        if r2
          r3 = _nt_V_LOCAL_TERM_CODE_REF
          s1 << r3
          if r3
            r4 = _nt_space
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CComplexObjectId0)
          r1.extend(CComplexObjectId1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_type_identifier
          s5 << r6
          if r6
            r7 = _nt_space
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(CComplexObjectId2)
            r5.extend(CComplexObjectId3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_complex_object_id][start_index] = r0

        r0
      end

      module CComplexObjectBody0
        def c_any
          elements[0]
        end

      end

      module CComplexObjectBody1
        def value(node)
          Hash[:attributes => [c_any.value(node)]]
        end
      end

      module CComplexObjectBody2
        def c_attributes
          elements[0]
        end

      end

      module CComplexObjectBody3
        def value(node)
          Hash[:attributes => c_attributes.value(node)]
        end
      end

      def _nt_c_complex_object_body
        start_index = index
        if node_cache[:c_complex_object_body].has_key?(index)
          cached = node_cache[:c_complex_object_body][index]
          if cached
            node_cache[:c_complex_object_body][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_any
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CComplexObjectBody0)
          r1.extend(CComplexObjectBody1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_c_attributes
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CComplexObjectBody2)
            r4.extend(CComplexObjectBody3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_complex_object_body][start_index] = r0

        r0
      end

      module CObject0
        def c_dv_quantity
          elements[0]
        end

      end

      module CObject1
        def value(node)
          c_dv_quantity.value(node)
        end
      end

      module CObject2
        def c_ordinal
          elements[0]
        end

      end

      module CObject3
        def value(node)
          args = c_ordinal.value
          args[:path] = node.path
          args[:rm_type_name] = 'DV_ORDINAL'
          args[:occurrences] ||= OpenEHR::AssumedLibraryTypes::Interval.new(
            :upper => 1, :lower => 1, :lower_included => true, :upper_included => true)
          OpenEHR::AM::OpenEHRProfile::DataTypes::Quantity::CDvOrdinal.new(
           args)
        end
      end

      module CObject4
        def c_primitive_object
          elements[0]
        end

      end

      module CObject5
        def value(node)
          c_primitive_object.value(node)
        end
      end

      module CObject6
        def c_complex_object
          elements[0]
        end

      end

      module CObject7
        def value(node)
          c_complex_object.value(node)
        end
      end

      module CObject8
        def c_code_phrase
          elements[0]
        end

      end

      module CObject9
        def value(node)
          c_code_phrase.value(node)
        end
      end

      module CObject10
        def constraint_ref
          elements[0]
        end

      end

      module CObject11
        def value(node)
          constraint_ref.value(node)
        end
      end

      module CObject12
        def archetype_slot
          elements[0]
        end

      end

      module CObject13
        def value(node)
          archetype_slot.value(node)
        end
      end

      module CObject14
        def archetype_internal_ref
          elements[0]
        end

      end

      module CObject15
        def value(node = nil)
          archetype_internal_ref.value(node)
        end
      end

      module CObject16
        def V_C_DOMAIN_TYPE
          elements[0]
        end

      end

      module CObject17
        def value(node = nil)
          p elemetns
        end
      end

      def _nt_c_object
        start_index = index
        if node_cache[:c_object].has_key?(index)
          cached = node_cache[:c_object][index]
          if cached
            node_cache[:c_object][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_dv_quantity
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CObject0)
          r1.extend(CObject1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_c_ordinal
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CObject2)
            r4.extend(CObject3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_c_primitive_object
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CObject4)
              r7.extend(CObject5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_c_complex_object
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(CObject6)
                r10.extend(CObject7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_c_code_phrase
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(CObject8)
                  r13.extend(CObject9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_constraint_ref
                  s16 << r17
                  if r17
                    if (match_len = has_terminal?('', false, index))
                      r18 = true
                      @index += match_len
                    else
                      terminal_parse_failure('')
                      r18 = nil
                    end
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(CObject10)
                    r16.extend(CObject11)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    i19, s19 = index, []
                    r20 = _nt_archetype_slot
                    s19 << r20
                    if r20
                      if (match_len = has_terminal?('', false, index))
                        r21 = true
                        @index += match_len
                      else
                        terminal_parse_failure('')
                        r21 = nil
                      end
                      s19 << r21
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(CObject12)
                      r19.extend(CObject13)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                      r0 = r19
                    else
                      i22, s22 = index, []
                      r23 = _nt_archetype_internal_ref
                      s22 << r23
                      if r23
                        if (match_len = has_terminal?('', false, index))
                          r24 = true
                          @index += match_len
                        else
                          terminal_parse_failure('')
                          r24 = nil
                        end
                        s22 << r24
                      end
                      if s22.last
                        r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                        r22.extend(CObject14)
                        r22.extend(CObject15)
                      else
                        @index = i22
                        r22 = nil
                      end
                      if r22
                        r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                        r0 = r22
                      else
                        i25, s25 = index, []
                        r26 = _nt_V_C_DOMAIN_TYPE
                        s25 << r26
                        if r26
                          if (match_len = has_terminal?('', false, index))
                            r27 = true
                            @index += match_len
                          else
                            terminal_parse_failure('')
                            r27 = nil
                          end
                          s25 << r27
                        end
                        if s25.last
                          r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                          r25.extend(CObject16)
                          r25.extend(CObject17)
                        else
                          @index = i25
                          r25 = nil
                        end
                        if r25
                          r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
                          r0 = r25
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:c_object][start_index] = r0

        r0
      end

      module ArchetypeInternalRef0
        def SYM_USE_NODE
          elements[0]
        end

        def type_identifier
          elements[1]
        end

        def c_occurrences
          elements[2]
        end

        def object_path
          elements[3]
        end

        def space
          elements[4]
        end
      end

      module ArchetypeInternalRef1
        def value(node)
          OpenEHR::AM::Archetype::ConstraintModel::ArchetypeInternalRef.new(
            :rm_type_name => type_identifier.value,
            :occurrences => c_occurrences.value,
            :path => node.path,
            :target_path => object_path.value)
        end
      end

      module ArchetypeInternalRef2
        def SYM_USE_NODE
          elements[0]
        end

        def type_identifier
          elements[1]
        end

        def object_path
          elements[2]
        end

        def space
          elements[3]
        end
      end

      module ArchetypeInternalRef3
        def value(node = nil)
          OpenEHR::AM::Archetype::ConstraintModel::ArchetypeInternalRef.new(
            :rm_type_name => type_identifier.value,
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => 1, :upper => 1, :lower_included => true, :upper_included => true),
            :path => node.path,
            :target_path => object_path.value)
         end
      end

      def _nt_archetype_internal_ref
        start_index = index
        if node_cache[:archetype_internal_ref].has_key?(index)
          cached = node_cache[:archetype_internal_ref][index]
          if cached
            node_cache[:archetype_internal_ref][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_USE_NODE
        s1 << r2
        if r2
          r3 = _nt_type_identifier
          s1 << r3
          if r3
            r4 = _nt_c_occurrences
            s1 << r4
            if r4
              r5 = _nt_object_path
              s1 << r5
              if r5
                r6 = _nt_space
                s1 << r6
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArchetypeInternalRef0)
          r1.extend(ArchetypeInternalRef1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_SYM_USE_NODE
          s7 << r8
          if r8
            r9 = _nt_type_identifier
            s7 << r9
            if r9
              r10 = _nt_object_path
              s7 << r10
              if r10
                r11 = _nt_space
                s7 << r11
              end
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(ArchetypeInternalRef2)
            r7.extend(ArchetypeInternalRef3)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:archetype_internal_ref][start_index] = r0

        r0
      end

      module ArchetypeSlot0
        def c_archetype_slot_head
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def c_includes
          elements[3]
        end

        def c_excludes
          elements[4]
        end

        def SYM_END_CBLOCK
          elements[5]
        end

        def space
          elements[6]
        end
      end

      module ArchetypeSlot1
        def value(node)
          args = c_archetype_slot_head.value(node)
          args[:includes] = c_includes.value
          args[:excludes] = c_excludes.value
          OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
        end
      end

      module ArchetypeSlot2
        def c_archetype_slot_head
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def c_includes
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module ArchetypeSlot3
        def value(node)
          args = c_archetype_slot_head.value(node)
          args[:includes] = c_includes.value
          OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
        end
      end

      module ArchetypeSlot4
        def c_archetype_slot_head
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def c_excludes
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module ArchetypeSlot5
        def value(node)
          args = c_archetype_slot_head.value(node)
          args[:excludes] = c_excludes.value
          OpenEHR::AM::Archetype::ConstraintModel::ArchetypeSlot.new(args)
        end
      end

      def _nt_archetype_slot
        start_index = index
        if node_cache[:archetype_slot].has_key?(index)
          cached = node_cache[:archetype_slot][index]
          if cached
            node_cache[:archetype_slot][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_archetype_slot_head
        s1 << r2
        if r2
          r3 = _nt_SYM_MATCHES
          s1 << r3
          if r3
            r4 = _nt_SYM_START_CBLOCK
            s1 << r4
            if r4
              r5 = _nt_c_includes
              s1 << r5
              if r5
                r6 = _nt_c_excludes
                s1 << r6
                if r6
                  r7 = _nt_SYM_END_CBLOCK
                  s1 << r7
                  if r7
                    r8 = _nt_space
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArchetypeSlot0)
          r1.extend(ArchetypeSlot1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_c_archetype_slot_head
          s9 << r10
          if r10
            r11 = _nt_SYM_MATCHES
            s9 << r11
            if r11
              r12 = _nt_SYM_START_CBLOCK
              s9 << r12
              if r12
                r13 = _nt_c_includes
                s9 << r13
                if r13
                  r14 = _nt_SYM_END_CBLOCK
                  s9 << r14
                  if r14
                    r15 = _nt_space
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(ArchetypeSlot2)
            r9.extend(ArchetypeSlot3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_c_archetype_slot_head
            s16 << r17
            if r17
              r18 = _nt_SYM_MATCHES
              s16 << r18
              if r18
                r19 = _nt_SYM_START_CBLOCK
                s16 << r19
                if r19
                  r20 = _nt_c_excludes
                  s16 << r20
                  if r20
                    r21 = _nt_SYM_END_CBLOCK
                    s16 << r21
                    if r21
                      r22 = _nt_space
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(ArchetypeSlot4)
              r16.extend(ArchetypeSlot5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:archetype_slot][start_index] = r0

        r0
      end

      module CArchetypeSlotHead0
        def c_archetype_slot_id
          elements[0]
        end

        def white_space
          elements[1]
        end

        def c_occurrences
          elements[2]
        end
      end

      module CArchetypeSlotHead1
        def value(node)
          args = c_archetype_slot_id.value(node)
          args[:occurrences] = c_occurrences.value
          args
        end
      end

      module CArchetypeSlotHead2
        def c_archetype_slot_id
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module CArchetypeSlotHead3
        def value(node)
          args = c_archetype_slot_id.value(node)
          args[:occurrences] = OpenEHR::AssumedLibraryTypes::Interval.new(
            :upper => 1, :lower => 1, :lower_included => true, :upper_included => true)
          args
        end
      end

      def _nt_c_archetype_slot_head
        start_index = index
        if node_cache[:c_archetype_slot_head].has_key?(index)
          cached = node_cache[:c_archetype_slot_head][index]
          if cached
            node_cache[:c_archetype_slot_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_archetype_slot_id
        s1 << r2
        if r2
          r3 = _nt_white_space
          s1 << r3
          if r3
            r4 = _nt_c_occurrences
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CArchetypeSlotHead0)
          r1.extend(CArchetypeSlotHead1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_c_archetype_slot_id
          s5 << r6
          if r6
            r7 = _nt_white_space
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(CArchetypeSlotHead2)
            r5.extend(CArchetypeSlotHead3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_archetype_slot_head][start_index] = r0

        r0
      end

      module CArchetypeSlotId0
        def SYM_ALLOW_ARCHETYPE
          elements[0]
        end

        def type_identifier
          elements[1]
        end

        def lt
          elements[2]
        end
      end

      module CArchetypeSlotId1
        def value(node)
          {:rm_type_name => type_identifier.value,
           :node_id => lt.value,
           :path => node.path + "[#{lt.value}]"}
        end
      end

      module CArchetypeSlotId2
        def SYM_ALLOW_ARCHETYPE
          elements[0]
        end

        def type_identifier
          elements[1]
        end
      end

      module CArchetypeSlotId3
        def value(node)
          {:rm_type_name => type_identifier.value,
           :path => node.path}
        end
      end

      def _nt_c_archetype_slot_id
        start_index = index
        if node_cache[:c_archetype_slot_id].has_key?(index)
          cached = node_cache[:c_archetype_slot_id][index]
          if cached
            node_cache[:c_archetype_slot_id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_ALLOW_ARCHETYPE
        s1 << r2
        if r2
          r3 = _nt_type_identifier
          s1 << r3
          if r3
            r4 = _nt_V_LOCAL_TERM_CODE_REF
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CArchetypeSlotId0)
          r1.extend(CArchetypeSlotId1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_SYM_ALLOW_ARCHETYPE
          s5 << r6
          if r6
            r7 = _nt_type_identifier
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(CArchetypeSlotId2)
            r5.extend(CArchetypeSlotId3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_archetype_slot_id][start_index] = r0

        r0
      end

      module CPrimitiveObject0
        def c_primitive
          elements[0]
        end

      end

      module CPrimitiveObject1
        def value(node)
          OpenEHR::AM::Archetype::ConstraintModel::CPrimitiveObject.new(
            {:item => c_primitive.value,
             :rm_type_name => c_primitive.value.type,
             :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                               :upper => 1, 
                               :lower => 1, 
                               :lower_included => true, 
                               :upper_included => true),
             :path => node.path})
        end
      end

      def _nt_c_primitive_object
        start_index = index
        if node_cache[:c_primitive_object].has_key?(index)
          cached = node_cache[:c_primitive_object][index]
          if cached
            node_cache[:c_primitive_object][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_c_primitive
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CPrimitiveObject0)
          r0.extend(CPrimitiveObject1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_primitive_object][start_index] = r0

        r0
      end

      module CPrimitive0
        def c_date_time
          elements[0]
        end

      end

      module CPrimitive1
        def value
          c_date_time.value
        end
      end

      module CPrimitive2
        def c_time
          elements[0]
        end

      end

      module CPrimitive3
        def value
          c_time.value
        end
      end

      module CPrimitive4
        def c_date
          elements[0]
        end

      end

      module CPrimitive5
        def value
          c_date.value
        end
      end

      module CPrimitive6
        def c_duration
          elements[0]
        end

      end

      module CPrimitive7
        def value
          c_duration.value
        end
      end

      module CPrimitive8
        def c_real
          elements[0]
        end

      end

      module CPrimitive9
        def value
          c_real.value
        end
      end

      module CPrimitive10
        def c_integer
          elements[0]
        end

      end

      module CPrimitive11
        def value
          c_integer.value
        end
      end

      module CPrimitive12
        def c_boolean
          elements[0]
        end

      end

      module CPrimitive13
        def value
          c_boolean.value
        end
      end

      module CPrimitive14
        def c_string
          elements[0]
        end

      end

      module CPrimitive15
        def value
          c_string.value
        end
      end

      def _nt_c_primitive
        start_index = index
        if node_cache[:c_primitive].has_key?(index)
          cached = node_cache[:c_primitive][index]
          if cached
            node_cache[:c_primitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_date_time
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CPrimitive0)
          r1.extend(CPrimitive1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_c_time
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CPrimitive2)
            r4.extend(CPrimitive3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_c_date
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CPrimitive4)
              r7.extend(CPrimitive5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_c_duration
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(CPrimitive6)
                r10.extend(CPrimitive7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_c_real
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(CPrimitive8)
                  r13.extend(CPrimitive9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_c_integer
                  s16 << r17
                  if r17
                    if (match_len = has_terminal?('', false, index))
                      r18 = true
                      @index += match_len
                    else
                      terminal_parse_failure('')
                      r18 = nil
                    end
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(CPrimitive10)
                    r16.extend(CPrimitive11)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    i19, s19 = index, []
                    r20 = _nt_c_boolean
                    s19 << r20
                    if r20
                      if (match_len = has_terminal?('', false, index))
                        r21 = true
                        @index += match_len
                      else
                        terminal_parse_failure('')
                        r21 = nil
                      end
                      s19 << r21
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(CPrimitive12)
                      r19.extend(CPrimitive13)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                      r0 = r19
                    else
                      i22, s22 = index, []
                      r23 = _nt_c_string
                      s22 << r23
                      if r23
                        if (match_len = has_terminal?('', false, index))
                          r24 = true
                          @index += match_len
                        else
                          terminal_parse_failure('')
                          r24 = nil
                        end
                        s22 << r24
                      end
                      if s22.last
                        r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                        r22.extend(CPrimitive14)
                        r22.extend(CPrimitive15)
                      else
                        @index = i22
                        r22 = nil
                      end
                      if r22
                        r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                        r0 = r22
                      else
                        @index = i0
                        r0 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:c_primitive][start_index] = r0

        r0
      end

      module CAny0
        def space
          elements[1]
        end
      end

      module CAny1
        def value(node)
          OpenEHR::AM::Archetype::ConstraintModel::CAttribute.new(
            :path => node.path, :rm_attribute_name => 'ANY',
            :existence => OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => 1, :upper => 1, :lower_included => true, :upper_included => true))
        end
      end

      def _nt_c_any
        start_index = index
        if node_cache[:c_any].has_key?(index)
          cached = node_cache[:c_any][index]
          if cached
            node_cache[:c_any][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('*', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('*')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CAny0)
          r0.extend(CAny1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_any][start_index] = r0

        r0
      end

      module CAttributes0
        def c_attribute
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module CAttributes1
        def c_attribute
          elements[0]
        end

        def more_attr
          elements[1]
        end
      end

      module CAttributes2
        def value(node)
          attributes.map {|c| c.value(node)}
        end

        def attributes
          [c_attribute] + more_attr.elements.map {|e| e.c_attribute}
        end
      end

      def _nt_c_attributes
        start_index = index
        if node_cache[:c_attributes].has_key?(index)
          cached = node_cache[:c_attributes][index]
          if cached
            node_cache[:c_attributes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_c_attribute
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_c_attribute
            s3 << r4
            if r4
              r5 = _nt_white_space
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(CAttributes0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CAttributes1)
          r0.extend(CAttributes2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_attributes][start_index] = r0

        r0
      end

      module CAttribute0
        def c_attr_head
          elements[0]
        end

        def c_attr_body
          elements[1]
        end
      end

      module CAttribute1
        def value(node)
          val = c_attr_head.value(node)
          child_node = ArchetypeNode.new(node)
          child_node.path = val.path
          val.children = c_attr_body.value(child_node)
	    val
        end
      end

      def _nt_c_attribute
        start_index = index
        if node_cache[:c_attribute].has_key?(index)
          cached = node_cache[:c_attribute][index]
          if cached
            node_cache[:c_attribute][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_c_attr_head
        s0 << r1
        if r1
          r2 = _nt_c_attr_body
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CAttribute0)
          r0.extend(CAttribute1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_attribute][start_index] = r0

        r0
      end

      module CAttrHead0
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end

        def c_existence
          elements[2]
        end

        def c_cardinality
          elements[3]
        end
      end

      module CAttrHead1
        def value(node)
          if node.root?
            path = node.path + id.value
          elsif node.id
            path = node.path + "[#{node.id}]/" + id.value
          elsif
            path = node.path + '/' + id.value
          end
          OpenEHR::AM::Archetype::ConstraintModel::CMultipleAttribute.new(
           :rm_attribute_name => id.value,
           :path => path,
           :existence => c_existence.value,
           :cardinality => c_cardinality.value)
        end
      end

      module CAttrHead2
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end

        def c_existence
          elements[2]
        end
      end

      module CAttrHead3
        def value(node)
          if node.root?
            path = node.path + id.value
          elsif node.id
            path = node.path + "[#{node.id}]/" + id.value
          elsif
            path = node.path + '/' + id.value
          end
          OpenEHR::AM::Archetype::ConstraintModel::CSingleAttribute.new(
           :rm_attribute_name => id.value,
           :path => path,
           :existence => c_existence.value)
        end
      end

      module CAttrHead4
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end

        def c_cardinality
          elements[2]
        end
      end

      module CAttrHead5
        def value(node)
          if node.root?
            path = node.path + id.value
          elsif node.id
            path = node.path + "[#{node.id}]/" + id.value
          elsif
            path = node.path + '/' + id.value
          end
          OpenEHR::AM::Archetype::ConstraintModel::CMultipleAttribute.new(
           :rm_attribute_name => id.value,
           :path => path,
           :cardinality => c_cardinality.value)
        end
      end

      module CAttrHead6
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module CAttrHead7
        def value(node)
          if node.root?
            path = node.path + id.value
          elsif node.id
            path = node.path + "[#{node.id}]/" + id.value
          elsif
            path = node.path + '/' + id.value
          end
          OpenEHR::AM::Archetype::ConstraintModel::CSingleAttribute.new(
           :rm_attribute_name => id.value, :path => path)
        end
      end

      def _nt_c_attr_head
        start_index = index
        if node_cache[:c_attr_head].has_key?(index)
          cached = node_cache[:c_attr_head][index]
          if cached
            node_cache[:c_attr_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_V_ATTRIBUTE_IDENTIFIER
        s1 << r2
        if r2
          r3 = _nt_white_space
          s1 << r3
          if r3
            r4 = _nt_c_existence
            s1 << r4
            if r4
              r5 = _nt_c_cardinality
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CAttrHead0)
          r1.extend(CAttrHead1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_V_ATTRIBUTE_IDENTIFIER
          s6 << r7
          if r7
            r8 = _nt_white_space
            s6 << r8
            if r8
              r9 = _nt_c_existence
              s6 << r9
            end
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CAttrHead2)
            r6.extend(CAttrHead3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            i10, s10 = index, []
            r11 = _nt_V_ATTRIBUTE_IDENTIFIER
            s10 << r11
            if r11
              r12 = _nt_white_space
              s10 << r12
              if r12
                r13 = _nt_c_cardinality
                s10 << r13
              end
            end
            if s10.last
              r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
              r10.extend(CAttrHead4)
              r10.extend(CAttrHead5)
            else
              @index = i10
              r10 = nil
            end
            if r10
              r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
              r0 = r10
            else
              i14, s14 = index, []
              r15 = _nt_V_ATTRIBUTE_IDENTIFIER
              s14 << r15
              if r15
                r16 = _nt_white_space
                s14 << r16
              end
              if s14.last
                r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                r14.extend(CAttrHead6)
                r14.extend(CAttrHead7)
              else
                @index = i14
                r14 = nil
              end
              if r14
                r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                r0 = r14
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_attr_head][start_index] = r0

        r0
      end

      module CAttrBody0
        def SYM_MATCHES
          elements[0]
        end

        def SYM_START_CBLOCK
          elements[1]
        end

        def c_attr_values
          elements[2]
        end

        def SYM_END_CBLOCK
          elements[3]
        end

        def space
          elements[4]
        end
      end

      module CAttrBody1
        def value(node)
          c_attr_values.value(node)
        end
      end

      def _nt_c_attr_body
        start_index = index
        if node_cache[:c_attr_body].has_key?(index)
          cached = node_cache[:c_attr_body][index]
          if cached
            node_cache[:c_attr_body][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_MATCHES
        s0 << r1
        if r1
          r2 = _nt_SYM_START_CBLOCK
          s0 << r2
          if r2
            r3 = _nt_c_attr_values
            s0 << r3
            if r3
              r4 = _nt_SYM_END_CBLOCK
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CAttrBody0)
          r0.extend(CAttrBody1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_attr_body][start_index] = r0

        r0
      end

      module CAttrValues0
        def c_any
          elements[0]
        end

      end

      module CAttrValues1
        def value(node)
          [c_any.value(node)]
        end
      end

      module CAttrValues2
        def c_object
          elements[0]
        end

      end

      module CAttrValues3
        def c_object
          elements[0]
        end

        def more_co
          elements[1]
        end
      end

      module CAttrValues4
        def value(node)
          c_objects.map {|c| c.value(node)}
        end

        def c_objects
          [c_object] + more_co.elements.map {|e| e.c_object }
        end
      end

      def _nt_c_attr_values
        start_index = index
        if node_cache[:c_attr_values].has_key?(index)
          cached = node_cache[:c_attr_values][index]
          if cached
            node_cache[:c_attr_values][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_any
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CAttrValues0)
          r1.extend(CAttrValues1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_c_object
          s4 << r5
          if r5
            s6, i6 = [], index
            loop do
              i7, s7 = index, []
              r8 = _nt_c_object
              s7 << r8
              if r8
                if (match_len = has_terminal?('', false, index))
                  r9 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r9 = nil
                end
                s7 << r9
              end
              if s7.last
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                r7.extend(CAttrValues2)
              else
                @index = i7
                r7 = nil
              end
              if r7
                s6 << r7
              else
                break
              end
            end
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CAttrValues3)
            r4.extend(CAttrValues4)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_attr_values][start_index] = r0

        r0
      end

      module CIncludes0
        def SYM_INCLUDE
          elements[0]
        end

        def assertions
          elements[1]
        end
      end

      module CIncludes1
        def value
          assertions.value
        end
      end

      def _nt_c_includes
        start_index = index
        if node_cache[:c_includes].has_key?(index)
          cached = node_cache[:c_includes][index]
          if cached
            node_cache[:c_includes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_INCLUDE
        s0 << r1
        if r1
          r2 = _nt_assertions
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CIncludes0)
          r0.extend(CIncludes1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_includes][start_index] = r0

        r0
      end

      module CExcludes0
        def SYM_EXCLUDE
          elements[0]
        end

        def assertions
          elements[1]
        end
      end

      module CExcludes1
        def value
          assertions.value
        end
      end

      def _nt_c_excludes
        start_index = index
        if node_cache[:c_excludes].has_key?(index)
          cached = node_cache[:c_excludes][index]
          if cached
            node_cache[:c_excludes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_EXCLUDE
        s0 << r1
        if r1
          r2 = _nt_assertions
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CExcludes0)
          r0.extend(CExcludes1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_excludes][start_index] = r0

        r0
      end

      module CExistence0
        def SYM_EXISTENCE
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def existence_spec
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module CExistence1
        def value
          existence_spec.value
        end
      end

      def _nt_c_existence
        start_index = index
        if node_cache[:c_existence].has_key?(index)
          cached = node_cache[:c_existence][index]
          if cached
            node_cache[:c_existence][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_EXISTENCE
        s0 << r1
        if r1
          r2 = _nt_SYM_MATCHES
          s0 << r2
          if r2
            r3 = _nt_SYM_START_CBLOCK
            s0 << r3
            if r3
              r4 = _nt_existence_spec
              s0 << r4
              if r4
                r5 = _nt_SYM_END_CBLOCK
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CExistence0)
          r0.extend(CExistence1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_existence][start_index] = r0

        r0
      end

      module ExistenceSpec0
        def lo
          elements[0]
        end

        def SYM_ELLIPSIS
          elements[1]
        end

        def up
          elements[2]
        end
      end

      module ExistenceSpec1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
            :lower => lo.value, 
            :upper => up.value, 
            :lower_included => true, 
            :upper_included => true)
        end
      end

      module ExistenceSpec2
        def V_INTEGER
          elements[0]
        end

      end

      module ExistenceSpec3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
            :lower => V_INTEGER.value, 
            :upper => V_INTEGER.value, 
            :lower_included => true, 
            :upper_included => true)
        end
      end

      def _nt_existence_spec
        start_index = index
        if node_cache[:existence_spec].has_key?(index)
          cached = node_cache[:existence_spec][index]
          if cached
            node_cache[:existence_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_V_INTEGER
        s1 << r2
        if r2
          r3 = _nt_SYM_ELLIPSIS
          s1 << r3
          if r3
            r4 = _nt_V_INTEGER
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ExistenceSpec0)
          r1.extend(ExistenceSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_V_INTEGER
          s5 << r6
          if r6
            if (match_len = has_terminal?('', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r7 = nil
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(ExistenceSpec2)
            r5.extend(ExistenceSpec3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:existence_spec][start_index] = r0

        r0
      end

      module CCardinality0
        def SYM_CARDINALITY
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def cardinality_spec
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module CCardinality1
        def value
          cardinality_spec.value
        end
      end

      def _nt_c_cardinality
        start_index = index
        if node_cache[:c_cardinality].has_key?(index)
          cached = node_cache[:c_cardinality][index]
          if cached
            node_cache[:c_cardinality][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_CARDINALITY
        s0 << r1
        if r1
          r2 = _nt_SYM_MATCHES
          s0 << r2
          if r2
            r3 = _nt_SYM_START_CBLOCK
            s0 << r3
            if r3
              r4 = _nt_cardinality_spec
              s0 << r4
              if r4
                r5 = _nt_SYM_END_CBLOCK
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CCardinality0)
          r0.extend(CCardinality1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_cardinality][start_index] = r0

        r0
      end

      module CardinalitySpec0
        def occurrence_spec
          elements[0]
        end

        def white_space1
          elements[2]
        end

        def SYM_ORDERED
          elements[3]
        end

        def white_space2
          elements[5]
        end

        def SYM_UNIQUE
          elements[6]
        end
      end

      module CardinalitySpec1
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_unique => true,
            :is_orderd => true)
        end
      end

      module CardinalitySpec2
        def occurrence_spec
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_ORDERED
          elements[3]
        end
      end

      module CardinalitySpec3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_orderd => true)
        end
      end

      module CardinalitySpec4
        def occurrence_spec
          elements[0]
        end

        def white_space1
          elements[2]
        end

        def SYM_UNORDERD
          elements[3]
        end

        def white_space2
          elements[5]
        end

        def SYM_UNIQUE
          elements[6]
        end
      end

      module CardinalitySpec5
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_unique => true,
            :is_orderd => false)
        end
      end

      module CardinalitySpec6
        def occurrence_spec
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_UNORDERD
          elements[3]
        end
      end

      module CardinalitySpec7
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_orderd => false)
        end
      end

      module CardinalitySpec8
        def occurrence_spec
          elements[0]
        end

        def SYM_UNIQUE
          elements[1]
        end

        def white_space
          elements[3]
        end

        def SYM_ORDERED
          elements[4]
        end
      end

      module CardinalitySpec9
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_unique => true,
            :is_orderd => true)
        end
      end

      module CardinalitySpec10
        def occurrence_spec
          elements[0]
        end

        def SYM_UNIQUE
          elements[1]
        end

        def white_space
          elements[3]
        end

        def SYM_UNORDERD
          elements[4]
        end
      end

      module CardinalitySpec11
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_unique => true,
            :is_ordered => false)
        end
      end

      module CardinalitySpec12
        def occurrence_spec
          elements[0]
        end

        def SYM_UNIQUE
          elements[1]
        end
      end

      module CardinalitySpec13
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value,
            :is_unique => true)
        end
      end

      module CardinalitySpec14
        def occurrence_spec
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module CardinalitySpec15
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Cardinality.new(
            :interval => occurrence_spec.value)
        end
      end

      def _nt_cardinality_spec
        start_index = index
        if node_cache[:cardinality_spec].has_key?(index)
          cached = node_cache[:cardinality_spec][index]
          if cached
            node_cache[:cardinality_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_occurrence_spec
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_SYM_ORDERED
              s1 << r5
              if r5
                if (match_len = has_terminal?(';', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure(';')
                  r6 = nil
                end
                s1 << r6
                if r6
                  r7 = _nt_white_space
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_UNIQUE
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CardinalitySpec0)
          r1.extend(CardinalitySpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_occurrence_spec
          s9 << r10
          if r10
            if (match_len = has_terminal?(';', false, index))
              r11 = true
              @index += match_len
            else
              terminal_parse_failure(';')
              r11 = nil
            end
            s9 << r11
            if r11
              r12 = _nt_white_space
              s9 << r12
              if r12
                r13 = _nt_SYM_ORDERED
                s9 << r13
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(CardinalitySpec2)
            r9.extend(CardinalitySpec3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i14, s14 = index, []
            r15 = _nt_occurrence_spec
            s14 << r15
            if r15
              if (match_len = has_terminal?(';', false, index))
                r16 = true
                @index += match_len
              else
                terminal_parse_failure(';')
                r16 = nil
              end
              s14 << r16
              if r16
                r17 = _nt_white_space
                s14 << r17
                if r17
                  r18 = _nt_SYM_UNORDERD
                  s14 << r18
                  if r18
                    if (match_len = has_terminal?(';', false, index))
                      r19 = true
                      @index += match_len
                    else
                      terminal_parse_failure(';')
                      r19 = nil
                    end
                    s14 << r19
                    if r19
                      r20 = _nt_white_space
                      s14 << r20
                      if r20
                        r21 = _nt_SYM_UNIQUE
                        s14 << r21
                      end
                    end
                  end
                end
              end
            end
            if s14.last
              r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
              r14.extend(CardinalitySpec4)
              r14.extend(CardinalitySpec5)
            else
              @index = i14
              r14 = nil
            end
            if r14
              r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
              r0 = r14
            else
              i22, s22 = index, []
              r23 = _nt_occurrence_spec
              s22 << r23
              if r23
                if (match_len = has_terminal?(';', false, index))
                  r24 = true
                  @index += match_len
                else
                  terminal_parse_failure(';')
                  r24 = nil
                end
                s22 << r24
                if r24
                  r25 = _nt_white_space
                  s22 << r25
                  if r25
                    r26 = _nt_SYM_UNORDERD
                    s22 << r26
                  end
                end
              end
              if s22.last
                r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                r22.extend(CardinalitySpec6)
                r22.extend(CardinalitySpec7)
              else
                @index = i22
                r22 = nil
              end
              if r22
                r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                r0 = r22
              else
                i27, s27 = index, []
                r28 = _nt_occurrence_spec
                s27 << r28
                if r28
                  r29 = _nt_SYM_UNIQUE
                  s27 << r29
                  if r29
                    if (match_len = has_terminal?(';', false, index))
                      r30 = true
                      @index += match_len
                    else
                      terminal_parse_failure(';')
                      r30 = nil
                    end
                    s27 << r30
                    if r30
                      r31 = _nt_white_space
                      s27 << r31
                      if r31
                        r32 = _nt_SYM_ORDERED
                        s27 << r32
                      end
                    end
                  end
                end
                if s27.last
                  r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                  r27.extend(CardinalitySpec8)
                  r27.extend(CardinalitySpec9)
                else
                  @index = i27
                  r27 = nil
                end
                if r27
                  r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                  r0 = r27
                else
                  i33, s33 = index, []
                  r34 = _nt_occurrence_spec
                  s33 << r34
                  if r34
                    r35 = _nt_SYM_UNIQUE
                    s33 << r35
                    if r35
                      if (match_len = has_terminal?(';', false, index))
                        r36 = true
                        @index += match_len
                      else
                        terminal_parse_failure(';')
                        r36 = nil
                      end
                      s33 << r36
                      if r36
                        r37 = _nt_white_space
                        s33 << r37
                        if r37
                          r38 = _nt_SYM_UNORDERD
                          s33 << r38
                        end
                      end
                    end
                  end
                  if s33.last
                    r33 = instantiate_node(SyntaxNode,input, i33...index, s33)
                    r33.extend(CardinalitySpec10)
                    r33.extend(CardinalitySpec11)
                  else
                    @index = i33
                    r33 = nil
                  end
                  if r33
                    r33 = SyntaxNode.new(input, (index-1)...index) if r33 == true
                    r0 = r33
                  else
                    i39, s39 = index, []
                    r40 = _nt_occurrence_spec
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_UNIQUE
                      s39 << r41
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(CardinalitySpec12)
                      r39.extend(CardinalitySpec13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i42, s42 = index, []
                      r43 = _nt_occurrence_spec
                      s42 << r43
                      if r43
                        r44 = _nt_space
                        s42 << r44
                      end
                      if s42.last
                        r42 = instantiate_node(SyntaxNode,input, i42...index, s42)
                        r42.extend(CardinalitySpec14)
                        r42.extend(CardinalitySpec15)
                      else
                        @index = i42
                        r42 = nil
                      end
                      if r42
                        r42 = SyntaxNode.new(input, (index-1)...index) if r42 == true
                        r0 = r42
                      else
                        @index = i0
                        r0 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:cardinality_spec][start_index] = r0

        r0
      end

      module COccurrences0
        def SYM_OCCURRENCES
          elements[0]
        end

        def SYM_MATCHES
          elements[1]
        end

        def SYM_START_CBLOCK
          elements[2]
        end

        def occurrence_spec
          elements[3]
        end

        def SYM_END_CBLOCK
          elements[4]
        end

        def space
          elements[5]
        end
      end

      module COccurrences1
        def value
          occurrence_spec.value
        end
      end

      def _nt_c_occurrences
        start_index = index
        if node_cache[:c_occurrences].has_key?(index)
          cached = node_cache[:c_occurrences][index]
          if cached
            node_cache[:c_occurrences][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_OCCURRENCES
        s0 << r1
        if r1
          r2 = _nt_SYM_MATCHES
          s0 << r2
          if r2
            r3 = _nt_SYM_START_CBLOCK
            s0 << r3
            if r3
              r4 = _nt_occurrence_spec
              s0 << r4
              if r4
                r5 = _nt_SYM_END_CBLOCK
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(COccurrences0)
          r0.extend(COccurrences1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_occurrences][start_index] = r0

        r0
      end

      module OccurrenceSpec0
        def st
          elements[0]
        end

        def SYM_ELLIPSIS
          elements[1]
        end

        def ed
          elements[2]
        end
      end

      module OccurrenceSpec1
        def value
          if ed.value == '*'
            OpenEHR::AssumedLibraryTypes::Interval.new(
               :lower => st.value,
               :lower_included => true)
          else
            OpenEHR::AssumedLibraryTypes::Interval.new(
              :lower => st.value,
              :upper => ed.value,
              :lower_included => true, 
              :upper_included => true)
          end
        end
      end

      module OccurrenceSpec2
        def cardinality_limit_value
          elements[0]
        end

      end

      module OccurrenceSpec3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
            :lower => cardinality_limit_value.value,
            :upper => cardinality_limit_value.value,
            :lower_included => true,
            :upper_included => true)
        end
      end

      def _nt_occurrence_spec
        start_index = index
        if node_cache[:occurrence_spec].has_key?(index)
          cached = node_cache[:occurrence_spec][index]
          if cached
            node_cache[:occurrence_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_value
        s1 << r2
        if r2
          r3 = _nt_SYM_ELLIPSIS
          s1 << r3
          if r3
            r4 = _nt_cardinality_limit_value
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(OccurrenceSpec0)
          r1.extend(OccurrenceSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_cardinality_limit_value
          s5 << r6
          if r6
            if (match_len = has_terminal?('', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r7 = nil
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(OccurrenceSpec2)
            r5.extend(OccurrenceSpec3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:occurrence_spec][start_index] = r0

        r0
      end

      module CardinalityLimitValue0
        def integer_value
          elements[0]
        end

      end

      module CardinalityLimitValue1
        def value
          text_value.to_i
        end
      end

      module CardinalityLimitValue2
        def value
          '*'
        end
      end

      def _nt_cardinality_limit_value
        start_index = index
        if node_cache[:cardinality_limit_value].has_key?(index)
          cached = node_cache[:cardinality_limit_value][index]
          if cached
            node_cache[:cardinality_limit_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CardinalityLimitValue0)
          r1.extend(CardinalityLimitValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('*', false, index))
            r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            r4.extend(CardinalityLimitValue2)
            @index += match_len
          else
            terminal_parse_failure('*')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:cardinality_limit_value][start_index] = r0

        r0
      end

      module CInteger0
        def c_integer_spec
          elements[0]
        end

        def white_space
          elements[2]
        end

        def integer_value
          elements[3]
        end
      end

      module CInteger1
        def value
          args = c_integer_spec.value
          args[:assumed_value] = integer_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CInteger.new(args)
        end
      end

      module CInteger2
        def c_integer_spec
          elements[0]
        end

      end

      module CInteger3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CInteger.new(
            c_integer_spec.value)
        end
      end

      def _nt_c_integer
        start_index = index
        if node_cache[:c_integer].has_key?(index)
          cached = node_cache[:c_integer][index]
          if cached
            node_cache[:c_integer][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_integer_spec
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_integer_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CInteger0)
          r1.extend(CInteger1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_integer_spec
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CInteger2)
            r6.extend(CInteger3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_integer][start_index] = r0

        r0
      end

      module CIntegerSpec0
        def integer_list_value
          elements[0]
        end

      end

      module CIntegerSpec1
        def value
          {:list => integer_list_value.value}
        end
      end

      module CIntegerSpec2
        def integer_interval_value
          elements[0]
        end

      end

      module CIntegerSpec3
        def value
          {:range => integer_interval_value.value}
        end
      end

      module CIntegerSpec4
        def integer_value
          elements[0]
        end

      end

      module CIntegerSpec5
        def value
          {:list => [integer_value.value]}
        end
      end

      module CIntegerSpec6
        def occurrence_spec
          elements[0]
        end

      end

      module CIntegerSpec7
        def value
          {:range => occurrence_spec.value}
        end
      end

      def _nt_c_integer_spec
        start_index = index
        if node_cache[:c_integer_spec].has_key?(index)
          cached = node_cache[:c_integer_spec][index]
          if cached
            node_cache[:c_integer_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_list_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CIntegerSpec0)
          r1.extend(CIntegerSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_integer_interval_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CIntegerSpec2)
            r4.extend(CIntegerSpec3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_integer_value
            s7 << r8
            if r8
              i9 = index
              if (match_len = has_terminal?('..', false, index))
                r10 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('..')
                r10 = nil
              end
              if r10
                r9 = nil
              else
                @index = i9
                r9 = instantiate_node(SyntaxNode,input, index...index)
              end
              s7 << r9
              if r9
                if (match_len = has_terminal?('', false, index))
                  r11 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r11 = nil
                end
                s7 << r11
              end
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CIntegerSpec4)
              r7.extend(CIntegerSpec5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i12, s12 = index, []
              r13 = _nt_occurrence_spec
              s12 << r13
              if r13
                if (match_len = has_terminal?('', false, index))
                  r14 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r14 = nil
                end
                s12 << r14
              end
              if s12.last
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                r12.extend(CIntegerSpec6)
                r12.extend(CIntegerSpec7)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                r0 = r12
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_integer_spec][start_index] = r0

        r0
      end

      module CRealSpec0
        def real_list_value
          elements[0]
        end

      end

      module CRealSpec1
        def value
          {:list => real_list_value.value}
        end
      end

      module CRealSpec2
        def real_interval_value
          elements[0]
        end

      end

      module CRealSpec3
        def value
          {:range => real_interval_value.value}
        end
      end

      module CRealSpec4
        def real_value
          elements[0]
        end

      end

      module CRealSpec5
        def value
          {:list => [real_value.value]}
        end
      end

      def _nt_c_real_spec
        start_index = index
        if node_cache[:c_real_spec].has_key?(index)
          cached = node_cache[:c_real_spec][index]
          if cached
            node_cache[:c_real_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_real_list_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CRealSpec0)
          r1.extend(CRealSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_real_interval_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CRealSpec2)
            r4.extend(CRealSpec3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_real_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CRealSpec4)
              r7.extend(CRealSpec5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:c_real_spec][start_index] = r0

        r0
      end

      module CReal0
        def c_real_spec
          elements[0]
        end

        def white_space
          elements[2]
        end

        def real_value
          elements[3]
        end
      end

      module CReal1
        def value
          args = c_real_spec.value
          args[:assumed_value] = real_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CReal.new(args)
        end
      end

      module CReal2
        def c_real_spec
          elements[0]
        end

      end

      module CReal3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CReal.new(
            c_real_spec.value)
        end
      end

      def _nt_c_real
        start_index = index
        if node_cache[:c_real].has_key?(index)
          cached = node_cache[:c_real][index]
          if cached
            node_cache[:c_real][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_real_spec
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_real_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CReal0)
          r1.extend(CReal1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_real_spec
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CReal2)
            r6.extend(CReal3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_real][start_index] = r0

        r0
      end

      module CDateConstraint0
        def date_interval_value
          elements[0]
        end

      end

      module CDateConstraint1
        def value
          {:range => date_interval_value.value}
        end
      end

      module CDateConstraint2
        def date_list_value
          elements[0]
        end

      end

      module CDateConstraint3
        def value
          {:list => date_list_value.value}
        end
      end

      module CDateConstraint4
        def date_value
          elements[0]
        end

      end

      module CDateConstraint5
        def value
          {:list => [date_value.value]}
        end
      end

      module CDateConstraint6
        def con
          elements[0]
        end

      end

      module CDateConstraint7
        def value
          {:pattern => con.text_value}
        end
      end

      def _nt_c_date_constraint
        start_index = index
        if node_cache[:c_date_constraint].has_key?(index)
          cached = node_cache[:c_date_constraint][index]
          if cached
            node_cache[:c_date_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_date_interval_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDateConstraint0)
          r1.extend(CDateConstraint1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_date_list_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CDateConstraint2)
            r4.extend(CDateConstraint3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_date_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CDateConstraint4)
              r7.extend(CDateConstraint5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_V_ISO8601_DATE_CONSTRAINT_PATTERN
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(CDateConstraint6)
                r10.extend(CDateConstraint7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_date_constraint][start_index] = r0

        r0
      end

      module CDate0
        def c_date_constraint
          elements[0]
        end

        def white_space
          elements[2]
        end

        def date_value
          elements[3]
        end
      end

      module CDate1
        def value
          args = c_date_constraint.value
          args[:assumed_value] = date_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDate.new(
            args)
        end
      end

      module CDate2
        def c_date_constraint
          elements[0]
        end

      end

      module CDate3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDate.new(
            c_date_constraint.value)
        end
      end

      def _nt_c_date
        start_index = index
        if node_cache[:c_date].has_key?(index)
          cached = node_cache[:c_date][index]
          if cached
            node_cache[:c_date][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_date_constraint
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_date_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDate0)
          r1.extend(CDate1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_date_constraint
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CDate2)
            r6.extend(CDate3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_date][start_index] = r0

        r0
      end

      module CTimeConstraint0
        def time_interval_value
          elements[0]
        end

      end

      module CTimeConstraint1
        def value
          {:range => time_interval_value.value}
        end
      end

      module CTimeConstraint2
        def time_list_value
          elements[0]
        end

      end

      module CTimeConstraint3
        def value
          {:list => time_list_value.value}
        end
      end

      module CTimeConstraint4
        def time_value
          elements[0]
        end

      end

      module CTimeConstraint5
        def value
          {:list => [time_value.value]}
        end
      end

      module CTimeConstraint6
        def tc
          elements[0]
        end

      end

      module CTimeConstraint7
        def value
          {:pattern => tc.text_value}
        end
      end

      def _nt_c_time_constraint
        start_index = index
        if node_cache[:c_time_constraint].has_key?(index)
          cached = node_cache[:c_time_constraint][index]
          if cached
            node_cache[:c_time_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_time_interval_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CTimeConstraint0)
          r1.extend(CTimeConstraint1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_time_list_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CTimeConstraint2)
            r4.extend(CTimeConstraint3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_time_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CTimeConstraint4)
              r7.extend(CTimeConstraint5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_V_ISO8601_TIME_CONSTRAINT_PATTERN
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(CTimeConstraint6)
                r10.extend(CTimeConstraint7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_time_constraint][start_index] = r0

        r0
      end

      module CTime0
        def c_time_constraint
          elements[0]
        end

        def white_space
          elements[2]
        end

        def time_value
          elements[3]
        end
      end

      module CTime1
        def value
          args = c_time_constraint.value
          args[:assumed_value] = time_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CTime.new(
            args)
        end
      end

      module CTime2
        def c_time_constraint
          elements[0]
        end

      end

      module CTime3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CTime.new(
            c_time_constraint.value)
        end
      end

      def _nt_c_time
        start_index = index
        if node_cache[:c_time].has_key?(index)
          cached = node_cache[:c_time][index]
          if cached
            node_cache[:c_time][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_time_constraint
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_time_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CTime0)
          r1.extend(CTime1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_time_constraint
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CTime2)
            r6.extend(CTime3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_time][start_index] = r0

        r0
      end

      module CDateTimeConstraint0
        def date_time_interval_value
          elements[0]
        end

      end

      module CDateTimeConstraint1
        def value
          {:range => date_time_interval_value.value}
        end
      end

      module CDateTimeConstraint2
        def date_time_value
          elements[0]
        end

      end

      module CDateTimeConstraint3
        def value
          {:list => [date_time_value.value]}
        end
      end

      module CDateTimeConstraint4
        def dtc
          elements[0]
        end

      end

      module CDateTimeConstraint5
        def value
          {:pattern => dtc.text_value}
        end
      end

      def _nt_c_date_time_constraint
        start_index = index
        if node_cache[:c_date_time_constraint].has_key?(index)
          cached = node_cache[:c_date_time_constraint][index]
          if cached
            node_cache[:c_date_time_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_date_time_interval_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDateTimeConstraint0)
          r1.extend(CDateTimeConstraint1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_date_time_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CDateTimeConstraint2)
            r4.extend(CDateTimeConstraint3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(CDateTimeConstraint4)
              r7.extend(CDateTimeConstraint5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:c_date_time_constraint][start_index] = r0

        r0
      end

      module CDateTime0
        def c_date_time_constraint
          elements[0]
        end

        def white_space
          elements[2]
        end

        def date_time_value
          elements[3]
        end
      end

      module CDateTime1
        def value
          args = c_date_time_constraint.value
          args[:assumed_value] = date_time_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDateTime.new(
            args)
        end
      end

      module CDateTime2
        def c_date_time_constraint
          elements[0]
        end

      end

      module CDateTime3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDateTime.new(
            c_date_time_constraint.value)
        end
      end

      def _nt_c_date_time
        start_index = index
        if node_cache[:c_date_time].has_key?(index)
          cached = node_cache[:c_date_time][index]
          if cached
            node_cache[:c_date_time][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_date_time_constraint
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_date_time_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDateTime0)
          r1.extend(CDateTime1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_date_time_constraint
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CDateTime2)
            r6.extend(CDateTime3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_date_time][start_index] = r0

        r0
      end

      module CDurationConstraint0
        def duration_pattern
          elements[0]
        end

        def duration_interval_value
          elements[2]
        end

      end

      module CDurationConstraint1
        def value
          {:pattern => duration_pattern.value,
	     :range => duration_interval_value.value}
        end
      end

      module CDurationConstraint2
        def duration_pattern
          elements[0]
        end

      end

      module CDurationConstraint3
        def value
          {:pattern => duration_pattern.value}
        end
      end

      module CDurationConstraint4
        def duration_interval_value
          elements[0]
        end

      end

      module CDurationConstraint5
        def value
          {:range => duration_interval_value.value}
        end
      end

      module CDurationConstraint6
        def duration_value
          elements[0]
        end

      end

      module CDurationConstraint7
        def value
          {:list => [duration_value.value]}
        end
      end

      def _nt_c_duration_constraint
        start_index = index
        if node_cache[:c_duration_constraint].has_key?(index)
          cached = node_cache[:c_duration_constraint][index]
          if cached
            node_cache[:c_duration_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_duration_pattern
        s1 << r2
        if r2
          if (match_len = has_terminal?('/', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('/')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_duration_interval_value
            s1 << r4
            if r4
              if (match_len = has_terminal?('', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r5 = nil
              end
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDurationConstraint0)
          r1.extend(CDurationConstraint1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_duration_pattern
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CDurationConstraint2)
            r6.extend(CDurationConstraint3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            i9, s9 = index, []
            r10 = _nt_duration_interval_value
            s9 << r10
            if r10
              if (match_len = has_terminal?('', false, index))
                r11 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r11 = nil
              end
              s9 << r11
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(CDurationConstraint4)
              r9.extend(CDurationConstraint5)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              i12, s12 = index, []
              r13 = _nt_duration_value
              s12 << r13
              if r13
                if (match_len = has_terminal?('', false, index))
                  r14 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r14 = nil
                end
                s12 << r14
              end
              if s12.last
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                r12.extend(CDurationConstraint6)
                r12.extend(CDurationConstraint7)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                r0 = r12
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_duration_constraint][start_index] = r0

        r0
      end

      module DurationPattern0
        def dp
          elements[0]
        end

      end

      module DurationPattern1
        def value
          dp.text_value
        end
      end

      def _nt_duration_pattern
        start_index = index
        if node_cache[:duration_pattern].has_key?(index)
          cached = node_cache[:duration_pattern][index]
          if cached
            node_cache[:duration_pattern][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ISO8601_DURATION_CONSTRAINT_PATTERN
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DurationPattern0)
          r0.extend(DurationPattern1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:duration_pattern][start_index] = r0

        r0
      end

      module CDuration0
        def c_duration_constraint
          elements[0]
        end

        def white_space
          elements[2]
        end

        def duration_value
          elements[3]
        end

      end

      module CDuration1
        def value
          args = c_duration_constraint.value
          args[:assumed_value] = duration_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDuration.new(
            args)
        end
      end

      module CDuration2
        def c_duration_constraint
          elements[0]
        end

      end

      module CDuration3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CDuration.new(
            c_duration_constraint.value)
        end
      end

      def _nt_c_duration
        start_index = index
        if node_cache[:c_duration].has_key?(index)
          cached = node_cache[:c_duration][index]
          if cached
            node_cache[:c_duration][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_duration_constraint
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_duration_value
              s1 << r5
              if r5
                if (match_len = has_terminal?('', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r6 = nil
                end
                s1 << r6
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CDuration0)
          r1.extend(CDuration1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_c_duration_constraint
          s7 << r8
          if r8
            if (match_len = has_terminal?('', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r9 = nil
            end
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(CDuration2)
            r7.extend(CDuration3)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_duration][start_index] = r0

        r0
      end

      module CStringSpec0
        def string_list_value
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module CStringSpec1
        def value
          {:list => string_list_value.value}
        end
      end

      module CStringSpec2
        def string_list_value
          elements[0]
        end

      end

      module CStringSpec3
        def value
          {:list => string_list_value.value}
        end
      end

      module CStringSpec4
        def pat
          elements[0]
        end

      end

      module CStringSpec5
        def value
          {:pattern => pat.value}
        end
      end

      module CStringSpec6
        def str
          elements[0]
        end

      end

      module CStringSpec7
        def value
          {:list => [str.value]}
        end
      end

      def _nt_c_string_spec
        start_index = index
        if node_cache[:c_string_spec].has_key?(index)
          cached = node_cache[:c_string_spec][index]
          if cached
            node_cache[:c_string_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_string_list_value
        s1 << r2
        if r2
          if (match_len = has_terminal?(',', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(',')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_SYM_LIST_CONTINUE
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CStringSpec0)
          r1.extend(CStringSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_string_list_value
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CStringSpec2)
            r6.extend(CStringSpec3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            i9, s9 = index, []
            r10 = _nt_V_REGEXP
            s9 << r10
            if r10
              if (match_len = has_terminal?('', false, index))
                r11 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r11 = nil
              end
              s9 << r11
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(CStringSpec4)
              r9.extend(CStringSpec5)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              i12, s12 = index, []
              r13 = _nt_V_STRING
              s12 << r13
              if r13
                if (match_len = has_terminal?('', false, index))
                  r14 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r14 = nil
                end
                s12 << r14
              end
              if s12.last
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                r12.extend(CStringSpec6)
                r12.extend(CStringSpec7)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                r0 = r12
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_string_spec][start_index] = r0

        r0
      end

      module CString0
        def c_string_spec
          elements[0]
        end

        def white_space1
          elements[1]
        end

        def white_space2
          elements[3]
        end

        def string_value
          elements[4]
        end
      end

      module CString1
        def value
          args = c_string_spec.value
          args[:assumed_value] = string_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CString.new(
            args)
        end
      end

      module CString2
        def c_string_spec
          elements[0]
        end

      end

      module CString3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CString.new(
            c_string_spec.value)
        end
      end

      def _nt_c_string
        start_index = index
        if node_cache[:c_string].has_key?(index)
          cached = node_cache[:c_string][index]
          if cached
            node_cache[:c_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_string_spec
        s1 << r2
        if r2
          r3 = _nt_white_space
          s1 << r3
          if r3
            if (match_len = has_terminal?(';', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(';')
              r4 = nil
            end
            s1 << r4
            if r4
              r5 = _nt_white_space
              s1 << r5
              if r5
                r6 = _nt_string_value
                s1 << r6
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CString0)
          r1.extend(CString1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_c_string_spec
          s7 << r8
          if r8
            if (match_len = has_terminal?('', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r9 = nil
            end
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(CString2)
            r7.extend(CString3)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_string][start_index] = r0

        r0
      end

      module CBooleanSpec0
        def SYM_TRUE
          elements[0]
        end

        def white_space1
          elements[1]
        end

        def white_space2
          elements[3]
        end

        def SYM_FALSE
          elements[4]
        end
      end

      module CBooleanSpec1
        def value
          {:true_valid => true, :false_valid => true}
        end
      end

      module CBooleanSpec2
        def SYM_TRUE
          elements[0]
        end

        def white_space
          elements[1]
        end

      end

      module CBooleanSpec3
        def value
          {:true_valid => true, :false_valid => false}
        end
      end

      module CBooleanSpec4
        def SYM_FALSE
          elements[0]
        end

        def white_space1
          elements[1]
        end

        def white_space2
          elements[3]
        end

        def SYM_TRUE
          elements[4]
        end
      end

      module CBooleanSpec5
        def value
          {:true_valid => true, :false_valid => true}
        end
      end

      module CBooleanSpec6
        def SYM_FALSE
          elements[0]
        end

        def white_space
          elements[1]
        end

      end

      module CBooleanSpec7
        def value
          {:false_valid => true, :true_valid => false}
        end
      end

      def _nt_c_boolean_spec
        start_index = index
        if node_cache[:c_boolean_spec].has_key?(index)
          cached = node_cache[:c_boolean_spec][index]
          if cached
            node_cache[:c_boolean_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_TRUE
        s1 << r2
        if r2
          r3 = _nt_white_space
          s1 << r3
          if r3
            if (match_len = has_terminal?(',', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s1 << r4
            if r4
              r5 = _nt_white_space
              s1 << r5
              if r5
                r6 = _nt_SYM_FALSE
                s1 << r6
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CBooleanSpec0)
          r1.extend(CBooleanSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_SYM_TRUE
          s7 << r8
          if r8
            r9 = _nt_white_space
            s7 << r9
            if r9
              if (match_len = has_terminal?('', false, index))
                r10 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r10 = nil
              end
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(CBooleanSpec2)
            r7.extend(CBooleanSpec3)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            i11, s11 = index, []
            r12 = _nt_SYM_FALSE
            s11 << r12
            if r12
              r13 = _nt_white_space
              s11 << r13
              if r13
                if (match_len = has_terminal?(',', false, index))
                  r14 = true
                  @index += match_len
                else
                  terminal_parse_failure(',')
                  r14 = nil
                end
                s11 << r14
                if r14
                  r15 = _nt_white_space
                  s11 << r15
                  if r15
                    r16 = _nt_SYM_TRUE
                    s11 << r16
                  end
                end
              end
            end
            if s11.last
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              r11.extend(CBooleanSpec4)
              r11.extend(CBooleanSpec5)
            else
              @index = i11
              r11 = nil
            end
            if r11
              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
              r0 = r11
            else
              i17, s17 = index, []
              r18 = _nt_SYM_FALSE
              s17 << r18
              if r18
                r19 = _nt_white_space
                s17 << r19
                if r19
                  if (match_len = has_terminal?('', false, index))
                    r20 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r20 = nil
                  end
                  s17 << r20
                end
              end
              if s17.last
                r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                r17.extend(CBooleanSpec6)
                r17.extend(CBooleanSpec7)
              else
                @index = i17
                r17 = nil
              end
              if r17
                r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                r0 = r17
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:c_boolean_spec][start_index] = r0

        r0
      end

      module CBoolean0
        def c_boolean_spec
          elements[0]
        end

        def white_space
          elements[2]
        end

        def boolean_value
          elements[3]
        end
      end

      module CBoolean1
        def value
          args = c_boolean_spec.value
          args[:assumed_value] = boolean_value.value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CBoolean.new(
            args)
        end
      end

      module CBoolean2
        def c_boolean_spec
          elements[0]
        end

      end

      module CBoolean3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::Primitive::CBoolean.new(
            c_boolean_spec.value)
        end
      end

      def _nt_c_boolean
        start_index = index
        if node_cache[:c_boolean].has_key?(index)
          cached = node_cache[:c_boolean][index]
          if cached
            node_cache[:c_boolean][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_boolean_spec
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_white_space
            s1 << r4
            if r4
              r5 = _nt_boolean_value
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CBoolean0)
          r1.extend(CBoolean1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_c_boolean_spec
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(CBoolean2)
            r6.extend(CBoolean3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_boolean][start_index] = r0

        r0
      end

      module ConstraintRef0
        def vltcr
          elements[0]
        end

      end

      module ConstraintRef1
        def value(node)
          OpenEHR::AM::Archetype::ConstraintModel::ConstraintRef.new(
            :path => node.path,
            :rm_type_name => 'ConstraintRef',
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                              :upper => 1, 
                              :lower => 1, 
                              :lower_included => true, 
                              :upper_included => true),
            :reference => vltcr.value)
        end
      end

      def _nt_constraint_ref
        start_index = index
        if node_cache[:constraint_ref].has_key?(index)
          cached = node_cache[:constraint_ref][index]
          if cached
            node_cache[:constraint_ref][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_LOCAL_TERM_CODE_REF
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConstraintRef0)
          r0.extend(ConstraintRef1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:constraint_ref][start_index] = r0

        r0
      end

      module VREGEXP0
      end

      module VREGEXP1
      end

      module VREGEXP2
      end

      module VREGEXP3
      end

      module VREGEXP4
      end

      module VREGEXP5
      end

      module VREGEXP6
        def value
          text_value
        end
      end

      def _nt_V_REGEXP
        start_index = index
        if node_cache[:V_REGEXP].has_key?(index)
          cached = node_cache[:V_REGEXP][index]
          if cached
            node_cache[:V_REGEXP][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i2, s2 = index, []
        i3 = index
        if (match_len = has_terminal?('=', false, index))
          r4 = true
          @index += match_len
        else
          terminal_parse_failure('=')
          r4 = nil
        end
        if r4
          r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
          r3 = r4
        else
          if (match_len = has_terminal?('!', false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('!')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r3 = r5
          else
            @index = i3
            r3 = nil
          end
        end
        s2 << r3
        if r3
          if (match_len = has_terminal?('~', false, index))
            r6 = true
            @index += match_len
          else
            terminal_parse_failure('~')
            r6 = nil
          end
          s2 << r6
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(VREGEXP0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          i7 = index
          i8, s8 = index, []
          if (match_len = has_terminal?('/', false, index))
            r9 = true
            @index += match_len
          else
            terminal_parse_failure('/')
            r9 = nil
          end
          s8 << r9
          if r9
            s10, i10 = [], index
            loop do
              i11 = index
              if (match_len = has_terminal?('\/', false, index))
                r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\/')
                r12 = nil
              end
              if r12
                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                r11 = r12
              else
                i13, s13 = index, []
                i14 = index
                if (match_len = has_terminal?('/', false, index))
                  r15 = true
                  @index += match_len
                else
                  terminal_parse_failure('/')
                  r15 = nil
                end
                if r15
                  r14 = nil
                else
                  @index = i14
                  r14 = instantiate_node(SyntaxNode,input, index...index)
                end
                s13 << r14
                if r14
                  if index < input_length
                    r16 = true
                    @index += 1
                  else
                    terminal_parse_failure("any character")
                    r16 = nil
                  end
                  s13 << r16
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(VREGEXP1)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r11 = r13
                else
                  @index = i11
                  r11 = nil
                end
              end
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s8 << r10
            if r10
              if (match_len = has_terminal?('/', false, index))
                r17 = true
                @index += match_len
              else
                terminal_parse_failure('/')
                r17 = nil
              end
              s8 << r17
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(VREGEXP2)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r7 = r8
          else
            i18, s18 = index, []
            if (match_len = has_terminal?('^', false, index))
              r19 = true
              @index += match_len
            else
              terminal_parse_failure('^')
              r19 = nil
            end
            s18 << r19
            if r19
              s20, i20 = [], index
              loop do
                i21, s21 = index, []
                i22 = index
                if (match_len = has_terminal?('^', false, index))
                  r23 = true
                  @index += match_len
                else
                  terminal_parse_failure('^')
                  r23 = nil
                end
                if r23
                  r22 = nil
                else
                  @index = i22
                  r22 = instantiate_node(SyntaxNode,input, index...index)
                end
                s21 << r22
                if r22
                  if index < input_length
                    r24 = true
                    @index += 1
                  else
                    terminal_parse_failure("any character")
                    r24 = nil
                  end
                  s21 << r24
                end
                if s21.last
                  r21 = instantiate_node(SyntaxNode,input, i21...index, s21)
                  r21.extend(VREGEXP3)
                else
                  @index = i21
                  r21 = nil
                end
                if r21
                  s20 << r21
                else
                  break
                end
              end
              r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
              s18 << r20
              if r20
                if (match_len = has_terminal?('^', false, index))
                  r25 = true
                  @index += match_len
                else
                  terminal_parse_failure('^')
                  r25 = nil
                end
                s18 << r25
              end
            end
            if s18.last
              r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
              r18.extend(VREGEXP4)
            else
              @index = i18
              r18 = nil
            end
            if r18
              r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
              r7 = r18
            else
              @index = i7
              r7 = nil
            end
          end
          s0 << r7
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VREGEXP5)
          r0.extend(VREGEXP6)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_REGEXP][start_index] = r0

        r0
      end

      module CodeString0
      end

      module CodeString1
        def value
          text_value
        end
      end

      def _nt_code_string
        start_index = index
        if node_cache[:code_string].has_key?(index)
          cached = node_cache[:code_string][index]
          if cached
            node_cache[:code_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_NAMECHAR
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CodeString0)
          r0.extend(CodeString1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:code_string][start_index] = r0

        r0
      end

      module CodeStringList0
        def space
          elements[1]
        end

        def code_string
          elements[2]
        end
      end

      module CodeStringList1
        def first
          elements[0]
        end

        def more
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module CodeStringList2
        def value
          codes.map {|c| c.value}
        end

        def codes
          [first] + more.elements.map {|e| e.code_string}
        end
      end

      def _nt_code_string_list
        start_index = index
        if node_cache[:code_string_list].has_key?(index)
          cached = node_cache[:code_string_list][index]
          if cached
            node_cache[:code_string_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_code_string
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?(',', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_space
              s3 << r5
              if r5
                r6 = _nt_code_string
                s3 << r6
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(CodeStringList0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            r7 = _nt_space
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CodeStringList1)
          r0.extend(CodeStringList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:code_string_list][start_index] = r0

        r0
      end

      module CodeStringSpec0
        def code_string_list
          elements[0]
        end

      end

      module CodeStringSpec1
        def value
          code_string_list.value
        end
      end

      module CodeStringSpec2
        def code_string
          elements[0]
        end

      end

      module CodeStringSpec3
        def value
          [code_string.value]
        end
      end

      def _nt_code_string_spec
        start_index = index
        if node_cache[:code_string_spec].has_key?(index)
          cached = node_cache[:code_string_spec][index]
          if cached
            node_cache[:code_string_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_code_string_list
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CodeStringSpec0)
          r1.extend(CodeStringSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_code_string
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(CodeStringSpec2)
            r4.extend(CodeStringSpec3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:code_string_spec][start_index] = r0

        r0
      end

      module CCodePhrase0
        def ti
          elements[0]
        end

        def code_string_spec
          elements[1]
        end

        def space1
          elements[3]
        end

        def code_string
          elements[4]
        end

        def space2
          elements[6]
        end
      end

      module CCodePhrase1
        def value(node)
          ::OpenEHR::AM::OpenEHRProfile::DataTypes::Text::CCodePhrase.new(
            :rm_type_name => 'CodePhrase',
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                              :upper => 1, 
                              :lower => 1, 
                              :lower_included => true, 
                              :upper_included => true),
            :terminology_id => ti.value, :code_list => code_string_spec.value,
            :assumed_value => code_string.value,
            :path => node.path)
        end
      end

      module CCodePhrase2
        def ti
          elements[0]
        end

        def code_string_spec
          elements[1]
        end

        def space
          elements[3]
        end
      end

      module CCodePhrase3
        def value(node)
          ::OpenEHR::AM::OpenEHRProfile::DataTypes::Text::CCodePhrase.new(
            :rm_type_name => 'CodePhrase',
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                              :upper => 1, 
                              :lower => 1, 
                              :lower_included => true, 
                              :upper_included => true),
            :terminology_id => ti.value, :code_list => code_string_spec.value,
            :path => node.path)
        end
      end

      module CCodePhrase4
        def ti
          elements[0]
        end

        def space
          elements[2]
        end
      end

      module CCodePhrase5
        def value(node)
          ::OpenEHR::AM::OpenEHRProfile::DataTypes::Text::CCodePhrase.new(
            :rm_type_name => 'CodePhrase',
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                              :upper => 1, 
                              :lower => 1, 
                              :lower_included => true, 
                              :upper_included => true),
            :terminology_id => ti.value, :code_list => [], :path => node.path)
        end
      end

      def _nt_c_code_phrase
        start_index = index
        if node_cache[:c_code_phrase].has_key?(index)
          cached = node_cache[:c_code_phrase][index]
          if cached
            node_cache[:c_code_phrase][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_V_TERM_CODE
        s1 << r2
        if r2
          r3 = _nt_code_string_spec
          s1 << r3
          if r3
            if (match_len = has_terminal?(';', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(';')
              r4 = nil
            end
            s1 << r4
            if r4
              r5 = _nt_space
              s1 << r5
              if r5
                r6 = _nt_code_string
                s1 << r6
                if r6
                  if (match_len = has_terminal?(']', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure(']')
                    r7 = nil
                  end
                  s1 << r7
                  if r7
                    r8 = _nt_space
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CCodePhrase0)
          r1.extend(CCodePhrase1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_V_TERM_CODE
          s9 << r10
          if r10
            r11 = _nt_code_string_spec
            s9 << r11
            if r11
              if (match_len = has_terminal?(']', false, index))
                r12 = true
                @index += match_len
              else
                terminal_parse_failure(']')
                r12 = nil
              end
              s9 << r12
              if r12
                r13 = _nt_space
                s9 << r13
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(CCodePhrase2)
            r9.extend(CCodePhrase3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i14, s14 = index, []
            r15 = _nt_V_TERM_CODE
            s14 << r15
            if r15
              if (match_len = has_terminal?(']', false, index))
                r16 = true
                @index += match_len
              else
                terminal_parse_failure(']')
                r16 = nil
              end
              s14 << r16
              if r16
                r17 = _nt_space
                s14 << r17
              end
            end
            if s14.last
              r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
              r14.extend(CCodePhrase4)
              r14.extend(CCodePhrase5)
            else
              @index = i14
              r14 = nil
            end
            if r14
              r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
              r0 = r14
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:c_code_phrase][start_index] = r0

        r0
      end

      module SYMCDVORDINAL0
        def space
          elements[1]
        end
      end

      def _nt_SYM_C_DV_ORDINAL
        start_index = index
        if node_cache[:SYM_C_DV_ORDINAL].has_key?(index)
          cached = node_cache[:SYM_C_DV_ORDINAL][index]
          if cached
            node_cache[:SYM_C_DV_ORDINAL][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('C_DV_ORDINAL', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('C_DV_ORDINAL')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMCDVORDINAL0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_C_DV_ORDINAL][start_index] = r0

        r0
      end

      module COrdinal0
        def c_ordinal_spec
          elements[0]
        end

        def space1
          elements[2]
        end

        def integer_value
          elements[3]
        end

        def space2
          elements[4]
        end
      end

      module COrdinal1
        def value
          args = c_ordinal_spec.value
          args[:assumed_value] = integer_value.value
          args
        end
      end

      module COrdinal2
        def c_ordinal_spec
          elements[0]
        end

        def space
          elements[1]
        end

      end

      module COrdinal3
        def value
          c_ordinal_spec.value
        end
      end

      module COrdinal4
        def SYM_C_DV_ORDINAL
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def white_space
          elements[2]
        end

        def SYM_GT
          elements[3]
        end

        def space
          elements[4]
        end
      end

      module COrdinal5
        def value
          {:list => nil}
        end
      end

      def _nt_c_ordinal
        start_index = index
        if node_cache[:c_ordinal].has_key?(index)
          cached = node_cache[:c_ordinal][index]
          if cached
            node_cache[:c_ordinal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_c_ordinal_spec
        s1 << r2
        if r2
          if (match_len = has_terminal?(';', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure(';')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_space
            s1 << r4
            if r4
              r5 = _nt_integer_value
              s1 << r5
              if r5
                r6 = _nt_space
                s1 << r6
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(COrdinal0)
          r1.extend(COrdinal1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_c_ordinal_spec
          s7 << r8
          if r8
            r9 = _nt_space
            s7 << r9
            if r9
              if (match_len = has_terminal?('', false, index))
                r10 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r10 = nil
              end
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(COrdinal2)
            r7.extend(COrdinal3)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            i11, s11 = index, []
            r12 = _nt_SYM_C_DV_ORDINAL
            s11 << r12
            if r12
              r13 = _nt_SYM_LT
              s11 << r13
              if r13
                r14 = _nt_white_space
                s11 << r14
                if r14
                  r15 = _nt_SYM_GT
                  s11 << r15
                  if r15
                    r16 = _nt_space
                    s11 << r16
                  end
                end
              end
            end
            if s11.last
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              r11.extend(COrdinal4)
              r11.extend(COrdinal5)
            else
              @index = i11
              r11 = nil
            end
            if r11
              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
              r0 = r11
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:c_ordinal][start_index] = r0

        r0
      end

      module COrdinalSpec0
        def ordinal_list
          elements[0]
        end

      end

      module COrdinalSpec1
        def value
          {:list => ordinal_list.value}
        end
      end

      module COrdinalSpec2
        def ordinal
          elements[0]
        end

      end

      module COrdinalSpec3
        def value
          {:list => [ordinal.value]}
        end
      end

      def _nt_c_ordinal_spec
        start_index = index
        if node_cache[:c_ordinal_spec].has_key?(index)
          cached = node_cache[:c_ordinal_spec][index]
          if cached
            node_cache[:c_ordinal_spec][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_ordinal_list
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(COrdinalSpec0)
          r1.extend(COrdinalSpec1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_ordinal
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(COrdinalSpec2)
            r4.extend(COrdinalSpec3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:c_ordinal_spec][start_index] = r0

        r0
      end

      module OrdinalList0
        def space
          elements[1]
        end

        def ordinal
          elements[2]
        end
      end

      module OrdinalList1
        def first
          elements[0]
        end

        def more
          elements[1]
        end
      end

      module OrdinalList2
        def value
          ordinals.map {|o| o.value}
        end

        def ordinals
          [first] + more.elements.map {|e| e.ordinal}
        end
      end

      def _nt_ordinal_list
        start_index = index
        if node_cache[:ordinal_list].has_key?(index)
          cached = node_cache[:ordinal_list][index]
          if cached
            node_cache[:ordinal_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_ordinal
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?(',', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_space
              s3 << r5
              if r5
                r6 = _nt_ordinal
                s3 << r6
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(OrdinalList0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OrdinalList1)
          r0.extend(OrdinalList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ordinal_list][start_index] = r0

        r0
      end

      module Ordinal0
        def integer_value
          elements[0]
        end

        def SYM_INTERVAL_DELIM
          elements[1]
        end

        def vqtc
          elements[2]
        end

      end

      module Ordinal1
        def value
          symbol = ::OpenEHR::RM::DataTypes::Text::DvCodedText.new(
            :value => vqtc.text_value, :defining_code => vqtc.value)
          ::OpenEHR::RM::DataTypes::Quantity::DvOrdinal.new(
              :value => integer_value.value,
              :symbol => symbol)
        end
      end

      def _nt_ordinal
        start_index = index
        if node_cache[:ordinal].has_key?(index)
          cached = node_cache[:ordinal][index]
          if cached
            node_cache[:ordinal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_integer_value
        s0 << r1
        if r1
          r2 = _nt_SYM_INTERVAL_DELIM
          s0 << r2
          if r2
            r3 = _nt_V_QUALIFIED_TERM_CODE_REF
            s0 << r3
            if r3
              i4 = index
              r5 = _nt_SYM_INTERVAL_DELIM
              if r5
                r4 = nil
              else
                @index = i4
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
              if r4
                if (match_len = has_terminal?('', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r6 = nil
                end
                s0 << r6
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ordinal0)
          r0.extend(Ordinal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ordinal][start_index] = r0

        r0
      end

      module CDvQuantity0
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def prop
          elements[2]
        end

        def ql
          elements[3]
        end

        def aqv
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      module CDvQuantity1
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def prop
          elements[2]
        end

        def aqv
          elements[3]
        end

        def ql
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      module CDvQuantity2
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def aqv
          elements[2]
        end

        def prop
          elements[3]
        end

        def ql
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      module CDvQuantity3
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def aqv
          elements[2]
        end

        def ql
          elements[3]
        end

        def prop
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      module CDvQuantity4
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def ql
          elements[2]
        end

        def aqv
          elements[3]
        end

        def prop
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      module CDvQuantity5
        def SYM_C_DV_QUANTITY
          elements[0]
        end

        def SYM_START_DBLOCK
          elements[1]
        end

        def ql
          elements[2]
        end

        def prop
          elements[3]
        end

        def aqv
          elements[4]
        end

        def SYM_END_DBLOCK
          elements[5]
        end
      end

      def _nt_c_dv_quantity
        start_index = index
        if node_cache[:c_dv_quantity].has_key?(index)
          cached = node_cache[:c_dv_quantity][index]
          if cached
            node_cache[:c_dv_quantity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_C_DV_QUANTITY
        s1 << r2
        if r2
          r3 = _nt_SYM_START_DBLOCK
          s1 << r3
          if r3
            r5 = _nt_property
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r4
            if r4
              r7 = _nt_quantity_list
              if r7
                r6 = r7
              else
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r6
              if r6
                r9 = _nt_assumed_quantity_value
                if r9
                  r8 = r9
                else
                  r8 = instantiate_node(SyntaxNode,input, index...index)
                end
                s1 << r8
                if r8
                  r10 = _nt_SYM_END_DBLOCK
                  s1 << r10
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(CDvQuantityItems,input, i1...index, s1)
          r1.extend(CDvQuantity0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i11, s11 = index, []
          r12 = _nt_SYM_C_DV_QUANTITY
          s11 << r12
          if r12
            r13 = _nt_SYM_START_DBLOCK
            s11 << r13
            if r13
              r15 = _nt_property
              if r15
                r14 = r15
              else
                r14 = instantiate_node(SyntaxNode,input, index...index)
              end
              s11 << r14
              if r14
                r17 = _nt_assumed_quantity_value
                if r17
                  r16 = r17
                else
                  r16 = instantiate_node(SyntaxNode,input, index...index)
                end
                s11 << r16
                if r16
                  r19 = _nt_quantity_list
                  if r19
                    r18 = r19
                  else
                    r18 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s11 << r18
                  if r18
                    r20 = _nt_SYM_END_DBLOCK
                    s11 << r20
                  end
                end
              end
            end
          end
          if s11.last
            r11 = instantiate_node(CDvQuantityItems,input, i11...index, s11)
            r11.extend(CDvQuantity1)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
            r0 = r11
          else
            i21, s21 = index, []
            r22 = _nt_SYM_C_DV_QUANTITY
            s21 << r22
            if r22
              r23 = _nt_SYM_START_DBLOCK
              s21 << r23
              if r23
                r25 = _nt_assumed_quantity_value
                if r25
                  r24 = r25
                else
                  r24 = instantiate_node(SyntaxNode,input, index...index)
                end
                s21 << r24
                if r24
                  r27 = _nt_property
                  if r27
                    r26 = r27
                  else
                    r26 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s21 << r26
                  if r26
                    r29 = _nt_quantity_list
                    if r29
                      r28 = r29
                    else
                      r28 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s21 << r28
                    if r28
                      r30 = _nt_SYM_END_DBLOCK
                      s21 << r30
                    end
                  end
                end
              end
            end
            if s21.last
              r21 = instantiate_node(CDvQuantityItems,input, i21...index, s21)
              r21.extend(CDvQuantity2)
            else
              @index = i21
              r21 = nil
            end
            if r21
              r21 = SyntaxNode.new(input, (index-1)...index) if r21 == true
              r0 = r21
            else
              i31, s31 = index, []
              r32 = _nt_SYM_C_DV_QUANTITY
              s31 << r32
              if r32
                r33 = _nt_SYM_START_DBLOCK
                s31 << r33
                if r33
                  r35 = _nt_assumed_quantity_value
                  if r35
                    r34 = r35
                  else
                    r34 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s31 << r34
                  if r34
                    r37 = _nt_quantity_list
                    if r37
                      r36 = r37
                    else
                      r36 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s31 << r36
                    if r36
                      r39 = _nt_property
                      if r39
                        r38 = r39
                      else
                        r38 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s31 << r38
                      if r38
                        r40 = _nt_SYM_END_DBLOCK
                        s31 << r40
                      end
                    end
                  end
                end
              end
              if s31.last
                r31 = instantiate_node(CDvQuantityItems,input, i31...index, s31)
                r31.extend(CDvQuantity3)
              else
                @index = i31
                r31 = nil
              end
              if r31
                r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
                r0 = r31
              else
                i41, s41 = index, []
                r42 = _nt_SYM_C_DV_QUANTITY
                s41 << r42
                if r42
                  r43 = _nt_SYM_START_DBLOCK
                  s41 << r43
                  if r43
                    r45 = _nt_quantity_list
                    if r45
                      r44 = r45
                    else
                      r44 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s41 << r44
                    if r44
                      r47 = _nt_assumed_quantity_value
                      if r47
                        r46 = r47
                      else
                        r46 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s41 << r46
                      if r46
                        r49 = _nt_property
                        if r49
                          r48 = r49
                        else
                          r48 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s41 << r48
                        if r48
                          r50 = _nt_SYM_END_DBLOCK
                          s41 << r50
                        end
                      end
                    end
                  end
                end
                if s41.last
                  r41 = instantiate_node(CDvQuantityItems,input, i41...index, s41)
                  r41.extend(CDvQuantity4)
                else
                  @index = i41
                  r41 = nil
                end
                if r41
                  r41 = SyntaxNode.new(input, (index-1)...index) if r41 == true
                  r0 = r41
                else
                  i51, s51 = index, []
                  r52 = _nt_SYM_C_DV_QUANTITY
                  s51 << r52
                  if r52
                    r53 = _nt_SYM_START_DBLOCK
                    s51 << r53
                    if r53
                      r55 = _nt_quantity_list
                      if r55
                        r54 = r55
                      else
                        r54 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s51 << r54
                      if r54
                        r57 = _nt_property
                        if r57
                          r56 = r57
                        else
                          r56 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s51 << r56
                        if r56
                          r59 = _nt_assumed_quantity_value
                          if r59
                            r58 = r59
                          else
                            r58 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s51 << r58
                          if r58
                            r60 = _nt_SYM_END_DBLOCK
                            s51 << r60
                          end
                        end
                      end
                    end
                  end
                  if s51.last
                    r51 = instantiate_node(CDvQuantityItems,input, i51...index, s51)
                    r51.extend(CDvQuantity5)
                  else
                    @index = i51
                    r51 = nil
                  end
                  if r51
                    r51 = SyntaxNode.new(input, (index-1)...index) if r51 == true
                    r0 = r51
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end

        node_cache[:c_dv_quantity][start_index] = r0

        r0
      end

      module SYMCDVQUANTITY0
        def space
          elements[1]
        end
      end

      def _nt_SYM_C_DV_QUANTITY
        start_index = index
        if node_cache[:SYM_C_DV_QUANTITY].has_key?(index)
          cached = node_cache[:SYM_C_DV_QUANTITY][index]
          if cached
            node_cache[:SYM_C_DV_QUANTITY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('C_DV_QUANTITY', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('C_DV_QUANTITY')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMCDVQUANTITY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_C_DV_QUANTITY][start_index] = r0

        r0
      end

      module Property0
        def SYM_PROPERTY
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def prop
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module Property1
        def value
          prop.value
        end
      end

      def _nt_property
        start_index = index
        if node_cache[:property].has_key?(index)
          cached = node_cache[:property][index]
          if cached
            node_cache[:property][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_PROPERTY
        s0 << r1
        if r1
          r2 = _nt_SYM_EQ
          s0 << r2
          if r2
            r3 = _nt_SYM_START_DBLOCK
            s0 << r3
            if r3
              r4 = _nt_V_QUALIFIED_TERM_CODE_REF
              s0 << r4
              if r4
                r5 = _nt_SYM_END_DBLOCK
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Property0)
          r0.extend(Property1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:property][start_index] = r0

        r0
      end

      module SYMPROPERTY0
        def space
          elements[1]
        end
      end

      def _nt_SYM_PROPERTY
        start_index = index
        if node_cache[:SYM_PROPERTY].has_key?(index)
          cached = node_cache[:SYM_PROPERTY][index]
          if cached
            node_cache[:SYM_PROPERTY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('property', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('property')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMPROPERTY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_PROPERTY][start_index] = r0

        r0
      end

      module QuantityList0
        def SYM_QUANTITY_LIST
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def c_quantity_items
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module QuantityList1
        def value(node)
          c_quantity_items.value(node)
        end
      end

      def _nt_quantity_list
        start_index = index
        if node_cache[:quantity_list].has_key?(index)
          cached = node_cache[:quantity_list][index]
          if cached
            node_cache[:quantity_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_QUANTITY_LIST
        s0 << r1
        if r1
          r2 = _nt_SYM_EQ
          s0 << r2
          if r2
            r3 = _nt_SYM_START_DBLOCK
            s0 << r3
            if r3
              r4 = _nt_c_quantity_items
              s0 << r4
              if r4
                r5 = _nt_SYM_END_DBLOCK
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(QuantityList0)
          r0.extend(QuantityList1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:quantity_list][start_index] = r0

        r0
      end

      module AssumedQuantityValue0
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue1
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue2
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def SYM_UNITS
          elements[3]
        end

        def SYM_EQ2
          elements[4]
        end

        def SYM_START_DBLOCK2
          elements[5]
        end

        def units
          elements[6]
        end

        def SYM_END_DBLOCK1
          elements[7]
        end

        def mag
          elements[8]
        end

        def prec
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      module AssumedQuantityValue3
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue4
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue5
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def SYM_UNITS
          elements[3]
        end

        def SYM_EQ2
          elements[4]
        end

        def SYM_START_DBLOCK2
          elements[5]
        end

        def units
          elements[6]
        end

        def SYM_END_DBLOCK1
          elements[7]
        end

        def prec
          elements[8]
        end

        def mag
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      module AssumedQuantityValue6
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue7
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue8
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def prec
          elements[3]
        end

        def SYM_UNITS
          elements[4]
        end

        def SYM_EQ2
          elements[5]
        end

        def SYM_START_DBLOCK2
          elements[6]
        end

        def units
          elements[7]
        end

        def SYM_END_DBLOCK1
          elements[8]
        end

        def mag
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      module AssumedQuantityValue9
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue10
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue11
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def prec
          elements[3]
        end

        def mag
          elements[4]
        end

        def SYM_UNITS
          elements[5]
        end

        def SYM_EQ2
          elements[6]
        end

        def SYM_START_DBLOCK2
          elements[7]
        end

        def units
          elements[8]
        end

        def SYM_END_DBLOCK1
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      module AssumedQuantityValue12
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue13
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue14
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def mag
          elements[3]
        end

        def prec
          elements[4]
        end

        def SYM_UNITS
          elements[5]
        end

        def SYM_EQ2
          elements[6]
        end

        def SYM_START_DBLOCK2
          elements[7]
        end

        def units
          elements[8]
        end

        def SYM_END_DBLOCK1
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      module AssumedQuantityValue15
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue16
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def val
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module AssumedQuantityValue17
        def SYM_ASSUMED_VALUE
          elements[0]
        end

        def SYM_EQ1
          elements[1]
        end

        def SYM_START_DBLOCK1
          elements[2]
        end

        def mag
          elements[3]
        end

        def SYM_UNITS
          elements[4]
        end

        def SYM_EQ2
          elements[5]
        end

        def SYM_START_DBLOCK2
          elements[6]
        end

        def units
          elements[7]
        end

        def SYM_END_DBLOCK1
          elements[8]
        end

        def prec
          elements[9]
        end

        def SYM_END_DBLOCK2
          elements[10]
        end
      end

      def _nt_assumed_quantity_value
        start_index = index
        if node_cache[:assumed_quantity_value].has_key?(index)
          cached = node_cache[:assumed_quantity_value][index]
          if cached
            node_cache[:assumed_quantity_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_ASSUMED_VALUE
        s1 << r2
        if r2
          r3 = _nt_SYM_EQ
          s1 << r3
          if r3
            r4 = _nt_SYM_START_DBLOCK
            s1 << r4
            if r4
              r5 = _nt_SYM_UNITS
              s1 << r5
              if r5
                r6 = _nt_SYM_EQ
                s1 << r6
                if r6
                  r7 = _nt_SYM_START_DBLOCK
                  s1 << r7
                  if r7
                    r8 = _nt_V_STRING
                    s1 << r8
                    if r8
                      r9 = _nt_SYM_END_DBLOCK
                      s1 << r9
                      if r9
                        i11, s11 = index, []
                        r12 = _nt_SYM_MAGNITUDE
                        s11 << r12
                        if r12
                          r13 = _nt_SYM_EQ
                          s11 << r13
                          if r13
                            r14 = _nt_SYM_START_DBLOCK
                            s11 << r14
                            if r14
                              r15 = _nt_real_value
                              s11 << r15
                              if r15
                                r16 = _nt_SYM_END_DBLOCK
                                s11 << r16
                              end
                            end
                          end
                        end
                        if s11.last
                          r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                          r11.extend(AssumedQuantityValue0)
                        else
                          @index = i11
                          r11 = nil
                        end
                        if r11
                          r10 = r11
                        else
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s1 << r10
                        if r10
                          i18, s18 = index, []
                          r19 = _nt_SYM_PRECISION
                          s18 << r19
                          if r19
                            r20 = _nt_SYM_EQ
                            s18 << r20
                            if r20
                              r21 = _nt_SYM_START_DBLOCK
                              s18 << r21
                              if r21
                                r22 = _nt_integer_value
                                s18 << r22
                                if r22
                                  r23 = _nt_SYM_END_DBLOCK
                                  s18 << r23
                                end
                              end
                            end
                          end
                          if s18.last
                            r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                            r18.extend(AssumedQuantityValue1)
                          else
                            @index = i18
                            r18 = nil
                          end
                          if r18
                            r17 = r18
                          else
                            r17 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s1 << r17
                          if r17
                            r24 = _nt_SYM_END_DBLOCK
                            s1 << r24
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(AssumedValueItems,input, i1...index, s1)
          r1.extend(AssumedQuantityValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i25, s25 = index, []
          r26 = _nt_SYM_ASSUMED_VALUE
          s25 << r26
          if r26
            r27 = _nt_SYM_EQ
            s25 << r27
            if r27
              r28 = _nt_SYM_START_DBLOCK
              s25 << r28
              if r28
                r29 = _nt_SYM_UNITS
                s25 << r29
                if r29
                  r30 = _nt_SYM_EQ
                  s25 << r30
                  if r30
                    r31 = _nt_SYM_START_DBLOCK
                    s25 << r31
                    if r31
                      r32 = _nt_V_STRING
                      s25 << r32
                      if r32
                        r33 = _nt_SYM_END_DBLOCK
                        s25 << r33
                        if r33
                          i35, s35 = index, []
                          r36 = _nt_SYM_PRECISION
                          s35 << r36
                          if r36
                            r37 = _nt_SYM_EQ
                            s35 << r37
                            if r37
                              r38 = _nt_SYM_START_DBLOCK
                              s35 << r38
                              if r38
                                r39 = _nt_integer_value
                                s35 << r39
                                if r39
                                  r40 = _nt_SYM_END_DBLOCK
                                  s35 << r40
                                end
                              end
                            end
                          end
                          if s35.last
                            r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                            r35.extend(AssumedQuantityValue3)
                          else
                            @index = i35
                            r35 = nil
                          end
                          if r35
                            r34 = r35
                          else
                            r34 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s25 << r34
                          if r34
                            i42, s42 = index, []
                            r43 = _nt_SYM_MAGNITUDE
                            s42 << r43
                            if r43
                              r44 = _nt_SYM_EQ
                              s42 << r44
                              if r44
                                r45 = _nt_SYM_START_DBLOCK
                                s42 << r45
                                if r45
                                  r46 = _nt_real_value
                                  s42 << r46
                                  if r46
                                    r47 = _nt_SYM_END_DBLOCK
                                    s42 << r47
                                  end
                                end
                              end
                            end
                            if s42.last
                              r42 = instantiate_node(SyntaxNode,input, i42...index, s42)
                              r42.extend(AssumedQuantityValue4)
                            else
                              @index = i42
                              r42 = nil
                            end
                            if r42
                              r41 = r42
                            else
                              r41 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s25 << r41
                            if r41
                              r48 = _nt_SYM_END_DBLOCK
                              s25 << r48
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s25.last
            r25 = instantiate_node(AssumedValueItems,input, i25...index, s25)
            r25.extend(AssumedQuantityValue5)
          else
            @index = i25
            r25 = nil
          end
          if r25
            r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
            r0 = r25
          else
            i49, s49 = index, []
            r50 = _nt_SYM_ASSUMED_VALUE
            s49 << r50
            if r50
              r51 = _nt_SYM_EQ
              s49 << r51
              if r51
                r52 = _nt_SYM_START_DBLOCK
                s49 << r52
                if r52
                  i54, s54 = index, []
                  r55 = _nt_SYM_PRECISION
                  s54 << r55
                  if r55
                    r56 = _nt_SYM_EQ
                    s54 << r56
                    if r56
                      r57 = _nt_SYM_START_DBLOCK
                      s54 << r57
                      if r57
                        r58 = _nt_integer_value
                        s54 << r58
                        if r58
                          r59 = _nt_SYM_END_DBLOCK
                          s54 << r59
                        end
                      end
                    end
                  end
                  if s54.last
                    r54 = instantiate_node(SyntaxNode,input, i54...index, s54)
                    r54.extend(AssumedQuantityValue6)
                  else
                    @index = i54
                    r54 = nil
                  end
                  if r54
                    r53 = r54
                  else
                    r53 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s49 << r53
                  if r53
                    r60 = _nt_SYM_UNITS
                    s49 << r60
                    if r60
                      r61 = _nt_SYM_EQ
                      s49 << r61
                      if r61
                        r62 = _nt_SYM_START_DBLOCK
                        s49 << r62
                        if r62
                          r63 = _nt_V_STRING
                          s49 << r63
                          if r63
                            r64 = _nt_SYM_END_DBLOCK
                            s49 << r64
                            if r64
                              i66, s66 = index, []
                              r67 = _nt_SYM_MAGNITUDE
                              s66 << r67
                              if r67
                                r68 = _nt_SYM_EQ
                                s66 << r68
                                if r68
                                  r69 = _nt_SYM_START_DBLOCK
                                  s66 << r69
                                  if r69
                                    r70 = _nt_real_value
                                    s66 << r70
                                    if r70
                                      r71 = _nt_SYM_END_DBLOCK
                                      s66 << r71
                                    end
                                  end
                                end
                              end
                              if s66.last
                                r66 = instantiate_node(SyntaxNode,input, i66...index, s66)
                                r66.extend(AssumedQuantityValue7)
                              else
                                @index = i66
                                r66 = nil
                              end
                              if r66
                                r65 = r66
                              else
                                r65 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s49 << r65
                              if r65
                                r72 = _nt_SYM_END_DBLOCK
                                s49 << r72
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s49.last
              r49 = instantiate_node(AssumedValueItems,input, i49...index, s49)
              r49.extend(AssumedQuantityValue8)
            else
              @index = i49
              r49 = nil
            end
            if r49
              r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
              r0 = r49
            else
              i73, s73 = index, []
              r74 = _nt_SYM_ASSUMED_VALUE
              s73 << r74
              if r74
                r75 = _nt_SYM_EQ
                s73 << r75
                if r75
                  r76 = _nt_SYM_START_DBLOCK
                  s73 << r76
                  if r76
                    i78, s78 = index, []
                    r79 = _nt_SYM_PRECISION
                    s78 << r79
                    if r79
                      r80 = _nt_SYM_EQ
                      s78 << r80
                      if r80
                        r81 = _nt_SYM_START_DBLOCK
                        s78 << r81
                        if r81
                          r82 = _nt_integer_value
                          s78 << r82
                          if r82
                            r83 = _nt_SYM_END_DBLOCK
                            s78 << r83
                          end
                        end
                      end
                    end
                    if s78.last
                      r78 = instantiate_node(SyntaxNode,input, i78...index, s78)
                      r78.extend(AssumedQuantityValue9)
                    else
                      @index = i78
                      r78 = nil
                    end
                    if r78
                      r77 = r78
                    else
                      r77 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s73 << r77
                    if r77
                      i85, s85 = index, []
                      r86 = _nt_SYM_MAGNITUDE
                      s85 << r86
                      if r86
                        r87 = _nt_SYM_EQ
                        s85 << r87
                        if r87
                          r88 = _nt_SYM_START_DBLOCK
                          s85 << r88
                          if r88
                            r89 = _nt_real_value
                            s85 << r89
                            if r89
                              r90 = _nt_SYM_END_DBLOCK
                              s85 << r90
                            end
                          end
                        end
                      end
                      if s85.last
                        r85 = instantiate_node(SyntaxNode,input, i85...index, s85)
                        r85.extend(AssumedQuantityValue10)
                      else
                        @index = i85
                        r85 = nil
                      end
                      if r85
                        r84 = r85
                      else
                        r84 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s73 << r84
                      if r84
                        r91 = _nt_SYM_UNITS
                        s73 << r91
                        if r91
                          r92 = _nt_SYM_EQ
                          s73 << r92
                          if r92
                            r93 = _nt_SYM_START_DBLOCK
                            s73 << r93
                            if r93
                              r94 = _nt_V_STRING
                              s73 << r94
                              if r94
                                r95 = _nt_SYM_END_DBLOCK
                                s73 << r95
                                if r95
                                  r96 = _nt_SYM_END_DBLOCK
                                  s73 << r96
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
              if s73.last
                r73 = instantiate_node(AssumedValueItems,input, i73...index, s73)
                r73.extend(AssumedQuantityValue11)
              else
                @index = i73
                r73 = nil
              end
              if r73
                r73 = SyntaxNode.new(input, (index-1)...index) if r73 == true
                r0 = r73
              else
                i97, s97 = index, []
                r98 = _nt_SYM_ASSUMED_VALUE
                s97 << r98
                if r98
                  r99 = _nt_SYM_EQ
                  s97 << r99
                  if r99
                    r100 = _nt_SYM_START_DBLOCK
                    s97 << r100
                    if r100
                      i102, s102 = index, []
                      r103 = _nt_SYM_MAGNITUDE
                      s102 << r103
                      if r103
                        r104 = _nt_SYM_EQ
                        s102 << r104
                        if r104
                          r105 = _nt_SYM_START_DBLOCK
                          s102 << r105
                          if r105
                            r106 = _nt_real_value
                            s102 << r106
                            if r106
                              r107 = _nt_SYM_END_DBLOCK
                              s102 << r107
                            end
                          end
                        end
                      end
                      if s102.last
                        r102 = instantiate_node(SyntaxNode,input, i102...index, s102)
                        r102.extend(AssumedQuantityValue12)
                      else
                        @index = i102
                        r102 = nil
                      end
                      if r102
                        r101 = r102
                      else
                        r101 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s97 << r101
                      if r101
                        i109, s109 = index, []
                        r110 = _nt_SYM_PRECISION
                        s109 << r110
                        if r110
                          r111 = _nt_SYM_EQ
                          s109 << r111
                          if r111
                            r112 = _nt_SYM_START_DBLOCK
                            s109 << r112
                            if r112
                              r113 = _nt_integer_value
                              s109 << r113
                              if r113
                                r114 = _nt_SYM_END_DBLOCK
                                s109 << r114
                              end
                            end
                          end
                        end
                        if s109.last
                          r109 = instantiate_node(SyntaxNode,input, i109...index, s109)
                          r109.extend(AssumedQuantityValue13)
                        else
                          @index = i109
                          r109 = nil
                        end
                        if r109
                          r108 = r109
                        else
                          r108 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s97 << r108
                        if r108
                          r115 = _nt_SYM_UNITS
                          s97 << r115
                          if r115
                            r116 = _nt_SYM_EQ
                            s97 << r116
                            if r116
                              r117 = _nt_SYM_START_DBLOCK
                              s97 << r117
                              if r117
                                r118 = _nt_V_STRING
                                s97 << r118
                                if r118
                                  r119 = _nt_SYM_END_DBLOCK
                                  s97 << r119
                                  if r119
                                    r120 = _nt_SYM_END_DBLOCK
                                    s97 << r120
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
                if s97.last
                  r97 = instantiate_node(AssumedValueItems,input, i97...index, s97)
                  r97.extend(AssumedQuantityValue14)
                else
                  @index = i97
                  r97 = nil
                end
                if r97
                  r97 = SyntaxNode.new(input, (index-1)...index) if r97 == true
                  r0 = r97
                else
                  i121, s121 = index, []
                  r122 = _nt_SYM_ASSUMED_VALUE
                  s121 << r122
                  if r122
                    r123 = _nt_SYM_EQ
                    s121 << r123
                    if r123
                      r124 = _nt_SYM_START_DBLOCK
                      s121 << r124
                      if r124
                        i126, s126 = index, []
                        r127 = _nt_SYM_MAGNITUDE
                        s126 << r127
                        if r127
                          r128 = _nt_SYM_EQ
                          s126 << r128
                          if r128
                            r129 = _nt_SYM_START_DBLOCK
                            s126 << r129
                            if r129
                              r130 = _nt_real_value
                              s126 << r130
                              if r130
                                r131 = _nt_SYM_END_DBLOCK
                                s126 << r131
                              end
                            end
                          end
                        end
                        if s126.last
                          r126 = instantiate_node(SyntaxNode,input, i126...index, s126)
                          r126.extend(AssumedQuantityValue15)
                        else
                          @index = i126
                          r126 = nil
                        end
                        if r126
                          r125 = r126
                        else
                          r125 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s121 << r125
                        if r125
                          r132 = _nt_SYM_UNITS
                          s121 << r132
                          if r132
                            r133 = _nt_SYM_EQ
                            s121 << r133
                            if r133
                              r134 = _nt_SYM_START_DBLOCK
                              s121 << r134
                              if r134
                                r135 = _nt_V_STRING
                                s121 << r135
                                if r135
                                  r136 = _nt_SYM_END_DBLOCK
                                  s121 << r136
                                  if r136
                                    i138, s138 = index, []
                                    r139 = _nt_SYM_PRECISION
                                    s138 << r139
                                    if r139
                                      r140 = _nt_SYM_EQ
                                      s138 << r140
                                      if r140
                                        r141 = _nt_SYM_START_DBLOCK
                                        s138 << r141
                                        if r141
                                          r142 = _nt_integer_value
                                          s138 << r142
                                          if r142
                                            r143 = _nt_SYM_END_DBLOCK
                                            s138 << r143
                                          end
                                        end
                                      end
                                    end
                                    if s138.last
                                      r138 = instantiate_node(SyntaxNode,input, i138...index, s138)
                                      r138.extend(AssumedQuantityValue16)
                                    else
                                      @index = i138
                                      r138 = nil
                                    end
                                    if r138
                                      r137 = r138
                                    else
                                      r137 = instantiate_node(SyntaxNode,input, index...index)
                                    end
                                    s121 << r137
                                    if r137
                                      r144 = _nt_SYM_END_DBLOCK
                                      s121 << r144
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                  if s121.last
                    r121 = instantiate_node(AssumedValueItems,input, i121...index, s121)
                    r121.extend(AssumedQuantityValue17)
                  else
                    @index = i121
                    r121 = nil
                  end
                  if r121
                    r121 = SyntaxNode.new(input, (index-1)...index) if r121 == true
                    r0 = r121
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end

        node_cache[:assumed_quantity_value][start_index] = r0

        r0
      end

      module SYMQUANTITYLIST0
        def space
          elements[1]
        end
      end

      def _nt_SYM_QUANTITY_LIST
        start_index = index
        if node_cache[:SYM_QUANTITY_LIST].has_key?(index)
          cached = node_cache[:SYM_QUANTITY_LIST][index]
          if cached
            node_cache[:SYM_QUANTITY_LIST][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('list', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('list')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMQUANTITYLIST0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_QUANTITY_LIST][start_index] = r0

        r0
      end

      module CQuantityItems0
        def c_quantity_item
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module CQuantityItems1
        def c_quantity_item
          elements[0]
        end

        def more_cdv
          elements[1]
        end
      end

      module CQuantityItems2
        def value(node)
          quantities.map {|q| q.value(node)}
        end

        def quantities
          [c_quantity_item] + more_cdv.elements.map {|e| e.c_quantity_item}
        end
      end

      def _nt_c_quantity_items
        start_index = index
        if node_cache[:c_quantity_items].has_key?(index)
          cached = node_cache[:c_quantity_items][index]
          if cached
            node_cache[:c_quantity_items][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_c_quantity_item
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_c_quantity_item
            s3 << r4
            if r4
              r5 = _nt_white_space
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(CQuantityItems0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CQuantityItems1)
          r0.extend(CQuantityItems2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_quantity_items][start_index] = r0

        r0
      end

      module CQuantityItem0
        def SYM_MAGNITUDE
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def int
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module CQuantityItem1
        def SYM_PRECISION
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def SYM_START_DBLOCK
          elements[2]
        end

        def int
          elements[3]
        end

        def SYM_END_DBLOCK
          elements[4]
        end
      end

      module CQuantityItem2
        def V_STRING
          elements[1]
        end

        def white_space
          elements[3]
        end

        def SYM_EQ1
          elements[4]
        end

        def SYM_START_DBLOCK1
          elements[5]
        end

        def SYM_UNITS
          elements[6]
        end

        def SYM_EQ2
          elements[7]
        end

        def SYM_START_DBLOCK2
          elements[8]
        end

        def units
          elements[9]
        end

        def SYM_END_DBLOCK1
          elements[10]
        end

        def mag
          elements[11]
        end

        def prec
          elements[12]
        end

        def SYM_END_DBLOCK2
          elements[13]
        end
      end

      module CQuantityItem3
        def value(node)
          magnitude, precision = nil
          magnitude = mag.int.value unless mag.empty?
          precision = prec.int.value unless prec.empty?
          OpenEHR::AM::OpenEHRProfile::DataTypes::Quantity::CQuantityItem.new(
            :path => node.path, :rm_type_name => 'DvQuantity',
            :occurrences => OpenEHR::AssumedLibraryTypes::Interval.new(
                              :upper => 1, 
                              :lower => 1, 
                              :lower_included => true, 
                              :upper_included => true),
            :units => units.value,
            :magnitude => magnitude, :precision => precision)
        end
      end

      def _nt_c_quantity_item
        start_index = index
        if node_cache[:c_quantity_item].has_key?(index)
          cached = node_cache[:c_quantity_item][index]
          if cached
            node_cache[:c_quantity_item][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_V_STRING
          s0 << r2
          if r2
            if (match_len = has_terminal?(']', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure(']')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_white_space
              s0 << r4
              if r4
                r5 = _nt_SYM_EQ
                s0 << r5
                if r5
                  r6 = _nt_SYM_START_DBLOCK
                  s0 << r6
                  if r6
                    r7 = _nt_SYM_UNITS
                    s0 << r7
                    if r7
                      r8 = _nt_SYM_EQ
                      s0 << r8
                      if r8
                        r9 = _nt_SYM_START_DBLOCK
                        s0 << r9
                        if r9
                          r10 = _nt_V_STRING
                          s0 << r10
                          if r10
                            r11 = _nt_SYM_END_DBLOCK
                            s0 << r11
                            if r11
                              i13, s13 = index, []
                              r14 = _nt_SYM_MAGNITUDE
                              s13 << r14
                              if r14
                                r15 = _nt_SYM_EQ
                                s13 << r15
                                if r15
                                  r16 = _nt_SYM_START_DBLOCK
                                  s13 << r16
                                  if r16
                                    r17 = _nt_real_interval_value
                                    s13 << r17
                                    if r17
                                      r18 = _nt_SYM_END_DBLOCK
                                      s13 << r18
                                    end
                                  end
                                end
                              end
                              if s13.last
                                r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                                r13.extend(CQuantityItem0)
                              else
                                @index = i13
                                r13 = nil
                              end
                              if r13
                                r12 = r13
                              else
                                r12 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s0 << r12
                              if r12
                                i20, s20 = index, []
                                r21 = _nt_SYM_PRECISION
                                s20 << r21
                                if r21
                                  r22 = _nt_SYM_EQ
                                  s20 << r22
                                  if r22
                                    r23 = _nt_SYM_START_DBLOCK
                                    s20 << r23
                                    if r23
                                      r24 = _nt_integer_interval_value
                                      s20 << r24
                                      if r24
                                        r25 = _nt_SYM_END_DBLOCK
                                        s20 << r25
                                      end
                                    end
                                  end
                                end
                                if s20.last
                                  r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                                  r20.extend(CQuantityItem1)
                                else
                                  @index = i20
                                  r20 = nil
                                end
                                if r20
                                  r19 = r20
                                else
                                  r19 = instantiate_node(SyntaxNode,input, index...index)
                                end
                                s0 << r19
                                if r19
                                  r26 = _nt_SYM_END_DBLOCK
                                  s0 << r26
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CQuantityItem2)
          r0.extend(CQuantityItem3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:c_quantity_item][start_index] = r0

        r0
      end

      module SYMUNITS0
        def space
          elements[1]
        end
      end

      def _nt_SYM_UNITS
        start_index = index
        if node_cache[:SYM_UNITS].has_key?(index)
          cached = node_cache[:SYM_UNITS][index]
          if cached
            node_cache[:SYM_UNITS][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('units', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('units')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMUNITS0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_UNITS][start_index] = r0

        r0
      end

      module SYMMAGNITUDE0
        def space
          elements[1]
        end
      end

      def _nt_SYM_MAGNITUDE
        start_index = index
        if node_cache[:SYM_MAGNITUDE].has_key?(index)
          cached = node_cache[:SYM_MAGNITUDE][index]
          if cached
            node_cache[:SYM_MAGNITUDE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('magnitude', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('magnitude')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMMAGNITUDE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_MAGNITUDE][start_index] = r0

        r0
      end

      module SYMPRECISION0
        def space
          elements[1]
        end
      end

      def _nt_SYM_PRECISION
        start_index = index
        if node_cache[:SYM_PRECISION].has_key?(index)
          cached = node_cache[:SYM_PRECISION][index]
          if cached
            node_cache[:SYM_PRECISION][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('precision', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('precision')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMPRECISION0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_PRECISION][start_index] = r0

        r0
      end

      module SYMASSUMEDVALUE0
        def space
          elements[1]
        end
      end

      def _nt_SYM_ASSUMED_VALUE
        start_index = index
        if node_cache[:SYM_ASSUMED_VALUE].has_key?(index)
          cached = node_cache[:SYM_ASSUMED_VALUE][index]
          if cached
            node_cache[:SYM_ASSUMED_VALUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('assumed_value', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('assumed_value')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMASSUMEDVALUE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ASSUMED_VALUE][start_index] = r0

        r0
      end

      module VCDOMAINTYPE0
      end

      def _nt_V_C_DOMAIN_TYPE
        start_index = index
        if node_cache[:V_C_DOMAIN_TYPE].has_key?(index)
          cached = node_cache[:V_C_DOMAIN_TYPE][index]
          if cached
            node_cache[:V_C_DOMAIN_TYPE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[A-Z]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[A-Z]')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              r5 = _nt_IDCHAR
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
            if r4
              if (match_len = has_terminal?(')', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure(')')
                r7 = nil
              end
              if r7
                r6 = r7
              else
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r6
              if r6
                s8, i8 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[ \\n]'] ||= Regexp.new(gr), :regexp, index)
                    r9 = true
                    @index += 1
                  else
                    terminal_parse_failure('[ \\n]')
                    r9 = nil
                  end
                  if r9
                    s8 << r9
                  else
                    break
                  end
                end
                r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                s0 << r8
                if r8
                  if (match_len = has_terminal?('<', false, index))
                    r10 = true
                    @index += match_len
                  else
                    terminal_parse_failure('<')
                    r10 = nil
                  end
                  s0 << r10
                  if r10
                    s11, i11 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[^>]'] ||= Regexp.new(gr), :regexp, index)
                        r12 = true
                        @index += 1
                      else
                        terminal_parse_failure('[^>]')
                        r12 = nil
                      end
                      if r12
                        s11 << r12
                      else
                        break
                      end
                    end
                    r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                    s0 << r11
                    if r11
                      if (match_len = has_terminal?('>', false, index))
                        r13 = true
                        @index += match_len
                      else
                        terminal_parse_failure('>')
                        r13 = nil
                      end
                      s0 << r13
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VCDOMAINTYPE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_C_DOMAIN_TYPE][start_index] = r0

        r0
      end

      module VASSERTIONTEXT0
        def assertions
          elements[0]
        end

      end

      module VASSERTIONTEXT1
        def value
          assertions.value
        end
      end

      def _nt_V_ASSERTION_TEXT
        start_index = index
        if node_cache[:V_ASSERTION_TEXT].has_key?(index)
          cached = node_cache[:V_ASSERTION_TEXT][index]
          if cached
            node_cache[:V_ASSERTION_TEXT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_assertions
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VASSERTIONTEXT0)
          r0.extend(VASSERTIONTEXT1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ASSERTION_TEXT][start_index] = r0

        r0
      end

      module Assertions0
        def assertion
          elements[0]
        end

      end

      module Assertions1
        def assertion
          elements[0]
        end

        def more_a
          elements[1]
        end
      end

      module Assertions2
        def value
          assertions.map {|a| a.value}
        end

        def assertions
          [assertion] + more_a.elements.map {|a| a.assertion}
        end
      end

      def _nt_assertions
        start_index = index
        if node_cache[:assertions].has_key?(index)
          cached = node_cache[:assertions][index]
          if cached
            node_cache[:assertions][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_assertion
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_assertion
            s3 << r4
            if r4
              if (match_len = has_terminal?('', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r5 = nil
              end
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Assertions0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Assertions1)
          r0.extend(Assertions2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:assertions][start_index] = r0

        r0
      end

      module Assertion0
        def any_identifier
          elements[0]
        end

      end

      module Assertion1
        def id
          elements[0]
        end

        def boolean_expression
          elements[1]
        end

        def space
          elements[2]
        end
      end

      module Assertion2
        def value
          if (id && !id.empty?)
            OpenEHR::AM::Archetype::Assertion::Assertion.new(
              :tag => id.value, :expression => boolean_expression.value,
              :string_expression => id.text_value + boolean_expression.text_value)
          else
            OpenEHR::AM::Archetype::Assertion::Assertion.new(
              :expression => boolean_expression.value,
              :string_expression => boolean_expression.text_value)
          end
        end
      end

      def _nt_assertion
        start_index = index
        if node_cache[:assertion].has_key?(index)
          cached = node_cache[:assertion][index]
          if cached
            node_cache[:assertion][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i2, s2 = index, []
        r3 = _nt_any_identifier
        s2 << r3
        if r3
          if (match_len = has_terminal?(':', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure(':')
            r4 = nil
          end
          s2 << r4
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Assertion0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r5 = _nt_boolean_expression
          s0 << r5
          if r5
            r6 = _nt_space
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Assertion1)
          r0.extend(Assertion2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:assertion][start_index] = r0

        r0
      end

      module BooleanExpression0
        def boolean_node
          elements[0]
        end

      end

      module BooleanExpression1
        def value
          boolean_node.value
        end
      end

      module BooleanExpression2
        def boolean_leaf
          elements[0]
        end

      end

      module BooleanExpression3
        def value
          boolean_leaf.value
        end
      end

      def _nt_boolean_expression
        start_index = index
        if node_cache[:boolean_expression].has_key?(index)
          cached = node_cache[:boolean_expression][index]
          if cached
            node_cache[:boolean_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_boolean_node
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(BooleanExpression0)
          r1.extend(BooleanExpression1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_boolean_leaf
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(BooleanExpression2)
            r4.extend(BooleanExpression3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:boolean_expression][start_index] = r0

        r0
      end

      module BooleanNode0
        def SYM_EXISTS
          elements[0]
        end

        def absolute_path
          elements[1]
        end
      end

      module BooleanNode1
        def value
          item = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
            :type => 'String',
            :item => absolute_path.value,
            :reference_type => 'CONSTANT')
          OpenEHR::AM::Archetype::Assertion::ExprUnaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EXISTS,
            :operand => item,
            :precedence_overridden => false)
        end
      end

      module BooleanNode2
        def relative_path
          elements[0]
        end

        def white_space
          elements[1]
        end

        def SYM_MATCHES
          elements[2]
        end

        def SYM_START_CBLOCK
          elements[3]
        end

        def c_primitive
          elements[4]
        end

        def SYM_END_CBLOCK
          elements[5]
        end
      end

      module BooleanNode3
        def value
          left_op = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
                      :type => 'String',
                      :item => relative_path.value,
                      :reference_type => 'Constant')
          right_op = OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
                      :item => c_primitive.value,
                      :type => c_primitive.value.type,
                      :reference_type => 'Constant')
          op = OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MATCHES
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => op,
            :right_operand => right_op,
            :left_operand => left_op,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode4
        def SYM_NOT
          elements[0]
        end

        def boolean_leaf
          elements[1]
        end

      end

      module BooleanNode5
        def value
          OpenEHR::AM::Archetype::Assertion::ExprUnaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_NOT,
            :operand => boolean_leaf.value,
            :precedence_overridden => false)
        end
      end

      module BooleanNode6
        def arithmetic_leaf
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode7
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EQ,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode8
        def arithmetic_leaf
          elements[0]
        end

        def SYM_NE
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode9
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_NE,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode10
        def arithmetic_leaf
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode11
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_LT,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode12
        def arithmetic_leaf
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode13
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_GT,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode14
        def arithmetic_leaf
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode15
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_LE,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode16
        def arithmetic_leaf
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module BooleanNode17
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_GE,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode18
        def boolean_leaf
          elements[0]
        end

        def SYM_AND
          elements[1]
        end

        def boolean_expression
          elements[2]
        end
      end

      module BooleanNode19
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_AND,
            :left_operand => boolean_leaf.value,
            :right_operand => boolean_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode20
        def boolean_leaf
          elements[0]
        end

        def SYM_OR
          elements[1]
        end

        def boolean_expression
          elements[2]
        end
      end

      module BooleanNode21
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_OR,
            :left_operand => boolean_leaf.value,
            :right_operand => boolean_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode22
        def boolean_leaf
          elements[0]
        end

        def SYM_XOR
          elements[1]
        end

        def boolean_expression
          elements[2]
        end
      end

      module BooleanNode23
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_XOR,
            :left_operand => boolean_leaf.value,
            :right_operand => boolean_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module BooleanNode24
        def boolean_leaf
          elements[0]
        end

        def SYM_IMPLIES
          elements[1]
        end

        def boolean_expression
          elements[2]
        end
      end

      module BooleanNode25
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_IMPLIES,
            :left_operand => boolean_leaf.value,
            :right_operand => boolean_expression.value,
            :reference_type => 'Constraint')
        end
      end

      def _nt_boolean_node
        start_index = index
        if node_cache[:boolean_node].has_key?(index)
          cached = node_cache[:boolean_node][index]
          if cached
            node_cache[:boolean_node][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_EXISTS
        s1 << r2
        if r2
          r3 = _nt_absolute_path
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(BooleanNode0)
          r1.extend(BooleanNode1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_relative_path
          s4 << r5
          if r5
            r6 = _nt_white_space
            s4 << r6
            if r6
              r7 = _nt_SYM_MATCHES
              s4 << r7
              if r7
                r8 = _nt_SYM_START_CBLOCK
                s4 << r8
                if r8
                  r9 = _nt_c_primitive
                  s4 << r9
                  if r9
                    r10 = _nt_SYM_END_CBLOCK
                    s4 << r10
                  end
                end
              end
            end
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(BooleanNode2)
            r4.extend(BooleanNode3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i11, s11 = index, []
            r12 = _nt_SYM_NOT
            s11 << r12
            if r12
              r13 = _nt_boolean_leaf
              s11 << r13
              if r13
                if (match_len = has_terminal?('', false, index))
                  r14 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r14 = nil
                end
                s11 << r14
              end
            end
            if s11.last
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              r11.extend(BooleanNode4)
              r11.extend(BooleanNode5)
            else
              @index = i11
              r11 = nil
            end
            if r11
              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
              r0 = r11
            else
              i15, s15 = index, []
              r16 = _nt_arithmetic_leaf
              s15 << r16
              if r16
                r17 = _nt_SYM_EQ
                s15 << r17
                if r17
                  r18 = _nt_arithmetic_expression
                  s15 << r18
                end
              end
              if s15.last
                r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
                r15.extend(BooleanNode6)
                r15.extend(BooleanNode7)
              else
                @index = i15
                r15 = nil
              end
              if r15
                r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
                r0 = r15
              else
                i19, s19 = index, []
                r20 = _nt_arithmetic_leaf
                s19 << r20
                if r20
                  r21 = _nt_SYM_NE
                  s19 << r21
                  if r21
                    r22 = _nt_arithmetic_expression
                    s19 << r22
                  end
                end
                if s19.last
                  r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                  r19.extend(BooleanNode8)
                  r19.extend(BooleanNode9)
                else
                  @index = i19
                  r19 = nil
                end
                if r19
                  r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                  r0 = r19
                else
                  i23, s23 = index, []
                  r24 = _nt_arithmetic_leaf
                  s23 << r24
                  if r24
                    r25 = _nt_SYM_LT
                    s23 << r25
                    if r25
                      r26 = _nt_arithmetic_expression
                      s23 << r26
                    end
                  end
                  if s23.last
                    r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                    r23.extend(BooleanNode10)
                    r23.extend(BooleanNode11)
                  else
                    @index = i23
                    r23 = nil
                  end
                  if r23
                    r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                    r0 = r23
                  else
                    i27, s27 = index, []
                    r28 = _nt_arithmetic_leaf
                    s27 << r28
                    if r28
                      r29 = _nt_SYM_GT
                      s27 << r29
                      if r29
                        r30 = _nt_arithmetic_expression
                        s27 << r30
                      end
                    end
                    if s27.last
                      r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                      r27.extend(BooleanNode12)
                      r27.extend(BooleanNode13)
                    else
                      @index = i27
                      r27 = nil
                    end
                    if r27
                      r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                      r0 = r27
                    else
                      i31, s31 = index, []
                      r32 = _nt_arithmetic_leaf
                      s31 << r32
                      if r32
                        r33 = _nt_SYM_LE
                        s31 << r33
                        if r33
                          r34 = _nt_arithmetic_expression
                          s31 << r34
                        end
                      end
                      if s31.last
                        r31 = instantiate_node(SyntaxNode,input, i31...index, s31)
                        r31.extend(BooleanNode14)
                        r31.extend(BooleanNode15)
                      else
                        @index = i31
                        r31 = nil
                      end
                      if r31
                        r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
                        r0 = r31
                      else
                        i35, s35 = index, []
                        r36 = _nt_arithmetic_leaf
                        s35 << r36
                        if r36
                          r37 = _nt_SYM_GE
                          s35 << r37
                          if r37
                            r38 = _nt_arithmetic_expression
                            s35 << r38
                          end
                        end
                        if s35.last
                          r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                          r35.extend(BooleanNode16)
                          r35.extend(BooleanNode17)
                        else
                          @index = i35
                          r35 = nil
                        end
                        if r35
                          r35 = SyntaxNode.new(input, (index-1)...index) if r35 == true
                          r0 = r35
                        else
                          i39, s39 = index, []
                          r40 = _nt_boolean_leaf
                          s39 << r40
                          if r40
                            r41 = _nt_SYM_AND
                            s39 << r41
                            if r41
                              r42 = _nt_boolean_expression
                              s39 << r42
                            end
                          end
                          if s39.last
                            r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                            r39.extend(BooleanNode18)
                            r39.extend(BooleanNode19)
                          else
                            @index = i39
                            r39 = nil
                          end
                          if r39
                            r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                            r0 = r39
                          else
                            i43, s43 = index, []
                            r44 = _nt_boolean_leaf
                            s43 << r44
                            if r44
                              r45 = _nt_SYM_OR
                              s43 << r45
                              if r45
                                r46 = _nt_boolean_expression
                                s43 << r46
                              end
                            end
                            if s43.last
                              r43 = instantiate_node(SyntaxNode,input, i43...index, s43)
                              r43.extend(BooleanNode20)
                              r43.extend(BooleanNode21)
                            else
                              @index = i43
                              r43 = nil
                            end
                            if r43
                              r43 = SyntaxNode.new(input, (index-1)...index) if r43 == true
                              r0 = r43
                            else
                              i47, s47 = index, []
                              r48 = _nt_boolean_leaf
                              s47 << r48
                              if r48
                                r49 = _nt_SYM_XOR
                                s47 << r49
                                if r49
                                  r50 = _nt_boolean_expression
                                  s47 << r50
                                end
                              end
                              if s47.last
                                r47 = instantiate_node(SyntaxNode,input, i47...index, s47)
                                r47.extend(BooleanNode22)
                                r47.extend(BooleanNode23)
                              else
                                @index = i47
                                r47 = nil
                              end
                              if r47
                                r47 = SyntaxNode.new(input, (index-1)...index) if r47 == true
                                r0 = r47
                              else
                                i51, s51 = index, []
                                r52 = _nt_boolean_leaf
                                s51 << r52
                                if r52
                                  r53 = _nt_SYM_IMPLIES
                                  s51 << r53
                                  if r53
                                    r54 = _nt_boolean_expression
                                    s51 << r54
                                  end
                                end
                                if s51.last
                                  r51 = instantiate_node(SyntaxNode,input, i51...index, s51)
                                  r51.extend(BooleanNode24)
                                  r51.extend(BooleanNode25)
                                else
                                  @index = i51
                                  r51 = nil
                                end
                                if r51
                                  r51 = SyntaxNode.new(input, (index-1)...index) if r51 == true
                                  r0 = r51
                                else
                                  @index = i0
                                  r0 = nil
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:boolean_node][start_index] = r0

        r0
      end

      module BooleanLeaf0
        def boolean_expression
          elements[1]
        end

      end

      module BooleanLeaf1
        def value
          boolean_expression.value
        end
      end

      module BooleanLeaf2
        def SYM_TRUE
          elements[0]
        end

      end

      module BooleanLeaf3
        def value
          OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
            :type => 'Boolean',
            :item => true,
            :reference_type => 'CONSTANT')
        end
      end

      module BooleanLeaf4
        def SYM_FALSE
          elements[0]
        end

      end

      module BooleanLeaf5
        def value
          OpenEHR::AM::Archetype::Assertion::ExprLeaf.new(
            :type => 'Boolean',
            :item => false,
            :reference_type => 'CONSTANT')
        end
      end

      def _nt_boolean_leaf
        start_index = index
        if node_cache[:boolean_leaf].has_key?(index)
          cached = node_cache[:boolean_leaf][index]
          if cached
            node_cache[:boolean_leaf][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('(', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_boolean_expression
          s1 << r3
          if r3
            if (match_len = has_terminal?(')', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(')')
              r4 = nil
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(BooleanLeaf0)
          r1.extend(BooleanLeaf1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_SYM_TRUE
          s5 << r6
          if r6
            if (match_len = has_terminal?('', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r7 = nil
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(BooleanLeaf2)
            r5.extend(BooleanLeaf3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            i8, s8 = index, []
            r9 = _nt_SYM_FALSE
            s8 << r9
            if r9
              if (match_len = has_terminal?('', false, index))
                r10 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r10 = nil
              end
              s8 << r10
            end
            if s8.last
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              r8.extend(BooleanLeaf4)
              r8.extend(BooleanLeaf5)
            else
              @index = i8
              r8 = nil
            end
            if r8
              r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
              r0 = r8
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:boolean_leaf][start_index] = r0

        r0
      end

      module ArithmeticExpression0
        def arithmetic_node
          elements[0]
        end

      end

      module ArithmeticExpression1
        def value
          arithmetic_node.value
        end
      end

      module ArithmeticExpression2
        def arithmetic_leaf
          elements[0]
        end

      end

      module ArithmeticExpression3
        def value
          arithmetic_leaf.value
        end
      end

      def _nt_arithmetic_expression
        start_index = index
        if node_cache[:arithmetic_expression].has_key?(index)
          cached = node_cache[:arithmetic_expression][index]
          if cached
            node_cache[:arithmetic_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_arithmetic_node
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArithmeticExpression0)
          r1.extend(ArithmeticExpression1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_arithmetic_leaf
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(ArithmeticExpression2)
            r4.extend(ArithmeticExpression3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:arithmetic_expression][start_index] = r0

        r0
      end

      module ArithmeticNode0
        def arithmetic_leaf
          elements[0]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module ArithmeticNode1
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_PLUS,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module ArithmeticNode2
        def arithmetic_leaf
          elements[0]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module ArithmeticNode3
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MINUS,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module ArithmeticNode4
        def arithmetic_leaf
          elements[0]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module ArithmeticNode5
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_MULTIPLY,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module ArithmeticNode6
        def arithmetic_leaf
          elements[0]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module ArithmeticNode7
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_DIVIDE,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      module ArithmeticNode8
        def arithmetic_leaf
          elements[0]
        end

        def arithmetic_expression
          elements[2]
        end
      end

      module ArithmeticNode9
        def value
          OpenEHR::AM::Archetype::Assertion::ExprBinaryOperator.new(
            :type => 'Boolean',
            :operator => OpenEHR::AM::Archetype::Assertion::OperatorKind::OP_EXP,
            :left_operand => arithmetic_leaf.value,
            :right_operand => arithmetic_expression.value,
            :reference_type => 'Constraint')
        end
      end

      def _nt_arithmetic_node
        start_index = index
        if node_cache[:arithmetic_node].has_key?(index)
          cached = node_cache[:arithmetic_node][index]
          if cached
            node_cache[:arithmetic_node][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_arithmetic_leaf
        s1 << r2
        if r2
          if (match_len = has_terminal?('+', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('+')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_arithmetic_expression
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArithmeticNode0)
          r1.extend(ArithmeticNode1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_arithmetic_leaf
          s5 << r6
          if r6
            if (match_len = has_terminal?('-', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('-')
              r7 = nil
            end
            s5 << r7
            if r7
              r8 = _nt_arithmetic_expression
              s5 << r8
            end
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(ArithmeticNode2)
            r5.extend(ArithmeticNode3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            i9, s9 = index, []
            r10 = _nt_arithmetic_leaf
            s9 << r10
            if r10
              if (match_len = has_terminal?('*', false, index))
                r11 = true
                @index += match_len
              else
                terminal_parse_failure('*')
                r11 = nil
              end
              s9 << r11
              if r11
                r12 = _nt_arithmetic_expression
                s9 << r12
              end
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(ArithmeticNode4)
              r9.extend(ArithmeticNode5)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              i13, s13 = index, []
              r14 = _nt_arithmetic_leaf
              s13 << r14
              if r14
                if (match_len = has_terminal?('/', false, index))
                  r15 = true
                  @index += match_len
                else
                  terminal_parse_failure('/')
                  r15 = nil
                end
                s13 << r15
                if r15
                  r16 = _nt_arithmetic_expression
                  s13 << r16
                end
              end
              if s13.last
                r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                r13.extend(ArithmeticNode6)
                r13.extend(ArithmeticNode7)
              else
                @index = i13
                r13 = nil
              end
              if r13
                r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                r0 = r13
              else
                i17, s17 = index, []
                r18 = _nt_arithmetic_leaf
                s17 << r18
                if r18
                  if (match_len = has_terminal?('^', false, index))
                    r19 = true
                    @index += match_len
                  else
                    terminal_parse_failure('^')
                    r19 = nil
                  end
                  s17 << r19
                  if r19
                    r20 = _nt_arithmetic_expression
                    s17 << r20
                  end
                end
                if s17.last
                  r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                  r17.extend(ArithmeticNode8)
                  r17.extend(ArithmeticNode9)
                else
                  @index = i17
                  r17 = nil
                end
                if r17
                  r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                  r0 = r17
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:arithmetic_node][start_index] = r0

        r0
      end

      module ArithmeticLeaf0
        def arithmetic_expression
          elements[1]
        end

        def space
          elements[3]
        end
      end

      module ArithmeticLeaf1
        def value
          arithmetic_expression.value
        end
      end

      module ArithmeticLeaf2
        def integer_value
          elements[0]
        end

      end

      module ArithmeticLeaf3
        def value
          OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
            :type => 'Integer',
            :item => integer_value.value,
            :reference_type => 'CONSTANT')
        end
      end

      module ArithmeticLeaf4
        def real_value
          elements[0]
        end

      end

      module ArithmeticLeaf5
        def value
          OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
            :type => 'Real',
            :item => real_value.value,
            :reference_type => 'CONSTANT')
        end
      end

      module ArithmeticLeaf6
        def absolute_path
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module ArithmeticLeaf7
        def value
          OpenEHR::AM::Archetype::ConstraintModel::ExprLeaf.new(
            :type => 'String',
            :item => absolute_path.value,
            :reference_type => 'CONSTANT')
          
        end
      end

      def _nt_arithmetic_leaf
        start_index = index
        if node_cache[:arithmetic_leaf].has_key?(index)
          cached = node_cache[:arithmetic_leaf][index]
          if cached
            node_cache[:arithmetic_leaf][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('(', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_arithmetic_expression
          s1 << r3
          if r3
            if (match_len = has_terminal?(')', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(')')
              r4 = nil
            end
            s1 << r4
            if r4
              r5 = _nt_space
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ArithmeticLeaf0)
          r1.extend(ArithmeticLeaf1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_integer_value
          s6 << r7
          if r7
            if (match_len = has_terminal?('', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r8 = nil
            end
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(ArithmeticLeaf2)
            r6.extend(ArithmeticLeaf3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            i9, s9 = index, []
            r10 = _nt_real_value
            s9 << r10
            if r10
              if (match_len = has_terminal?('', false, index))
                r11 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r11 = nil
              end
              s9 << r11
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(ArithmeticLeaf4)
              r9.extend(ArithmeticLeaf5)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              i12, s12 = index, []
              r13 = _nt_absolute_path
              s12 << r13
              if r13
                r14 = _nt_space
                s12 << r14
              end
              if s12.last
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                r12.extend(ArithmeticLeaf6)
                r12.extend(ArithmeticLeaf7)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                r0 = r12
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:arithmetic_leaf][start_index] = r0

        r0
      end

      module ObjectPath0
        def movable_path
          elements[0]
        end

      end

      module ObjectPath1
        def value
          movable_path.value
        end
      end

      module ObjectPath2
        def absolute_path
          elements[0]
        end

      end

      module ObjectPath3
        def value
          absolute_path.value
        end
      end

      module ObjectPath4
        def relative_path
          elements[0]
        end

      end

      module ObjectPath5
        def value
          relative_path.value
        end
      end

      def _nt_object_path
        start_index = index
        if node_cache[:object_path].has_key?(index)
          cached = node_cache[:object_path][index]
          if cached
            node_cache[:object_path][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_movable_path
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ObjectPath0)
          r1.extend(ObjectPath1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_absolute_path
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(ObjectPath2)
            r4.extend(ObjectPath3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_relative_path
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(ObjectPath4)
              r7.extend(ObjectPath5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:object_path][start_index] = r0

        r0
      end

      module MovablePath0
        def SYM_MOVABLE_LEADER
          elements[0]
        end

        def relative_path
          elements[1]
        end

      end

      module MovablePath1
        def value
          text_value
        end
      end

      def _nt_movable_path
        start_index = index
        if node_cache[:movable_path].has_key?(index)
          cached = node_cache[:movable_path][index]
          if cached
            node_cache[:movable_path][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_MOVABLE_LEADER
        s0 << r1
        if r1
          r2 = _nt_relative_path
          s0 << r2
          if r2
            if (match_len = has_terminal?('', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r3 = nil
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MovablePath0)
          r0.extend(MovablePath1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:movable_path][start_index] = r0

        r0
      end

      module AbsolutePath0
      end

      module AbsolutePath1
        def value
          text_value
        end
      end

      def _nt_absolute_path
        start_index = index
        if node_cache[:absolute_path].has_key?(index)
          cached = node_cache[:absolute_path][index]
          if cached
            node_cache[:absolute_path][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('/', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('/')
          r1 = nil
        end
        s0 << r1
        if r1
          r3 = _nt_relative_path
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?('', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r4 = nil
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AbsolutePath0)
          r0.extend(AbsolutePath1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:absolute_path][start_index] = r0

        r0
      end

      module RelativePath0
        def path_segment
          elements[1]
        end
      end

      module RelativePath1
        def path_segment
          elements[0]
        end

      end

      module RelativePath2
        def value
          text_value
        end
      end

      def _nt_relative_path
        start_index = index
        if node_cache[:relative_path].has_key?(index)
          cached = node_cache[:relative_path][index]
          if cached
            node_cache[:relative_path][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_path_segment
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?('/', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('/')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_path_segment
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(RelativePath0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RelativePath1)
          r0.extend(RelativePath2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:relative_path][start_index] = r0

        r0
      end

      module PathSegment0
        def V_ATTRIBUTE_IDENTIFIER
          elements[0]
        end

      end

      module PathSegment1
        def value
          text_value
        end
      end

      def _nt_path_segment
        start_index = index
        if node_cache[:path_segment].has_key?(index)
          cached = node_cache[:path_segment][index]
          if cached
            node_cache[:path_segment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ATTRIBUTE_IDENTIFIER
        s0 << r1
        if r1
          r3 = _nt_V_LOCAL_TERM_CODE_REF
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?('', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r4 = nil
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PathSegment0)
          r0.extend(PathSegment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:path_segment][start_index] = r0

        r0
      end

      def _nt_SYM_MOVABLE_LEADER
        start_index = index
        if node_cache[:SYM_MOVABLE_LEADER].has_key?(index)
          cached = node_cache[:SYM_MOVABLE_LEADER][index]
          if cached
            node_cache[:SYM_MOVABLE_LEADER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('//', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('//')
          r0 = nil
        end

        node_cache[:SYM_MOVABLE_LEADER][start_index] = r0

        r0
      end

      module VDADLTEXT0
        def attr_vals
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module VDADLTEXT1
        def value
          attr_vals.value
        end
      end

      module VDADLTEXT2
        def complex_object_block
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module VDADLTEXT3
        def value
          complex_object_block.value
        end
      end

      def _nt_V_DADL_TEXT
        start_index = index
        if node_cache[:V_DADL_TEXT].has_key?(index)
          cached = node_cache[:V_DADL_TEXT][index]
          if cached
            node_cache[:V_DADL_TEXT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_attr_vals
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VDADLTEXT0)
          r1.extend(VDADLTEXT1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_complex_object_block
          s4 << r5
          if r5
            r6 = _nt_space
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(VDADLTEXT2)
            r4.extend(VDADLTEXT3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:V_DADL_TEXT][start_index] = r0

        r0
      end

      module AttrVals0
        def space1
          elements[1]
        end

        def attr_val
          elements[2]
        end

        def space2
          elements[3]
        end
      end

      module AttrVals1
        def first
          elements[0]
        end

        def second
          elements[1]
        end
      end

      module AttrVals2
        def value
          attrs.inject({ }) {|val, a| val.update a.value}
        end

        def attrs
          [first] + second.elements.map {|e| e.attr_val}
        end
      end

      def _nt_attr_vals
        start_index = index
        if node_cache[:attr_vals].has_key?(index)
          cached = node_cache[:attr_vals][index]
          if cached
            node_cache[:attr_vals][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_attr_val
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?(';', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(';')
              r5 = nil
            end
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              r6 = _nt_space
              s3 << r6
              if r6
                r7 = _nt_attr_val
                s3 << r7
                if r7
                  r8 = _nt_space
                  s3 << r8
                end
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(AttrVals0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AttrVals1)
          r0.extend(AttrVals2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:attr_vals][start_index] = r0

        r0
      end

      module AttrVal0
        def attr_id
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def object_block
          elements[2]
        end
      end

      module AttrVal1
        def value
          {attr_id.value =>  object_block.value}
        end
      end

      def _nt_attr_val
        start_index = index
        if node_cache[:attr_val].has_key?(index)
          cached = node_cache[:attr_val][index]
          if cached
            node_cache[:attr_val][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_attr_id
        s0 << r1
        if r1
          r2 = _nt_SYM_EQ
          s0 << r2
          if r2
            r3 = _nt_object_block
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AttrVal0)
          r0.extend(AttrVal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:attr_val][start_index] = r0

        r0
      end

      module AttrId0
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module AttrId1
        def value
          id.value
        end
      end

      def _nt_attr_id
        start_index = index
        if node_cache[:attr_id].has_key?(index)
          cached = node_cache[:attr_id][index]
          if cached
            node_cache[:attr_id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ATTRIBUTE_IDENTIFIER
        s0 << r1
        if r1
          r2 = _nt_white_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AttrId0)
          r0.extend(AttrId1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:attr_id][start_index] = r0

        r0
      end

      module ObjectBlock0
        def complex_object_block
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module ObjectBlock1
	  def value
        complex_object_block.value
      end
      end

      module ObjectBlock2
        def primitive_object_block
          elements[0]
        end

        def space
          elements[1]
        end
      end

      module ObjectBlock3
        def value
          primitive_object_block.value
        end
      end

      def _nt_object_block
        start_index = index
        if node_cache[:object_block].has_key?(index)
          cached = node_cache[:object_block][index]
          if cached
            node_cache[:object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_complex_object_block
        s1 << r2
        if r2
          r3 = _nt_space
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ObjectBlock0)
          r1.extend(ObjectBlock1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_primitive_object_block
          s4 << r5
          if r5
            r6 = _nt_space
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(ObjectBlock2)
            r4.extend(ObjectBlock3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:object_block][start_index] = r0

        r0
      end

      module ComplexObjectBlock0
        def single_attr_object_block
          elements[0]
        end

      end

      module ComplexObjectBlock1
        def value
          single_attr_object_block.value
        end
      end

      module ComplexObjectBlock2
        def multiple_attr_object_block
          elements[0]
        end

      end

      module ComplexObjectBlock3
        def value
          multiple_attr_object_block.value
        end
      end

      def _nt_complex_object_block
        start_index = index
        if node_cache[:complex_object_block].has_key?(index)
          cached = node_cache[:complex_object_block][index]
          if cached
            node_cache[:complex_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_single_attr_object_block
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ComplexObjectBlock0)
          r1.extend(ComplexObjectBlock1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_multiple_attr_object_block
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(ComplexObjectBlock2)
            r4.extend(ComplexObjectBlock3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:complex_object_block][start_index] = r0

        r0
      end

      module MultipleAttrObjectBlock0
        def untyped_multiple_attr_object_block
          elements[1]
        end
      end

      module MultipleAttrObjectBlock1
        def value
          untyped_multiple_attr_object_block.value
        end
      end

      def _nt_multiple_attr_object_block
        start_index = index
        if node_cache[:multiple_attr_object_block].has_key?(index)
          cached = node_cache[:multiple_attr_object_block][index]
          if cached
            node_cache[:multiple_attr_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_type_identifier
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_untyped_multiple_attr_object_block
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MultipleAttrObjectBlock0)
          r0.extend(MultipleAttrObjectBlock1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:multiple_attr_object_block][start_index] = r0

        r0
      end

      module UntypedMultipleAttrObjectBlock0
        def multiple_attr_object_block_head
          elements[0]
        end

        def keyed_objects
          elements[1]
        end

        def SYM_END_DBLOCK
          elements[2]
        end
      end

      module UntypedMultipleAttrObjectBlock1
        def value
          keyed_objects.value
        end
      end

      def _nt_untyped_multiple_attr_object_block
        start_index = index
        if node_cache[:untyped_multiple_attr_object_block].has_key?(index)
          cached = node_cache[:untyped_multiple_attr_object_block][index]
          if cached
            node_cache[:untyped_multiple_attr_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_multiple_attr_object_block_head
        s0 << r1
        if r1
          r2 = _nt_keyed_objects
          s0 << r2
          if r2
            r3 = _nt_SYM_END_DBLOCK
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UntypedMultipleAttrObjectBlock0)
          r0.extend(UntypedMultipleAttrObjectBlock1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:untyped_multiple_attr_object_block][start_index] = r0

        r0
      end

      def _nt_multiple_attr_object_block_head
        start_index = index
        if node_cache[:multiple_attr_object_block_head].has_key?(index)
          cached = node_cache[:multiple_attr_object_block_head][index]
          if cached
            node_cache[:multiple_attr_object_block_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SYM_START_DBLOCK

        node_cache[:multiple_attr_object_block_head][start_index] = r0

        r0
      end

      module KeyedObjects0
        def value
          elements.inject({ }) {|val, e| val.update e.value}
        end
      end

      def _nt_keyed_objects
        start_index = index
        if node_cache[:keyed_objects].has_key?(index)
          cached = node_cache[:keyed_objects][index]
          if cached
            node_cache[:keyed_objects][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_keyed_object
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(KeyedObjects0)
        end

        node_cache[:keyed_objects][start_index] = r0

        r0
      end

      module KeyedObject0
        def object_key
          elements[0]
        end

        def SYM_EQ
          elements[1]
        end

        def object_block
          elements[2]
        end
      end

      module KeyedObject1
        def value
          {object_key.value => object_block.value}
        end
      end

      def _nt_keyed_object
        start_index = index
        if node_cache[:keyed_object].has_key?(index)
          cached = node_cache[:keyed_object][index]
          if cached
            node_cache[:keyed_object][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_object_key
        s0 << r1
        if r1
          r2 = _nt_SYM_EQ
          s0 << r2
          if r2
            r3 = _nt_object_block
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(KeyedObject0)
          r0.extend(KeyedObject1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:keyed_object][start_index] = r0

        r0
      end

      module ObjectKey0
        def simple_value
          elements[1]
        end

        def white_space
          elements[3]
        end
      end

      module ObjectKey1
        def value
          simple_value.value
        end
      end

      def _nt_object_key
        start_index = index
        if node_cache[:object_key].has_key?(index)
          cached = node_cache[:object_key][index]
          if cached
            node_cache[:object_key][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_simple_value
          s0 << r2
          if r2
            if (match_len = has_terminal?(']', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure(']')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_white_space
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ObjectKey0)
          r0.extend(ObjectKey1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:object_key][start_index] = r0

        r0
      end

      module SingleAttrObjectBlock0
        def untyped_single_attr_object_block
          elements[1]
        end
      end

      module SingleAttrObjectBlock1
        def value
          untyped_single_attr_object_block.value
        end
      end

      def _nt_single_attr_object_block
        start_index = index
        if node_cache[:single_attr_object_block].has_key?(index)
          cached = node_cache[:single_attr_object_block][index]
          if cached
            node_cache[:single_attr_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_type_identifier
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_untyped_single_attr_object_block
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SingleAttrObjectBlock0)
          r0.extend(SingleAttrObjectBlock1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:single_attr_object_block][start_index] = r0

        r0
      end

      module UntypedSingleAttrObjectBlock0
        def single_attr_object_complex_head
          elements[0]
        end

        def attr_vals
          elements[1]
        end

        def SYM_END_DBLOCK
          elements[2]
        end
      end

      module UntypedSingleAttrObjectBlock1
        def value
          elements[1].value
	   end
      end

      module UntypedSingleAttrObjectBlock2
        def single_attr_object_complex_head
          elements[0]
        end

        def SYM_END_DBLOCK
          elements[1]
        end
      end

      module UntypedSingleAttrObjectBlock3
        def value
          nil
        end
      end

      def _nt_untyped_single_attr_object_block
        start_index = index
        if node_cache[:untyped_single_attr_object_block].has_key?(index)
          cached = node_cache[:untyped_single_attr_object_block][index]
          if cached
            node_cache[:untyped_single_attr_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_single_attr_object_complex_head
        s1 << r2
        if r2
          r3 = _nt_attr_vals
          s1 << r3
          if r3
            r4 = _nt_SYM_END_DBLOCK
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(UntypedSingleAttrObjectBlock0)
          r1.extend(UntypedSingleAttrObjectBlock1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_single_attr_object_complex_head
          s5 << r6
          if r6
            r7 = _nt_SYM_END_DBLOCK
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(UntypedSingleAttrObjectBlock2)
            r5.extend(UntypedSingleAttrObjectBlock3)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:untyped_single_attr_object_block][start_index] = r0

        r0
      end

      def _nt_single_attr_object_complex_head
        start_index = index
        if node_cache[:single_attr_object_complex_head].has_key?(index)
          cached = node_cache[:single_attr_object_complex_head][index]
          if cached
            node_cache[:single_attr_object_complex_head][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_SYM_START_DBLOCK

        node_cache[:single_attr_object_complex_head][start_index] = r0

        r0
      end

      module PrimitiveObjectBlock0
        def untyped_primitive_object_block
          elements[1]
        end
      end

      module PrimitiveObjectBlock1
	  def value
	    untyped_primitive_object_block.value
        end
      end

      def _nt_primitive_object_block
        start_index = index
        if node_cache[:primitive_object_block].has_key?(index)
          cached = node_cache[:primitive_object_block][index]
          if cached
            node_cache[:primitive_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_type_identifier
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_untyped_primitive_object_block
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PrimitiveObjectBlock0)
          r0.extend(PrimitiveObjectBlock1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:primitive_object_block][start_index] = r0

        r0
      end

      module UntypedPrimitiveObjectBlock0
        def SYM_START_DBLOCK
          elements[0]
        end

        def primitive_object_value
          elements[1]
        end

        def SYM_END_DBLOCK
          elements[2]
        end
      end

      module UntypedPrimitiveObjectBlock1
	  def value
	    primitive_object_value.value
        end
      end

      def _nt_untyped_primitive_object_block
        start_index = index
        if node_cache[:untyped_primitive_object_block].has_key?(index)
          cached = node_cache[:untyped_primitive_object_block][index]
          if cached
            node_cache[:untyped_primitive_object_block][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SYM_START_DBLOCK
        s0 << r1
        if r1
          r2 = _nt_primitive_object_value
          s0 << r2
          if r2
            r3 = _nt_SYM_END_DBLOCK
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UntypedPrimitiveObjectBlock0)
          r0.extend(UntypedPrimitiveObjectBlock1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:untyped_primitive_object_block][start_index] = r0

        r0
      end

      module PrimitiveObjectValue0
        def term_code_list_value
          elements[0]
        end

      end

      module PrimitiveObjectValue1
        def value
          term_code_list_value.value
        end
      end

      module PrimitiveObjectValue2
        def term_code
          elements[0]
        end

      end

      module PrimitiveObjectValue3
        def value
          term_code.value
        end
      end

      module PrimitiveObjectValue4
        def simple_list_value
          elements[0]
        end

      end

      module PrimitiveObjectValue5
        def value
          simple_list_value.value
        end
      end

      module PrimitiveObjectValue6
        def simple_interval_value
          elements[0]
        end

      end

      module PrimitiveObjectValue7
        def value
          simple_interval_value.value
        end
      end

      module PrimitiveObjectValue8
        def simple_value
          elements[0]
        end

      end

      module PrimitiveObjectValue9
        def value
          simple_value.value
        end
      end

      def _nt_primitive_object_value
        start_index = index
        if node_cache[:primitive_object_value].has_key?(index)
          cached = node_cache[:primitive_object_value][index]
          if cached
            node_cache[:primitive_object_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_term_code_list_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(PrimitiveObjectValue0)
          r1.extend(PrimitiveObjectValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_term_code
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(PrimitiveObjectValue2)
            r4.extend(PrimitiveObjectValue3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_simple_list_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(PrimitiveObjectValue4)
              r7.extend(PrimitiveObjectValue5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_simple_interval_value
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(PrimitiveObjectValue6)
                r10.extend(PrimitiveObjectValue7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_simple_value
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(PrimitiveObjectValue8)
                  r13.extend(PrimitiveObjectValue9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:primitive_object_value][start_index] = r0

        r0
      end

      module SimpleValue0
        def integer_value
          elements[0]
        end

      end

      module SimpleValue1
        def value
          integer_value.value
        end
      end

      module SimpleValue2
        def real_value
          elements[0]
        end

      end

      module SimpleValue3
        def value
          real_value.value
        end
      end

      module SimpleValue4
        def boolean_value
          elements[0]
        end

      end

      module SimpleValue5
        def value
          boolean_value.value
        end
      end

      module SimpleValue6
        def uri_value
          elements[0]
        end

      end

      module SimpleValue7
        def value
          uri_value.value
        end
      end

      module SimpleValue8
        def date_value
          elements[0]
        end

      end

      module SimpleValue9
        def value
          date_value.value
        end
      end

      module SimpleValue10
        def time_value
          elements[0]
        end

      end

      module SimpleValue11
        def value
          time_value.value
        end
      end

      module SimpleValue12
        def date_time_value
          elements[0]
        end

      end

      module SimpleValue13
        def value
          date_time_value.value
        end
      end

      module SimpleValue14
        def duration_value
          elements[0]
        end

      end

      module SimpleValue15
        def value
          duration_value.value
        end
      end

      module SimpleValue16
        def string_value
          elements[0]
        end

      end

      module SimpleValue17
        def value
          string_value.value
        end
      end

      module SimpleValue18
        def character_value
          elements[0]
        end

      end

      module SimpleValue19
        def value
          character_value.value
        end
      end

      def _nt_simple_value
        start_index = index
        if node_cache[:simple_value].has_key?(index)
          cached = node_cache[:simple_value][index]
          if cached
            node_cache[:simple_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(SimpleValue0)
          r1.extend(SimpleValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_real_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(SimpleValue2)
            r4.extend(SimpleValue3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_boolean_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(SimpleValue4)
              r7.extend(SimpleValue5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_uri_value
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(SimpleValue6)
                r10.extend(SimpleValue7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_date_value
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(SimpleValue8)
                  r13.extend(SimpleValue9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_time_value
                  s16 << r17
                  if r17
                    if (match_len = has_terminal?('', false, index))
                      r18 = true
                      @index += match_len
                    else
                      terminal_parse_failure('')
                      r18 = nil
                    end
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(SimpleValue10)
                    r16.extend(SimpleValue11)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    i19, s19 = index, []
                    r20 = _nt_date_time_value
                    s19 << r20
                    if r20
                      if (match_len = has_terminal?('', false, index))
                        r21 = true
                        @index += match_len
                      else
                        terminal_parse_failure('')
                        r21 = nil
                      end
                      s19 << r21
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(SimpleValue12)
                      r19.extend(SimpleValue13)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                      r0 = r19
                    else
                      i22, s22 = index, []
                      r23 = _nt_duration_value
                      s22 << r23
                      if r23
                        if (match_len = has_terminal?('', false, index))
                          r24 = true
                          @index += match_len
                        else
                          terminal_parse_failure('')
                          r24 = nil
                        end
                        s22 << r24
                      end
                      if s22.last
                        r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                        r22.extend(SimpleValue14)
                        r22.extend(SimpleValue15)
                      else
                        @index = i22
                        r22 = nil
                      end
                      if r22
                        r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                        r0 = r22
                      else
                        i25, s25 = index, []
                        r26 = _nt_string_value
                        s25 << r26
                        if r26
                          if (match_len = has_terminal?('', false, index))
                            r27 = true
                            @index += match_len
                          else
                            terminal_parse_failure('')
                            r27 = nil
                          end
                          s25 << r27
                        end
                        if s25.last
                          r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                          r25.extend(SimpleValue16)
                          r25.extend(SimpleValue17)
                        else
                          @index = i25
                          r25 = nil
                        end
                        if r25
                          r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
                          r0 = r25
                        else
                          i28, s28 = index, []
                          r29 = _nt_character_value
                          s28 << r29
                          if r29
                            if (match_len = has_terminal?('', false, index))
                              r30 = true
                              @index += match_len
                            else
                              terminal_parse_failure('')
                              r30 = nil
                            end
                            s28 << r30
                          end
                          if s28.last
                            r28 = instantiate_node(SyntaxNode,input, i28...index, s28)
                            r28.extend(SimpleValue18)
                            r28.extend(SimpleValue19)
                          else
                            @index = i28
                            r28 = nil
                          end
                          if r28
                            r28 = SyntaxNode.new(input, (index-1)...index) if r28 == true
                            r0 = r28
                          else
                            @index = i0
                            r0 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:simple_value][start_index] = r0

        r0
      end

      module SimpleListValue0
        def integer_list_value
          elements[0]
        end

      end

      module SimpleListValue1
        def value
          integer_list_value.value
        end
      end

      module SimpleListValue2
        def real_list_value
          elements[0]
        end

      end

      module SimpleListValue3
        def value
          real_list_value.value
        end
      end

      module SimpleListValue4
        def boolean_list_value
          elements[0]
        end

      end

      module SimpleListValue5
        def value
          boolean_list_value.value
        end
      end

      module SimpleListValue6
        def character_list_value
          elements[0]
        end

      end

      module SimpleListValue7
        def value
          character_list_value.value
        end
      end

      module SimpleListValue8
        def date_list_value
          elements[0]
        end

      end

      module SimpleListValue9
        def value
          date_list_value.value
        end
      end

      module SimpleListValue10
        def time_list_value
          elements[0]
        end

      end

      module SimpleListValue11
        def value
          time_list_value.value
        end
      end

      module SimpleListValue12
        def date_time_list_value
          elements[0]
        end

      end

      module SimpleListValue13
        def value
          date_time_list_value.value
        end
      end

      module SimpleListValue14
        def duration_list_value
          elements[0]
        end

      end

      module SimpleListValue15
        def value
          duration_list_value.value
        end
      end

      module SimpleListValue16
        def string_list_value
          elements[0]
        end

      end

      module SimpleListValue17
        def value
          string_list_value.value
        end
      end

      def _nt_simple_list_value
        start_index = index
        if node_cache[:simple_list_value].has_key?(index)
          cached = node_cache[:simple_list_value][index]
          if cached
            node_cache[:simple_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_list_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(SimpleListValue0)
          r1.extend(SimpleListValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_real_list_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(SimpleListValue2)
            r4.extend(SimpleListValue3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_boolean_list_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(SimpleListValue4)
              r7.extend(SimpleListValue5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_character_list_value
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(SimpleListValue6)
                r10.extend(SimpleListValue7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_date_list_value
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(SimpleListValue8)
                  r13.extend(SimpleListValue9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_time_list_value
                  s16 << r17
                  if r17
                    if (match_len = has_terminal?('', false, index))
                      r18 = true
                      @index += match_len
                    else
                      terminal_parse_failure('')
                      r18 = nil
                    end
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(SimpleListValue10)
                    r16.extend(SimpleListValue11)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    i19, s19 = index, []
                    r20 = _nt_date_time_list_value
                    s19 << r20
                    if r20
                      if (match_len = has_terminal?('', false, index))
                        r21 = true
                        @index += match_len
                      else
                        terminal_parse_failure('')
                        r21 = nil
                      end
                      s19 << r21
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(SimpleListValue12)
                      r19.extend(SimpleListValue13)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                      r0 = r19
                    else
                      i22, s22 = index, []
                      r23 = _nt_duration_list_value
                      s22 << r23
                      if r23
                        if (match_len = has_terminal?('', false, index))
                          r24 = true
                          @index += match_len
                        else
                          terminal_parse_failure('')
                          r24 = nil
                        end
                        s22 << r24
                      end
                      if s22.last
                        r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                        r22.extend(SimpleListValue14)
                        r22.extend(SimpleListValue15)
                      else
                        @index = i22
                        r22 = nil
                      end
                      if r22
                        r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                        r0 = r22
                      else
                        i25, s25 = index, []
                        r26 = _nt_string_list_value
                        s25 << r26
                        if r26
                          if (match_len = has_terminal?('', false, index))
                            r27 = true
                            @index += match_len
                          else
                            terminal_parse_failure('')
                            r27 = nil
                          end
                          s25 << r27
                        end
                        if s25.last
                          r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                          r25.extend(SimpleListValue16)
                          r25.extend(SimpleListValue17)
                        else
                          @index = i25
                          r25 = nil
                        end
                        if r25
                          r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
                          r0 = r25
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:simple_list_value][start_index] = r0

        r0
      end

      module SimpleIntervalValue0
        def integer_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue1
        def value
          integer_interval_value.value
        end
      end

      module SimpleIntervalValue2
        def real_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue3
        def value
          real_interval_value.value
        end
      end

      module SimpleIntervalValue4
        def date_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue5
        def value
          date_interval_value.value
        end
      end

      module SimpleIntervalValue6
        def time_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue7
        def value
          time_interval_value.value
        end
      end

      module SimpleIntervalValue8
        def date_time_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue9
        def value
          date_time_interval_value.value
        end
      end

      module SimpleIntervalValue10
        def duration_interval_value
          elements[0]
        end

      end

      module SimpleIntervalValue11
        def value
          duration_interval_value.value
        end
      end

      def _nt_simple_interval_value
        start_index = index
        if node_cache[:simple_interval_value].has_key?(index)
          cached = node_cache[:simple_interval_value][index]
          if cached
            node_cache[:simple_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_interval_value
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(SimpleIntervalValue0)
          r1.extend(SimpleIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_real_interval_value
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(SimpleIntervalValue2)
            r4.extend(SimpleIntervalValue3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_date_interval_value
            s7 << r8
            if r8
              if (match_len = has_terminal?('', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('')
                r9 = nil
              end
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(SimpleIntervalValue4)
              r7.extend(SimpleIntervalValue5)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_time_interval_value
              s10 << r11
              if r11
                if (match_len = has_terminal?('', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure('')
                  r12 = nil
                end
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(SimpleIntervalValue6)
                r10.extend(SimpleIntervalValue7)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_date_time_interval_value
                s13 << r14
                if r14
                  if (match_len = has_terminal?('', false, index))
                    r15 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r15 = nil
                  end
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(SimpleIntervalValue8)
                  r13.extend(SimpleIntervalValue9)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_duration_interval_value
                  s16 << r17
                  if r17
                    if (match_len = has_terminal?('', false, index))
                      r18 = true
                      @index += match_len
                    else
                      terminal_parse_failure('')
                      r18 = nil
                    end
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(SimpleIntervalValue10)
                    r16.extend(SimpleIntervalValue11)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end

        node_cache[:simple_interval_value][start_index] = r0

        r0
      end

      module TermCode0
        def vtref
          elements[0]
        end

      end

      module TermCode1
        def value
          vtref.value
        end
      end

      def _nt_term_code
        start_index = index
        if node_cache[:term_code].has_key?(index)
          cached = node_cache[:term_code][index]
          if cached
            node_cache[:term_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_QUALIFIED_TERM_CODE_REF
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TermCode0)
          r0.extend(TermCode1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:term_code][start_index] = r0

        r0
      end

      module TermCodeListValue0
        def term_code
          elements[1]
        end
      end

      module TermCodeListValue1
        def first
          elements[0]
        end

        def more
          elements[1]
        end
      end

      module TermCodeListValue2
        def value
          term_codes.map {|t| t.value}
        end

        def term_codes
          [first] + more.elements.map {|e| e.term_code}
        end
      end

      module TermCodeListValue3
        def term_code
          elements[0]
        end

        def SYM_LIST_CONTINUE
          elements[2]
        end
      end

      module TermCodeListValue4
        def value
          [term_code.value]
        end
      end

      def _nt_term_code_list_value
        start_index = index
        if node_cache[:term_code_list_value].has_key?(index)
          cached = node_cache[:term_code_list_value][index]
          if cached
            node_cache[:term_code_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_term_code
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_term_code
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(TermCodeListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TermCodeListValue1)
          r1.extend(TermCodeListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_term_code
          s7 << r8
          if r8
            if (match_len = has_terminal?(',', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r9 = nil
            end
            s7 << r9
            if r9
              r10 = _nt_SYM_LIST_CONTINUE
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(TermCodeListValue3)
            r7.extend(TermCodeListValue4)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:term_code_list_value][start_index] = r0

        r0
      end

      module UriValue0
        def uri
          elements[0]
        end

      end

      module UriValue1
        def value
          uri.value
        end
      end

      def _nt_uri_value
        start_index = index
        if node_cache[:uri_value].has_key?(index)
          cached = node_cache[:uri_value][index]
          if cached
            node_cache[:uri_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_URI
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UriValue0)
          r0.extend(UriValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:uri_value][start_index] = r0

        r0
      end

      module AnyIdentifier0
        def type_identifier
          elements[0]
        end

      end

      module AnyIdentifier1
        def value
          type_identifier.value
        end
      end

      module AnyIdentifier2
        def V_ATTRIBUTE_IDENTIFIER
          elements[0]
        end

      end

      module AnyIdentifier3
        def value
          V_ATTRIBUTE_IDENTIFIER.value
        end
      end

      def _nt_any_identifier
        start_index = index
        if node_cache[:any_identifier].has_key?(index)
          cached = node_cache[:any_identifier][index]
          if cached
            node_cache[:any_identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_type_identifier
        s1 << r2
        if r2
          if (match_len = has_terminal?('', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(AnyIdentifier0)
          r1.extend(AnyIdentifier1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_V_ATTRIBUTE_IDENTIFIER
          s4 << r5
          if r5
            if (match_len = has_terminal?('', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(AnyIdentifier2)
            r4.extend(AnyIdentifier3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:any_identifier][start_index] = r0

        r0
      end

      module TypeIdentifier0
        def id
          elements[1]
        end

        def white_space
          elements[3]
        end
      end

      module TypeIdentifier1
        def value
          id.value
        end
      end

      module TypeIdentifier2
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module TypeIdentifier3
        def value
          id.value
        end
      end

      module TypeIdentifier4
        def id
          elements[1]
        end

        def white_space
          elements[3]
        end
      end

      module TypeIdentifier5
        def value
          id.value
        end
      end

      module TypeIdentifier6
        def id
          elements[0]
        end

        def white_space
          elements[1]
        end
      end

      module TypeIdentifier7
        def value
          id.value
        end
      end

      def _nt_type_identifier
        start_index = index
        if node_cache[:type_identifier].has_key?(index)
          cached = node_cache[:type_identifier][index]
          if cached
            node_cache[:type_identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('(', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_V_GENERIC_TYPE_IDENTIFIER
          s1 << r3
          if r3
            if (match_len = has_terminal?(')', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(')')
              r4 = nil
            end
            s1 << r4
            if r4
              r5 = _nt_white_space
              s1 << r5
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TypeIdentifier0)
          r1.extend(TypeIdentifier1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i6, s6 = index, []
          r7 = _nt_V_GENERIC_TYPE_IDENTIFIER
          s6 << r7
          if r7
            r8 = _nt_white_space
            s6 << r8
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(TypeIdentifier2)
            r6.extend(TypeIdentifier3)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            i9, s9 = index, []
            if (match_len = has_terminal?('(', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure('(')
              r10 = nil
            end
            s9 << r10
            if r10
              r11 = _nt_V_TYPE_IDENTIFIER
              s9 << r11
              if r11
                if (match_len = has_terminal?(')', false, index))
                  r12 = true
                  @index += match_len
                else
                  terminal_parse_failure(')')
                  r12 = nil
                end
                s9 << r12
                if r12
                  r13 = _nt_white_space
                  s9 << r13
                end
              end
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(TypeIdentifier4)
              r9.extend(TypeIdentifier5)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              i14, s14 = index, []
              r15 = _nt_V_TYPE_IDENTIFIER
              s14 << r15
              if r15
                r16 = _nt_white_space
                s14 << r16
              end
              if s14.last
                r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                r14.extend(TypeIdentifier6)
                r14.extend(TypeIdentifier7)
              else
                @index = i14
                r14 = nil
              end
              if r14
                r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                r0 = r14
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:type_identifier][start_index] = r0

        r0
      end

      module BooleanValue0
        def value
          true
        end
      end

      module BooleanValue1
        def value
          false
        end
      end

      def _nt_boolean_value
        start_index = index
        if node_cache[:boolean_value].has_key?(index)
          cached = node_cache[:boolean_value][index]
          if cached
            node_cache[:boolean_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_SYM_TRUE
        r1.extend(BooleanValue0)
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_SYM_FALSE
          r2.extend(BooleanValue1)
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:boolean_value][start_index] = r0

        r0
      end

      module BooleanListValue0
        def boolean_value
          elements[0]
        end

      end

      module BooleanListValue1
        def white_space
          elements[1]
        end

        def more_bool
          elements[2]
        end
      end

      module BooleanListValue2
        def boolean_value
          elements[0]
        end

      end

      module BooleanListValue3
        def value
          booelans.map {|b| b.value} 
        end

        def booleans
          [boolean_value] + more_bool.elements.map { |b| b.boolean_value }
        end
      end

      module BooleanListValue4
        def boolean_value
          elements[0]
        end

        def white_space
          elements[1]
        end

        def SYM_LIST_CONTINUE
          elements[2]
        end
      end

      module BooleanListValue5
        def value
          [boolean_value.value]
        end
      end

      def _nt_boolean_list_value
        start_index = index
        if node_cache[:boolean_list_value].has_key?(index)
          cached = node_cache[:boolean_list_value][index]
          if cached
            node_cache[:boolean_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_boolean_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                i7, s7 = index, []
                r8 = _nt_boolean_value
                s7 << r8
                if r8
                  if (match_len = has_terminal?('', false, index))
                    r9 = true
                    @index += match_len
                  else
                    terminal_parse_failure('')
                    r9 = nil
                  end
                  s7 << r9
                end
                if s7.last
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                  r7.extend(BooleanListValue0)
                else
                  @index = i7
                  r7 = nil
                end
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(BooleanListValue1)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(BooleanListValue2)
          r1.extend(BooleanListValue3)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i10, s10 = index, []
          r11 = _nt_boolean_value
          s10 << r11
          if r11
            r12 = _nt_white_space
            s10 << r12
            if r12
              r13 = _nt_SYM_LIST_CONTINUE
              s10 << r13
            end
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(BooleanListValue4)
            r10.extend(BooleanListValue5)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:boolean_list_value][start_index] = r0

        r0
      end

      module IntegerValue0
        def V_INTEGER
          elements[1]
        end

      end

      module IntegerValue1
        def value
          text_value.to_i
        end
      end

      def _nt_integer_value
        start_index = index
        if node_cache[:integer_value].has_key?(index)
          cached = node_cache[:integer_value][index]
          if cached
            node_cache[:integer_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[+-]')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_V_INTEGER
          s0 << r3
          if r3
            if (match_len = has_terminal?('', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('')
              r4 = nil
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IntegerValue0)
          r0.extend(IntegerValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:integer_value][start_index] = r0

        r0
      end

      module IntegerListValue0
        def white_space
          elements[1]
        end

        def integer_value
          elements[2]
        end
      end

      module IntegerListValue1
        def integer_value
          elements[0]
        end

        def more_i
          elements[1]
        end
      end

      module IntegerListValue2
        def value
          integers.map { |i| i.value }
        end

        def integers
          [integer_value] + more_i.elements.map { |i| i.integer_value }
        end
      end

      module IntegerListValue3
        def integer_value
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module IntegerListValue4
        def value
          [integer_value.value]
        end
      end

      def _nt_integer_list_value
        start_index = index
        if node_cache[:integer_list_value].has_key?(index)
          cached = node_cache[:integer_list_value][index]
          if cached
            node_cache[:integer_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_integer_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_integer_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(IntegerListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(IntegerListValue1)
          r1.extend(IntegerListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_integer_value
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_white_space
              s8 << r11
              if r11
                r12 = _nt_SYM_LIST_CONTINUE
                s8 << r12
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(IntegerListValue3)
            r8.extend(IntegerListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:integer_list_value][start_index] = r0

        r0
      end

      module IntegerIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module IntegerIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
          :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module IntegerIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module IntegerIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module IntegerIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module IntegerIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module IntegerIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module IntegerIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module IntegerIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module IntegerIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module IntegerIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module IntegerIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module IntegerIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module IntegerIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module IntegerIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def iv
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module IntegerIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => iv.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module IntegerIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module IntegerIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_integer_interval_value
        start_index = index
        if node_cache[:integer_interval_value].has_key?(index)
          cached = node_cache[:integer_interval_value][index]
          if cached
            node_cache[:integer_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_integer_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_integer_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(IntegerIntervalValue0)
          r1.extend(IntegerIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_integer_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_integer_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(IntegerIntervalValue2)
            r9.extend(IntegerIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_integer_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_integer_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(IntegerIntervalValue4)
              r16.extend(IntegerIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_integer_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_integer_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(IntegerIntervalValue6)
                r23.extend(IntegerIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_integer_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(IntegerIntervalValue8)
                  r29.extend(IntegerIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_integer_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(IntegerIntervalValue10)
                    r34.extend(IntegerIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_integer_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(IntegerIntervalValue12)
                      r39.extend(IntegerIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_integer_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(IntegerIntervalValue14)
                        r44.extend(IntegerIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_integer_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(IntegerIntervalValue16)
                          r49.extend(IntegerIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:integer_interval_value][start_index] = r0

        r0
      end

      module RealValue0
        def V_REAL
          elements[1]
        end
      end

      module RealValue1
        def value
          text_value.to_f
        end
      end

      def _nt_real_value
        start_index = index
        if node_cache[:real_value].has_key?(index)
          cached = node_cache[:real_value][index]
          if cached
            node_cache[:real_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i2 = index
        if (match_len = has_terminal?('+', false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('+')
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r2 = r3
        else
          if (match_len = has_terminal?('-', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('-')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r2 = r4
          else
            @index = i2
            r2 = nil
          end
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r5 = _nt_V_REAL
          s0 << r5
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RealValue0)
          r0.extend(RealValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:real_value][start_index] = r0

        r0
      end

      module RealListValue0
        def white_space
          elements[1]
        end

        def real_value
          elements[2]
        end
      end

      module RealListValue1
        def real_value
          elements[0]
        end

        def more_i
          elements[1]
        end
      end

      module RealListValue2
        def value
          reals.map { |i| i.value }
        end

        def reals
          [real_value] + more_i.elements.map { |i| i.real_value }
        end
      end

      module RealListValue3
        def real_value
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module RealListValue4
        def value
          [real_value.value]
        end
      end

      def _nt_real_list_value
        start_index = index
        if node_cache[:real_list_value].has_key?(index)
          cached = node_cache[:real_list_value][index]
          if cached
            node_cache[:real_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_real_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_real_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(RealListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(RealListValue1)
          r1.extend(RealListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_real_value
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_white_space
              s8 << r11
              if r11
                r12 = _nt_SYM_LIST_CONTINUE
                s8 << r12
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(RealListValue3)
            r8.extend(RealListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:real_list_value][start_index] = r0

        r0
      end

      module RealIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module RealIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module RealIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module RealIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module RealIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module RealIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module RealIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module RealIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module RealIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module RealIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module RealIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module RealIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module RealIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module RealIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module RealIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module RealIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module RealIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module RealIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_real_interval_value
        start_index = index
        if node_cache[:real_interval_value].has_key?(index)
          cached = node_cache[:real_interval_value][index]
          if cached
            node_cache[:real_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_real_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_real_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(RealIntervalValue0)
          r1.extend(RealIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_real_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_real_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(RealIntervalValue2)
            r9.extend(RealIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_real_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_real_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(RealIntervalValue4)
              r16.extend(RealIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_real_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_real_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(RealIntervalValue6)
                r23.extend(RealIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_real_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(RealIntervalValue8)
                  r29.extend(RealIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_real_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(RealIntervalValue10)
                    r34.extend(RealIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_real_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(RealIntervalValue12)
                      r39.extend(RealIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_real_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(RealIntervalValue14)
                        r44.extend(RealIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_real_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(RealIntervalValue16)
                          r49.extend(RealIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:real_interval_value][start_index] = r0

        r0
      end

      module CharacterValue0
        def V_CHAR
          elements[0]
        end

      end

      module CharacterValue1
        def value
          text_value
        end
      end

      def _nt_character_value
        start_index = index
        if node_cache[:character_value].has_key?(index)
          cached = node_cache[:character_value][index]
          if cached
            node_cache[:character_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_CHAR
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CharacterValue0)
          r0.extend(CharacterValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:character_value][start_index] = r0

        r0
      end

      module CharacterListValue0
        def white_space
          elements[1]
        end

        def more_chars
          elements[2]
        end
      end

      module CharacterListValue1
        def character_value
          elements[0]
        end

      end

      module CharacterListValue2
        def value
          characters.map {|c| c.value }
        end

        def characters
          [character_value] + more_chars.elements.map {|c| c.character_value}
        end
      end

      module CharacterListValue3
        def character_value
          elements[0]
        end

        def SYM_LIST_CONTINUE
          elements[2]
        end
      end

      module CharacterListValue4
        def value
          [character_value.value]
        end
      end

      def _nt_character_list_value
        start_index = index
        if node_cache[:character_list_value].has_key?(index)
          cached = node_cache[:character_list_value][index]
          if cached
            node_cache[:character_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_character_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_character_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(CharacterListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CharacterListValue1)
          r1.extend(CharacterListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_character_value
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_SYM_LIST_CONTINUE
              s8 << r11
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(CharacterListValue3)
            r8.extend(CharacterListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:character_list_value][start_index] = r0

        r0
      end

      module StringValue0
        def str
          elements[0]
        end

      end

      module StringValue1
        def value
          str.value
        end
      end

      def _nt_string_value
        start_index = index
        if node_cache[:string_value].has_key?(index)
          cached = node_cache[:string_value][index]
          if cached
            node_cache[:string_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_STRING
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(StringValue0)
          r0.extend(StringValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:string_value][start_index] = r0

        r0
      end

      module StringListValue0
        def white_space
          elements[1]
        end

        def string_value
          elements[2]
        end
      end

      module StringListValue1
        def first
          elements[0]
        end

        def second
          elements[1]
        end
      end

      module StringListValue2
        def value
          strings.map {|s| s.value}
        end

        def strings
          [first] + second.elements.map {|s| s.string_value}
        end
      end

      module StringListValue3
        def str
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module StringListValue4
        def value
          [str.value]
        end
      end

      def _nt_string_list_value
        start_index = index
        if node_cache[:string_list_value].has_key?(index)
          cached = node_cache[:string_list_value][index]
          if cached
            node_cache[:string_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_string_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_string_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(StringListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(StringListValue1)
          r1.extend(StringListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_V_STRING
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_white_space
              s8 << r11
              if r11
                r12 = _nt_SYM_LIST_CONTINUE
                s8 << r12
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(StringListValue3)
            r8.extend(StringListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:string_list_value][start_index] = r0

        r0
      end

      module DateValue0
        def ed
          elements[0]
        end

      end

      module DateValue1
        def value
          ::OpenEHR::RM::DataTypes::Quantity::DateTime::DvDate.new(
            :value => ed.text_value)
        end
      end

      def _nt_date_value
        start_index = index
        if node_cache[:date_value].has_key?(index)
          cached = node_cache[:date_value][index]
          if cached
            node_cache[:date_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ISO8601_EXTENDED_DATE
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DateValue0)
          r0.extend(DateValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:date_value][start_index] = r0

        r0
      end

      module DateListValue0
        def white_space
          elements[1]
        end

        def date_value
          elements[2]
        end
      end

      module DateListValue1
        def date_value
          elements[0]
        end

        def more_dates
          elements[1]
        end
      end

      module DateListValue2
        def value
          dates.map {|d| d.value}
        end

        def dates
          [date_value] + more_dates.elements.map {|d| d.date_value}
        end
      end

      module DateListValue3
        def date_value
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module DateListValue4
        def value
          [date_value.value]
        end
      end

      def _nt_date_list_value
        start_index = index
        if node_cache[:date_list_value].has_key?(index)
          cached = node_cache[:date_list_value][index]
          if cached
            node_cache[:date_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_date_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_date_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(DateListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DateListValue1)
          r1.extend(DateListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_date_value
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_white_space
              s8 << r11
              if r11
                r12 = _nt_SYM_LIST_CONTINUE
                s8 << r12
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(DateListValue3)
            r8.extend(DateListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:date_list_value][start_index] = r0

        r0
      end

      module DateIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module DateIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module DateIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DateIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module DateIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DateIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module DateIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module DateIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module DateIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module DateIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module DateIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module DateIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def val
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module DateIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module DateIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_date_interval_value
        start_index = index
        if node_cache[:date_interval_value].has_key?(index)
          cached = node_cache[:date_interval_value][index]
          if cached
            node_cache[:date_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_date_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_date_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DateIntervalValue0)
          r1.extend(DateIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_date_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_date_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(DateIntervalValue2)
            r9.extend(DateIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_date_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_date_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(DateIntervalValue4)
              r16.extend(DateIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_date_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_date_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(DateIntervalValue6)
                r23.extend(DateIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_date_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(DateIntervalValue8)
                  r29.extend(DateIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_date_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(DateIntervalValue10)
                    r34.extend(DateIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_date_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(DateIntervalValue12)
                      r39.extend(DateIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_date_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(DateIntervalValue14)
                        r44.extend(DateIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_date_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(DateIntervalValue16)
                          r49.extend(DateIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:date_interval_value][start_index] = r0

        r0
      end

      module TimeValue0
        def ti
          elements[0]
        end

      end

      module TimeValue1
        def value
          ::OpenEHR::RM::DataTypes::Quantity::DateTime::DvTime.new(
            :value => ti.text_value)
        end
      end

      def _nt_time_value
        start_index = index
        if node_cache[:time_value].has_key?(index)
          cached = node_cache[:time_value][index]
          if cached
            node_cache[:time_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ISO8601_EXTENDED_TIME
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TimeValue0)
          r0.extend(TimeValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:time_value][start_index] = r0

        r0
      end

      module TimeListValue0
        def white_space
          elements[1]
        end

        def time_value
          elements[2]
        end
      end

      module TimeListValue1
        def time_value
          elements[0]
        end

        def more_t
          elements[1]
        end
      end

      module TimeListValue2
        def value
          times.map {|t| t.value}
        end

        def times
          [time_value] + more_t.elements.map {|t| t.time_value}
        end
      end

      module TimeListValue3
        def time_value
          elements[0]
        end

        def white_space
          elements[2]
        end

        def SYM_LIST_CONTINUE
          elements[3]
        end
      end

      module TimeListValue4
        def value
          [time_value.value]
        end
      end

      def _nt_time_list_value
        start_index = index
        if node_cache[:time_list_value].has_key?(index)
          cached = node_cache[:time_list_value][index]
          if cached
            node_cache[:time_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_time_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_white_space
              s4 << r6
              if r6
                r7 = _nt_time_value
                s4 << r7
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(TimeListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TimeListValue1)
          r1.extend(TimeListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_time_value
          s8 << r9
          if r9
            if (match_len = has_terminal?(',', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r10 = nil
            end
            s8 << r10
            if r10
              r11 = _nt_white_space
              s8 << r11
              if r11
                r12 = _nt_SYM_LIST_CONTINUE
                s8 << r12
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(TimeListValue3)
            r8.extend(TimeListValue4)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:time_list_value][start_index] = r0

        r0
      end

      module TimeIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module TimeIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module TimeIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module TimeIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module TimeIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module TimeIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module TimeIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module TimeIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module TimeIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module TimeIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module TimeIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module TimeIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module TimeIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module TimeIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module TimeIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def tv
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module TimeIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => tv.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module TimeIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module TimeIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_time_interval_value
        start_index = index
        if node_cache[:time_interval_value].has_key?(index)
          cached = node_cache[:time_interval_value][index]
          if cached
            node_cache[:time_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_time_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_time_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TimeIntervalValue0)
          r1.extend(TimeIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_time_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_time_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(TimeIntervalValue2)
            r9.extend(TimeIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_time_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_time_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(TimeIntervalValue4)
              r16.extend(TimeIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_time_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_time_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(TimeIntervalValue6)
                r23.extend(TimeIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_time_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(TimeIntervalValue8)
                  r29.extend(TimeIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_time_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(TimeIntervalValue10)
                    r34.extend(TimeIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_time_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(TimeIntervalValue12)
                      r39.extend(TimeIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_time_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(TimeIntervalValue14)
                        r44.extend(TimeIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_time_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(TimeIntervalValue16)
                          r49.extend(TimeIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:time_interval_value][start_index] = r0

        r0
      end

      module DateTimeValue0
        def dt
          elements[0]
        end

      end

      module DateTimeValue1
        def value
          ::OpenEHR::RM::DataTypes::Quantity::DateTime::DvDateTime.new(
            :value => dt.text_value)
        end
      end

      def _nt_date_time_value
        start_index = index
        if node_cache[:date_time_value].has_key?(index)
          cached = node_cache[:date_time_value][index]
          if cached
            node_cache[:date_time_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ISO8601_EXTENDED_DATE_TIME
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DateTimeValue0)
          r0.extend(DateTimeValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:date_time_value][start_index] = r0

        r0
      end

      module DateTimeListValue0
        def more_dt
          elements[1]
        end
      end

      module DateTimeListValue1
        def date_time_value
          elements[0]
        end

      end

      module DateTimeListValue2
        def value
          date_times.map {|t| t.value}
        end

        def date_times
          [date_time_value] + more_dt.elements.map {|dt| dt.date_time_value}
        end
      end

      module DateTimeListValue3
        def date_time_value
          elements[0]
        end

        def SYM_LIST_CONTINUE
          elements[2]
        end
      end

      module DateTimeListValue4
        def value
          [date_time_value.value]
        end
      end

      def _nt_date_time_list_value
        start_index = index
        if node_cache[:date_time_list_value].has_key?(index)
          cached = node_cache[:date_time_list_value][index]
          if cached
            node_cache[:date_time_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_date_time_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_date_time_value
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(DateTimeListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DateTimeListValue1)
          r1.extend(DateTimeListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_date_time_value
          s7 << r8
          if r8
            if (match_len = has_terminal?(',', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r9 = nil
            end
            s7 << r9
            if r9
              r10 = _nt_SYM_LIST_CONTINUE
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(DateTimeListValue3)
            r7.extend(DateTimeListValue4)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:date_time_list_value][start_index] = r0

        r0
      end

      module DateTimeIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module DateTimeIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module DateTimeIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DateTimeIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module DateTimeIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DateTimeIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module DateTimeIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module DateTimeIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module DateTimeIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateTimeIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module DateTimeIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateTimeIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module DateTimeIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateTimeIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module DateTimeIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def dt
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DateTimeIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => dt.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module DateTimeIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module DateTimeIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_date_time_interval_value
        start_index = index
        if node_cache[:date_time_interval_value].has_key?(index)
          cached = node_cache[:date_time_interval_value][index]
          if cached
            node_cache[:date_time_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_date_time_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_date_time_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DateTimeIntervalValue0)
          r1.extend(DateTimeIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_date_time_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_date_time_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(DateTimeIntervalValue2)
            r9.extend(DateTimeIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_date_time_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_date_time_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(DateTimeIntervalValue4)
              r16.extend(DateTimeIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_date_time_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_date_time_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(DateTimeIntervalValue6)
                r23.extend(DateTimeIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_date_time_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(DateTimeIntervalValue8)
                  r29.extend(DateTimeIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_date_time_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(DateTimeIntervalValue10)
                    r34.extend(DateTimeIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_date_time_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(DateTimeIntervalValue12)
                      r39.extend(DateTimeIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_date_time_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(DateTimeIntervalValue14)
                        r44.extend(DateTimeIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_date_time_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(DateTimeIntervalValue16)
                          r49.extend(DateTimeIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:date_time_interval_value][start_index] = r0

        r0
      end

      module DurationValue0
        def du
          elements[0]
        end

      end

      module DurationValue1
        def value
          ::OpenEHR::RM::DataTypes::Quantity::DateTime::DvDuration.new(
            :value => du.text_value)
        end
      end

      def _nt_duration_value
        start_index = index
        if node_cache[:duration_value].has_key?(index)
          cached = node_cache[:duration_value][index]
          if cached
            node_cache[:duration_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_V_ISO8601_DURATION
        s0 << r1
        if r1
          if (match_len = has_terminal?('', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DurationValue0)
          r0.extend(DurationValue1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:duration_value][start_index] = r0

        r0
      end

      module DurationListValue0
        def duration_value
          elements[1]
        end
      end

      module DurationListValue1
        def duration_value
          elements[0]
        end

        def more_d
          elements[1]
        end
      end

      module DurationListValue2
        def value
          durations.map {|d| d.value}
        end

        def durations
          [duration_value] + more_d.elements.map {|d| d.duration_value}
        end
      end

      module DurationListValue3
        def duration_value
          elements[0]
        end

        def SYM_LIST_CONTINUE
          elements[2]
        end
      end

      module DurationListValue4
        def value
          [duration_value.value]
        end
      end

      def _nt_duration_list_value
        start_index = index
        if node_cache[:duration_list_value].has_key?(index)
          cached = node_cache[:duration_list_value][index]
          if cached
            node_cache[:duration_list_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_duration_value
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r5 = nil
            end
            s4 << r5
            if r5
              r6 = _nt_duration_value
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(DurationListValue0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DurationListValue1)
          r1.extend(DurationListValue2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i7, s7 = index, []
          r8 = _nt_duration_value
          s7 << r8
          if r8
            if (match_len = has_terminal?(',', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure(',')
              r9 = nil
            end
            s7 << r9
            if r9
              r10 = _nt_SYM_LIST_CONTINUE
              s7 << r10
            end
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(DurationListValue3)
            r7.extend(DurationListValue4)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:duration_list_value][start_index] = r0

        r0
      end

      module DurationIntervalValue0
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def SYM_LT
          elements[4]
        end

        def up
          elements[5]
        end

        def SYM_INTERVAL_DELIM2
          elements[6]
        end
      end

      module DurationIntervalValue1
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => false)
        end
      end

      module DurationIntervalValue2
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_ELLIPSIS
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DurationIntervalValue3
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => false,
                :upper_included => true)
        end
      end

      module DurationIntervalValue4
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def SYM_LT
          elements[3]
        end

        def up
          elements[4]
        end

        def SYM_INTERVAL_DELIM2
          elements[5]
        end
      end

      module DurationIntervalValue5
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => false)
        end
      end

      module DurationIntervalValue6
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def lo
          elements[1]
        end

        def SYM_ELLIPSIS
          elements[2]
        end

        def up
          elements[3]
        end

        def SYM_INTERVAL_DELIM2
          elements[4]
        end
      end

      module DurationIntervalValue7
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(:lower => lo.value,
                :upper => up.value,
                :lower_included => true,
                :upper_included => true)
        end
      end

      module DurationIntervalValue8
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LT
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DurationIntervalValue9
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => false)
        end
      end

      module DurationIntervalValue10
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_LE
          elements[1]
        end

        def up
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DurationIntervalValue11
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => up.value,
                :lower_unbounded => true,
                :upper_included => true)
        end
      end

      module DurationIntervalValue12
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GT
          elements[1]
        end

        def lo
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DurationIntervalValue13
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => lo.value,
                :uppper_unbounded => true,
                :lower_included => false)
        end
      end

      module DurationIntervalValue14
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def SYM_GE
          elements[1]
        end

        def val
          elements[2]
        end

        def SYM_INTERVAL_DELIM2
          elements[3]
        end
      end

      module DurationIntervalValue15
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :lower => val.value,
                :upper_unbounded => true,
                :lower_included => true)
        end
      end

      module DurationIntervalValue16
        def SYM_INTERVAL_DELIM1
          elements[0]
        end

        def val
          elements[1]
        end

        def SYM_INTERVAL_DELIM2
          elements[2]
        end
      end

      module DurationIntervalValue17
        def value
          OpenEHR::AssumedLibraryTypes::Interval.new(
                :upper => val.value,
                :lower => val.value,
                :upper_included => true,
                :lower_included => true)
        end
      end

      def _nt_duration_interval_value
        start_index = index
        if node_cache[:duration_interval_value].has_key?(index)
          cached = node_cache[:duration_interval_value][index]
          if cached
            node_cache[:duration_interval_value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_SYM_INTERVAL_DELIM
        s1 << r2
        if r2
          r3 = _nt_SYM_GT
          s1 << r3
          if r3
            r4 = _nt_duration_value
            s1 << r4
            if r4
              r5 = _nt_SYM_ELLIPSIS
              s1 << r5
              if r5
                r6 = _nt_SYM_LT
                s1 << r6
                if r6
                  r7 = _nt_duration_value
                  s1 << r7
                  if r7
                    r8 = _nt_SYM_INTERVAL_DELIM
                    s1 << r8
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(DurationIntervalValue0)
          r1.extend(DurationIntervalValue1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_SYM_INTERVAL_DELIM
          s9 << r10
          if r10
            r11 = _nt_SYM_GT
            s9 << r11
            if r11
              r12 = _nt_duration_value
              s9 << r12
              if r12
                r13 = _nt_SYM_ELLIPSIS
                s9 << r13
                if r13
                  r14 = _nt_duration_value
                  s9 << r14
                  if r14
                    r15 = _nt_SYM_INTERVAL_DELIM
                    s9 << r15
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(DurationIntervalValue2)
            r9.extend(DurationIntervalValue3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i16, s16 = index, []
            r17 = _nt_SYM_INTERVAL_DELIM
            s16 << r17
            if r17
              r18 = _nt_duration_value
              s16 << r18
              if r18
                r19 = _nt_SYM_ELLIPSIS
                s16 << r19
                if r19
                  r20 = _nt_SYM_LT
                  s16 << r20
                  if r20
                    r21 = _nt_duration_value
                    s16 << r21
                    if r21
                      r22 = _nt_SYM_INTERVAL_DELIM
                      s16 << r22
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(DurationIntervalValue4)
              r16.extend(DurationIntervalValue5)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
            else
              i23, s23 = index, []
              r24 = _nt_SYM_INTERVAL_DELIM
              s23 << r24
              if r24
                r25 = _nt_duration_value
                s23 << r25
                if r25
                  r26 = _nt_SYM_ELLIPSIS
                  s23 << r26
                  if r26
                    r27 = _nt_duration_value
                    s23 << r27
                    if r27
                      r28 = _nt_SYM_INTERVAL_DELIM
                      s23 << r28
                    end
                  end
                end
              end
              if s23.last
                r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                r23.extend(DurationIntervalValue6)
                r23.extend(DurationIntervalValue7)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                r0 = r23
              else
                i29, s29 = index, []
                r30 = _nt_SYM_INTERVAL_DELIM
                s29 << r30
                if r30
                  r31 = _nt_SYM_LT
                  s29 << r31
                  if r31
                    r32 = _nt_duration_value
                    s29 << r32
                    if r32
                      r33 = _nt_SYM_INTERVAL_DELIM
                      s29 << r33
                    end
                  end
                end
                if s29.last
                  r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                  r29.extend(DurationIntervalValue8)
                  r29.extend(DurationIntervalValue9)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                  r0 = r29
                else
                  i34, s34 = index, []
                  r35 = _nt_SYM_INTERVAL_DELIM
                  s34 << r35
                  if r35
                    r36 = _nt_SYM_LE
                    s34 << r36
                    if r36
                      r37 = _nt_duration_value
                      s34 << r37
                      if r37
                        r38 = _nt_SYM_INTERVAL_DELIM
                        s34 << r38
                      end
                    end
                  end
                  if s34.last
                    r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                    r34.extend(DurationIntervalValue10)
                    r34.extend(DurationIntervalValue11)
                  else
                    @index = i34
                    r34 = nil
                  end
                  if r34
                    r34 = SyntaxNode.new(input, (index-1)...index) if r34 == true
                    r0 = r34
                  else
                    i39, s39 = index, []
                    r40 = _nt_SYM_INTERVAL_DELIM
                    s39 << r40
                    if r40
                      r41 = _nt_SYM_GT
                      s39 << r41
                      if r41
                        r42 = _nt_duration_value
                        s39 << r42
                        if r42
                          r43 = _nt_SYM_INTERVAL_DELIM
                          s39 << r43
                        end
                      end
                    end
                    if s39.last
                      r39 = instantiate_node(SyntaxNode,input, i39...index, s39)
                      r39.extend(DurationIntervalValue12)
                      r39.extend(DurationIntervalValue13)
                    else
                      @index = i39
                      r39 = nil
                    end
                    if r39
                      r39 = SyntaxNode.new(input, (index-1)...index) if r39 == true
                      r0 = r39
                    else
                      i44, s44 = index, []
                      r45 = _nt_SYM_INTERVAL_DELIM
                      s44 << r45
                      if r45
                        r46 = _nt_SYM_GE
                        s44 << r46
                        if r46
                          r47 = _nt_duration_value
                          s44 << r47
                          if r47
                            r48 = _nt_SYM_INTERVAL_DELIM
                            s44 << r48
                          end
                        end
                      end
                      if s44.last
                        r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                        r44.extend(DurationIntervalValue14)
                        r44.extend(DurationIntervalValue15)
                      else
                        @index = i44
                        r44 = nil
                      end
                      if r44
                        r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                        r0 = r44
                      else
                        i49, s49 = index, []
                        r50 = _nt_SYM_INTERVAL_DELIM
                        s49 << r50
                        if r50
                          r51 = _nt_duration_value
                          s49 << r51
                          if r51
                            r52 = _nt_SYM_INTERVAL_DELIM
                            s49 << r52
                          end
                        end
                        if s49.last
                          r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                          r49.extend(DurationIntervalValue16)
                          r49.extend(DurationIntervalValue17)
                        else
                          @index = i49
                          r49 = nil
                        end
                        if r49
                          r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                          r0 = r49
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:duration_interval_value][start_index] = r0

        r0
      end

      def _nt_ALPHANUM
        start_index = index
        if node_cache[:ALPHANUM].has_key?(index)
          cached = node_cache[:ALPHANUM][index]
          if cached
            node_cache[:ALPHANUM][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9]')
          r0 = nil
        end

        node_cache[:ALPHANUM][start_index] = r0

        r0
      end

      def _nt_IDCHAR
        start_index = index
        if node_cache[:IDCHAR].has_key?(index)
          cached = node_cache[:IDCHAR][index]
          if cached
            node_cache[:IDCHAR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9_]')
          r0 = nil
        end

        node_cache[:IDCHAR][start_index] = r0

        r0
      end

      def _nt_NAMECHAR
        start_index = index
        if node_cache[:NAMECHAR].has_key?(index)
          cached = node_cache[:NAMECHAR][index]
          if cached
            node_cache[:NAMECHAR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\._\\-]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9\\._\\-]')
          r0 = nil
        end

        node_cache[:NAMECHAR][start_index] = r0

        r0
      end

      def _nt_NAMECHAR_SPACE
        start_index = index
        if node_cache[:NAMECHAR_SPACE].has_key?(index)
          cached = node_cache[:NAMECHAR_SPACE][index]
          if cached
            node_cache[:NAMECHAR_SPACE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\._\\- ]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9\\._\\- ]')
          r0 = nil
        end

        node_cache[:NAMECHAR_SPACE][start_index] = r0

        r0
      end

      def _nt_NAMECHAR_PAREN
        start_index = index
        if node_cache[:NAMECHAR_PAREN].has_key?(index)
          cached = node_cache[:NAMECHAR_PAREN][index]
          if cached
            node_cache[:NAMECHAR_PAREN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9\\._\\-\\(\\)]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9\\._\\-\\(\\)]')
          r0 = nil
        end

        node_cache[:NAMECHAR_PAREN][start_index] = r0

        r0
      end

      module NAMESTR0
      end

      def _nt_NAMESTR
        start_index = index
        if node_cache[:NAMESTR].has_key?(index)
          cached = node_cache[:NAMESTR][index]
          if cached
            node_cache[:NAMESTR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[a-zA-Z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z0-9_]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NAMESTR0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:NAMESTR][start_index] = r0

        r0
      end

      module Space0
        def white_space
          elements[1]
        end
      end

      def _nt_space
        start_index = index
        if node_cache[:space].has_key?(index)
          cached = node_cache[:space][index]
          if cached
            node_cache[:space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_COMMENT
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r3 = _nt_white_space
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Space0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:space][start_index] = r0

        r0
      end

      module COMMENT0
        def white_space
          elements[0]
        end

      end

      def _nt_COMMENT
        start_index = index
        if node_cache[:COMMENT].has_key?(index)
          cached = node_cache[:COMMENT][index]
          if cached
            node_cache[:COMMENT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_white_space
        s0 << r1
        if r1
          if (match_len = has_terminal?('--', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('--')
            r2 = nil
          end
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[^\\n]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[^\\n]')
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
            if r3
              if (match_len = has_terminal?("\n", false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure("\n")
                r5 = nil
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(COMMENT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:COMMENT][start_index] = r0

        r0
      end

      def _nt_white_space
        start_index = index
        if node_cache[:white_space].has_key?(index)
          cached = node_cache[:white_space][index]
          if cached
            node_cache[:white_space][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[ \\t\\r\\n]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[ \\t\\r\\n]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:white_space][start_index] = r0

        r0
      end

      def _nt_Minus_code
        start_index = index
        if node_cache[:Minus_code].has_key?(index)
          cached = node_cache[:Minus_code][index]
          if cached
            node_cache[:Minus_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('-', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('-')
          r0 = nil
        end

        node_cache[:Minus_code][start_index] = r0

        r0
      end

      def _nt_Plus_Code
        start_index = index
        if node_cache[:Plus_Code].has_key?(index)
          cached = node_cache[:Plus_Code][index]
          if cached
            node_cache[:Plus_Code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('+', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('+')
          r0 = nil
        end

        node_cache[:Plus_Code][start_index] = r0

        r0
      end

      def _nt_Star_code
        start_index = index
        if node_cache[:Star_code].has_key?(index)
          cached = node_cache[:Star_code][index]
          if cached
            node_cache[:Star_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('*', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('*')
          r0 = nil
        end

        node_cache[:Star_code][start_index] = r0

        r0
      end

      def _nt_Slash_code
        start_index = index
        if node_cache[:Slash_code].has_key?(index)
          cached = node_cache[:Slash_code][index]
          if cached
            node_cache[:Slash_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('/', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('/')
          r0 = nil
        end

        node_cache[:Slash_code][start_index] = r0

        r0
      end

      def _nt_Carret_code
        start_index = index
        if node_cache[:Carret_code].has_key?(index)
          cached = node_cache[:Carret_code][index]
          if cached
            node_cache[:Carret_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('^', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('^')
          r0 = nil
        end

        node_cache[:Carret_code][start_index] = r0

        r0
      end

      def _nt_Dot_code
        start_index = index
        if node_cache[:Dot_code].has_key?(index)
          cached = node_cache[:Dot_code][index]
          if cached
            node_cache[:Dot_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('.', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('.')
          r0 = nil
        end

        node_cache[:Dot_code][start_index] = r0

        r0
      end

      def _nt_Semicolon_code
        start_index = index
        if node_cache[:Semicolon_code].has_key?(index)
          cached = node_cache[:Semicolon_code][index]
          if cached
            node_cache[:Semicolon_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(';', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure(';')
          r0 = nil
        end

        node_cache[:Semicolon_code][start_index] = r0

        r0
      end

      def _nt_Colon_code
        start_index = index
        if node_cache[:Colon_code].has_key?(index)
          cached = node_cache[:Colon_code][index]
          if cached
            node_cache[:Colon_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(':', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure(':')
          r0 = nil
        end

        node_cache[:Colon_code][start_index] = r0

        r0
      end

      def _nt_Comma_code
        start_index = index
        if node_cache[:Comma_code].has_key?(index)
          cached = node_cache[:Comma_code][index]
          if cached
            node_cache[:Comma_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(',', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure(',')
          r0 = nil
        end

        node_cache[:Comma_code][start_index] = r0

        r0
      end

      def _nt_Expclamation_code
        start_index = index
        if node_cache[:Expclamation_code].has_key?(index)
          cached = node_cache[:Expclamation_code][index]
          if cached
            node_cache[:Expclamation_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('!', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('!')
          r0 = nil
        end

        node_cache[:Expclamation_code][start_index] = r0

        r0
      end

      def _nt_Left_parenthesis_code
        start_index = index
        if node_cache[:Left_parenthesis_code].has_key?(index)
          cached = node_cache[:Left_parenthesis_code][index]
          if cached
            node_cache[:Left_parenthesis_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('(', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('(')
          r0 = nil
        end

        node_cache[:Left_parenthesis_code][start_index] = r0

        r0
      end

      def _nt_Right_parenthesis_code
        start_index = index
        if node_cache[:Right_parenthesis_code].has_key?(index)
          cached = node_cache[:Right_parenthesis_code][index]
          if cached
            node_cache[:Right_parenthesis_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(')', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure(')')
          r0 = nil
        end

        node_cache[:Right_parenthesis_code][start_index] = r0

        r0
      end

      def _nt_Dollar_code
        start_index = index
        if node_cache[:Dollar_code].has_key?(index)
          cached = node_cache[:Dollar_code][index]
          if cached
            node_cache[:Dollar_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('$', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('$')
          r0 = nil
        end

        node_cache[:Dollar_code][start_index] = r0

        r0
      end

      def _nt_SYM_DT_UNKNOWN
        start_index = index
        if node_cache[:SYM_DT_UNKNOWN].has_key?(index)
          cached = node_cache[:SYM_DT_UNKNOWN][index]
          if cached
            node_cache[:SYM_DT_UNKNOWN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('??', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('??')
          r0 = nil
        end

        node_cache[:SYM_DT_UNKNOWN][start_index] = r0

        r0
      end

      def _nt_Question_mark_code
        start_index = index
        if node_cache[:Question_mark_code].has_key?(index)
          cached = node_cache[:Question_mark_code][index]
          if cached
            node_cache[:Question_mark_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('?', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('?')
          r0 = nil
        end

        node_cache[:Question_mark_code][start_index] = r0

        r0
      end

      def _nt_SYM_INTERVAL_DELIM
        start_index = index
        if node_cache[:SYM_INTERVAL_DELIM].has_key?(index)
          cached = node_cache[:SYM_INTERVAL_DELIM][index]
          if cached
            node_cache[:SYM_INTERVAL_DELIM][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('|', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('|')
          r0 = nil
        end

        node_cache[:SYM_INTERVAL_DELIM][start_index] = r0

        r0
      end

      module LeftBracketCode0
        def space
          elements[1]
        end
      end

      def _nt_Left_bracket_code
        start_index = index
        if node_cache[:Left_bracket_code].has_key?(index)
          cached = node_cache[:Left_bracket_code][index]
          if cached
            node_cache[:Left_bracket_code][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LeftBracketCode0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:Left_bracket_code][start_index] = r0

        r0
      end

      def _nt_Right_bracket_codde
        start_index = index
        if node_cache[:Right_bracket_codde].has_key?(index)
          cached = node_cache[:Right_bracket_codde][index]
          if cached
            node_cache[:Right_bracket_codde][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(']', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure(']')
          r0 = nil
        end

        node_cache[:Right_bracket_codde][start_index] = r0

        r0
      end

      module SYMEQ0
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_EQ
        start_index = index
        if node_cache[:SYM_EQ].has_key?(index)
          cached = node_cache[:SYM_EQ][index]
          if cached
            node_cache[:SYM_EQ][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('=', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('=')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_white_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMEQ0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_EQ][start_index] = r0

        r0
      end

      module SYMGE0
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_GE
        start_index = index
        if node_cache[:SYM_GE].has_key?(index)
          cached = node_cache[:SYM_GE][index]
          if cached
            node_cache[:SYM_GE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('=>', false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('=>')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('>=', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('>=')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r4 = _nt_white_space
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMGE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_GE][start_index] = r0

        r0
      end

      module SYMLE0
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_LE
        start_index = index
        if node_cache[:SYM_LE].has_key?(index)
          cached = node_cache[:SYM_LE][index]
          if cached
            node_cache[:SYM_LE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('<=', false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('<=')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('=>', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('=>')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r4 = _nt_white_space
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMLE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_LE][start_index] = r0

        r0
      end

      module SYMLT0
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_LT
        start_index = index
        if node_cache[:SYM_LT].has_key?(index)
          cached = node_cache[:SYM_LT][index]
          if cached
            node_cache[:SYM_LT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('<', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('<')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_white_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMLT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_LT][start_index] = r0

        r0
      end

      module SYMGT0
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_GT
        start_index = index
        if node_cache[:SYM_GT].has_key?(index)
          cached = node_cache[:SYM_GT][index]
          if cached
            node_cache[:SYM_GT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('>', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('>')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_white_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMGT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_GT][start_index] = r0

        r0
      end

      module SYMSTARTDBLOCK0
        def space
          elements[1]
        end
      end

      def _nt_SYM_START_DBLOCK
        start_index = index
        if node_cache[:SYM_START_DBLOCK].has_key?(index)
          cached = node_cache[:SYM_START_DBLOCK][index]
          if cached
            node_cache[:SYM_START_DBLOCK][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('<', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('<')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMSTARTDBLOCK0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_START_DBLOCK][start_index] = r0

        r0
      end

      module SYMENDDBLOCK0
        def space
          elements[1]
        end
      end

      def _nt_SYM_END_DBLOCK
        start_index = index
        if node_cache[:SYM_END_DBLOCK].has_key?(index)
          cached = node_cache[:SYM_END_DBLOCK][index]
          if cached
            node_cache[:SYM_END_DBLOCK][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('>', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('>')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMENDDBLOCK0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_END_DBLOCK][start_index] = r0

        r0
      end

      module SYMSTARTCBLOCK0
        def space
          elements[1]
        end
      end

      def _nt_SYM_START_CBLOCK
        start_index = index
        if node_cache[:SYM_START_CBLOCK].has_key?(index)
          cached = node_cache[:SYM_START_CBLOCK][index]
          if cached
            node_cache[:SYM_START_CBLOCK][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('{', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('{')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_space
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMSTARTCBLOCK0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_START_CBLOCK][start_index] = r0

        r0
      end

      def _nt_SYM_END_CBLOCK
        start_index = index
        if node_cache[:SYM_END_CBLOCK].has_key?(index)
          cached = node_cache[:SYM_END_CBLOCK][index]
          if cached
            node_cache[:SYM_END_CBLOCK][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('}', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('}')
          r0 = nil
        end

        node_cache[:SYM_END_CBLOCK][start_index] = r0

        r0
      end

      def _nt_SYM_ELLIPSIS
        start_index = index
        if node_cache[:SYM_ELLIPSIS].has_key?(index)
          cached = node_cache[:SYM_ELLIPSIS][index]
          if cached
            node_cache[:SYM_ELLIPSIS][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('..', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('..')
          r0 = nil
        end

        node_cache[:SYM_ELLIPSIS][start_index] = r0

        r0
      end

      def _nt_SYM_LIST_CONTINUE
        start_index = index
        if node_cache[:SYM_LIST_CONTINUE].has_key?(index)
          cached = node_cache[:SYM_LIST_CONTINUE][index]
          if cached
            node_cache[:SYM_LIST_CONTINUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('...', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('...')
          r0 = nil
        end

        node_cache[:SYM_LIST_CONTINUE][start_index] = r0

        r0
      end

      module SYMINFINITY0
        def space
          elements[8]
        end
      end

      def _nt_SYM_INFINITY
        start_index = index
        if node_cache[:SYM_INFINITY].has_key?(index)
          cached = node_cache[:SYM_INFINITY][index]
          if cached
            node_cache[:SYM_INFINITY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ff]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ii]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Nn]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ii]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Yy]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMINFINITY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_INFINITY][start_index] = r0

        r0
      end

      module SYMARCHETYPE0
        def space
          elements[9]
        end
      end

      def _nt_SYM_ARCHETYPE
        start_index = index
        if node_cache[:SYM_ARCHETYPE].has_key?(index)
          cached = node_cache[:SYM_ARCHETYPE][index]
          if cached
            node_cache[:SYM_ARCHETYPE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Aa]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Rr]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Cc]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Hh]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Hh]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ee]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Tt]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Yy]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Pp]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ee]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMARCHETYPE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ARCHETYPE][start_index] = r0

        r0
      end

      module SYMMATCHES0
      end

      module SYMMATCHES1
      end

      module SYMMATCHES2
        def white_space
          elements[1]
        end
      end

      def _nt_SYM_MATCHES
        start_index = index
        if node_cache[:SYM_MATCHES].has_key?(index)
          cached = node_cache[:SYM_MATCHES][index]
          if cached
            node_cache[:SYM_MATCHES][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
          r3 = true
          @index += 1
        else
          terminal_parse_failure('[Mm]')
          r3 = nil
        end
        s2 << r3
        if r3
          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[Aa]')
            r4 = nil
          end
          s2 << r4
          if r4
            if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[Tt]')
              r5 = nil
            end
            s2 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[Cc]')
                r6 = nil
              end
              s2 << r6
              if r6
                if has_terminal?(@regexps[gr = '\A[Hh]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[Hh]')
                  r7 = nil
                end
                s2 << r7
                if r7
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r8 = nil
                  end
                  s2 << r8
                  if r8
                    if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ss]')
                      r9 = nil
                    end
                    s2 << r9
                  end
                end
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(SYMMATCHES0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          i10, s10 = index, []
          if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
            r11 = true
            @index += 1
          else
            terminal_parse_failure('[Ii]')
            r11 = nil
          end
          s10 << r11
          if r11
            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
              r12 = true
              @index += 1
            else
              terminal_parse_failure('[Ss]')
              r12 = nil
            end
            s10 << r12
            if r12
              if (match_len = has_terminal?('_', false, index))
                r13 = true
                @index += match_len
              else
                terminal_parse_failure('_')
                r13 = nil
              end
              s10 << r13
              if r13
                if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                  r14 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ii]')
                  r14 = nil
                end
                s10 << r14
                if r14
                  if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                    r15 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Nn]')
                    r15 = nil
                  end
                  s10 << r15
                end
              end
            end
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(SYMMATCHES1)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
            r1 = r10
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r16 = _nt_white_space
          s0 << r16
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMMATCHES2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_MATCHES][start_index] = r0

        r0
      end

      module SYMTHEN0
        def space
          elements[4]
        end
      end

      def _nt_SYM_THEN
        start_index = index
        if node_cache[:SYM_THEN].has_key?(index)
          cached = node_cache[:SYM_THEN][index]
          if cached
            node_cache[:SYM_THEN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Tt]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Hh]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Hh]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ee]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Nn]')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMTHEN0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_THEN][start_index] = r0

        r0
      end

      module SYMELSE0
        def space
          elements[4]
        end
      end

      def _nt_SYM_ELSE
        start_index = index
        if node_cache[:SYM_ELSE].has_key?(index)
          cached = node_cache[:SYM_ELSE][index]
          if cached
            node_cache[:SYM_ELSE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ee]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ll]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ss]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ee]')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMELSE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ELSE][start_index] = r0

        r0
      end

      module SYMAND0
        def space
          elements[3]
        end
      end

      def _nt_SYM_AND
        start_index = index
        if node_cache[:SYM_AND].has_key?(index)
          cached = node_cache[:SYM_AND][index]
          if cached
            node_cache[:SYM_AND][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Aa]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Dd]')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_space
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMAND0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_AND][start_index] = r0

        r0
      end

      module SYMOR0
        def space
          elements[2]
        end
      end

      def _nt_SYM_OR
        start_index = index
        if node_cache[:SYM_OR].has_key?(index)
          cached = node_cache[:SYM_OR][index]
          if cached
            node_cache[:SYM_OR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Oo]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Rr]')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_space
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMOR0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_OR][start_index] = r0

        r0
      end

      module SYMXOR0
        def space
          elements[3]
        end
      end

      def _nt_SYM_XOR
        start_index = index
        if node_cache[:SYM_XOR].has_key?(index)
          cached = node_cache[:SYM_XOR][index]
          if cached
            node_cache[:SYM_XOR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Xx]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Xx]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Oo]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Rr]')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_space
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMXOR0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_XOR][start_index] = r0

        r0
      end

      module SYMNOT0
        def space
          elements[3]
        end
      end

      def _nt_SYM_NOT
        start_index = index
        if node_cache[:SYM_NOT].has_key?(index)
          cached = node_cache[:SYM_NOT][index]
          if cached
            node_cache[:SYM_NOT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Nn]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Oo]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Tt]')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_space
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMNOT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_NOT][start_index] = r0

        r0
      end

      module SYMIMPLIES0
        def space
          elements[7]
        end
      end

      def _nt_SYM_IMPLIES
        start_index = index
        if node_cache[:SYM_IMPLIES].has_key?(index)
          cached = node_cache[:SYM_IMPLIES][index]
          if cached
            node_cache[:SYM_IMPLIES][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Mm]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Pp]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ll]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ii]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ss]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMIMPLIES0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_IMPLIES][start_index] = r0

        r0
      end

      module SYMTRUE0
        def space
          elements[4]
        end
      end

      def _nt_SYM_TRUE
        start_index = index
        if node_cache[:SYM_TRUE].has_key?(index)
          cached = node_cache[:SYM_TRUE][index]
          if cached
            node_cache[:SYM_TRUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Tt]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Rr]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Uu]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ee]')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_space
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMTRUE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_TRUE][start_index] = r0

        r0
      end

      module SYMFALSE0
        def space
          elements[5]
        end
      end

      def _nt_SYM_FALSE
        start_index = index
        if node_cache[:SYM_FALSE].has_key?(index)
          cached = node_cache[:SYM_FALSE][index]
          if cached
            node_cache[:SYM_FALSE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ff]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Aa]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ll]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ss]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ee]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_space
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMFALSE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_FALSE][start_index] = r0

        r0
      end

      module SYMFORALL0
        def space
          elements[7]
        end
      end

      def _nt_SYM_FORALL
        start_index = index
        if node_cache[:SYM_FORALL].has_key?(index)
          cached = node_cache[:SYM_FORALL][index]
          if cached
            node_cache[:SYM_FORALL][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ff]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Oo]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Rr]')
              r3 = nil
            end
            s0 << r3
            if r3
              if (match_len = has_terminal?('_', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('_')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Aa]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ll]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ll]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMFORALL0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_FORALL][start_index] = r0

        r0
      end

      module SYMEXISTS0
        def space
          elements[6]
        end
      end

      def _nt_SYM_EXISTS
        start_index = index
        if node_cache[:SYM_EXISTS].has_key?(index)
          cached = node_cache[:SYM_EXISTS][index]
          if cached
            node_cache[:SYM_EXISTS][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ee]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Xx]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Xx]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ii]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ss]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Tt]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ss]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMEXISTS0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_EXISTS][start_index] = r0

        r0
      end

      module SYMEXISTENCE0
        def space
          elements[9]
        end
      end

      def _nt_SYM_EXISTENCE
        start_index = index
        if node_cache[:SYM_EXISTENCE].has_key?(index)
          cached = node_cache[:SYM_EXISTENCE][index]
          if cached
            node_cache[:SYM_EXISTENCE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ee]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Xx]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Xx]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ii]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ss]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Tt]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Nn]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Cc]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ee]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMEXISTENCE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_EXISTENCE][start_index] = r0

        r0
      end

      module SYMOCCURRENCES0
        def white_space
          elements[11]
        end
      end

      def _nt_SYM_OCCURRENCES
        start_index = index
        if node_cache[:SYM_OCCURRENCES].has_key?(index)
          cached = node_cache[:SYM_OCCURRENCES][index]
          if cached
            node_cache[:SYM_OCCURRENCES][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Oo]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Cc]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Cc]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Uu]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Rr]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ee]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Nn]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Cc]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Ee]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Ss]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_white_space
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMOCCURRENCES0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_OCCURRENCES][start_index] = r0

        r0
      end

      module SYMCARDINALITY0
        def white_space
          elements[11]
        end
      end

      def _nt_SYM_CARDINALITY
        start_index = index
        if node_cache[:SYM_CARDINALITY].has_key?(index)
          cached = node_cache[:SYM_CARDINALITY][index]
          if cached
            node_cache[:SYM_CARDINALITY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Cc]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Aa]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Rr]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Dd]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ii]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Nn]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Aa]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ll]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ii]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Tt]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Yy]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_white_space
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMCARDINALITY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_CARDINALITY][start_index] = r0

        r0
      end

      module SYMORDERED0
        def white_space
          elements[7]
        end
      end

      def _nt_SYM_ORDERED
        start_index = index
        if node_cache[:SYM_ORDERED].has_key?(index)
          cached = node_cache[:SYM_ORDERED][index]
          if cached
            node_cache[:SYM_ORDERED][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Oo]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Rr]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Dd]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ee]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Dd]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_white_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMORDERED0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ORDERED][start_index] = r0

        r0
      end

      module SYMUNORDERD0
        def white_space
          elements[9]
        end
      end

      def _nt_SYM_UNORDERD
        start_index = index
        if node_cache[:SYM_UNORDERD].has_key?(index)
          cached = node_cache[:SYM_UNORDERD][index]
          if cached
            node_cache[:SYM_UNORDERD][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Uu]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Oo]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Rr]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Dd]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Rr]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Dd]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_white_space
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMUNORDERD0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_UNORDERD][start_index] = r0

        r0
      end

      module SYMUNIQUE0
        def space
          elements[6]
        end
      end

      def _nt_SYM_UNIQUE
        start_index = index
        if node_cache[:SYM_UNIQUE].has_key?(index)
          cached = node_cache[:SYM_UNIQUE][index]
          if cached
            node_cache[:SYM_UNIQUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Uu]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ii]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Qq]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Qq]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Uu]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_space
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMUNIQUE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_UNIQUE][start_index] = r0

        r0
      end

      module SYMINFINITY0
        def space
          elements[8]
        end
      end

      def _nt_SYM_INFINITY
        start_index = index
        if node_cache[:SYM_INFINITY].has_key?(index)
          cached = node_cache[:SYM_INFINITY][index]
          if cached
            node_cache[:SYM_INFINITY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ff]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ii]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Nn]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ii]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Yy]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMINFINITY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_INFINITY][start_index] = r0

        r0
      end

      module SYMUSENODE0
        def space
          elements[8]
        end
      end

      def _nt_SYM_USE_NODE
        start_index = index
        if node_cache[:SYM_USE_NODE].has_key?(index)
          cached = node_cache[:SYM_USE_NODE][index]
          if cached
            node_cache[:SYM_USE_NODE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Uu]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ss]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ee]')
              r3 = nil
            end
            s0 << r3
            if r3
              if (match_len = has_terminal?('_', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('_')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Nn]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Oo]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Dd]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMUSENODE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_USE_NODE][start_index] = r0

        r0
      end

      module SYMALLOWARCHETYPE0
      end

      module SYMALLOWARCHETYPE1
      end

      module SYMALLOWARCHETYPE2
        def space
          elements[11]
        end
      end

      def _nt_SYM_ALLOW_ARCHETYPE
        start_index = index
        if node_cache[:SYM_ALLOW_ARCHETYPE].has_key?(index)
          cached = node_cache[:SYM_ALLOW_ARCHETYPE][index]
          if cached
            node_cache[:SYM_ALLOW_ARCHETYPE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
          r3 = true
          @index += 1
        else
          terminal_parse_failure('[Aa]')
          r3 = nil
        end
        s2 << r3
        if r3
          if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[Ll]')
            r4 = nil
          end
          s2 << r4
          if r4
            if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[Ll]')
              r5 = nil
            end
            s2 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[Oo]')
                r6 = nil
              end
              s2 << r6
              if r6
                if has_terminal?(@regexps[gr = '\A[Ww]'] ||= Regexp.new(gr), :regexp, index)
                  r7 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ww]')
                  r7 = nil
                end
                s2 << r7
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(SYMALLOWARCHETYPE0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          i8, s8 = index, []
          if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
            r9 = true
            @index += 1
          else
            terminal_parse_failure('[Uu]')
            r9 = nil
          end
          s8 << r9
          if r9
            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
              r10 = true
              @index += 1
            else
              terminal_parse_failure('[Ss]')
              r10 = nil
            end
            s8 << r10
            if r10
              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                r11 = true
                @index += 1
              else
                terminal_parse_failure('[Ee]')
                r11 = nil
              end
              s8 << r11
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(SYMALLOWARCHETYPE1)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r1 = r8
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('_', false, index))
            r12 = true
            @index += match_len
          else
            terminal_parse_failure('_')
            r12 = nil
          end
          s0 << r12
          if r12
            if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
              r13 = true
              @index += 1
            else
              terminal_parse_failure('[Aa]')
              r13 = nil
            end
            s0 << r13
            if r13
              if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                r14 = true
                @index += 1
              else
                terminal_parse_failure('[Rr]')
                r14 = nil
              end
              s0 << r14
              if r14
                if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                  r15 = true
                  @index += 1
                else
                  terminal_parse_failure('[Cc]')
                  r15 = nil
                end
                s0 << r15
                if r15
                  if has_terminal?(@regexps[gr = '\A[Hh]'] ||= Regexp.new(gr), :regexp, index)
                    r16 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Hh]')
                    r16 = nil
                  end
                  s0 << r16
                  if r16
                    if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                      r17 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ee]')
                      r17 = nil
                    end
                    s0 << r17
                    if r17
                      if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                        r18 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Tt]')
                        r18 = nil
                      end
                      s0 << r18
                      if r18
                        if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                          r19 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Yy]')
                          r19 = nil
                        end
                        s0 << r19
                        if r19
                          if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                            r20 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Pp]')
                            r20 = nil
                          end
                          s0 << r20
                          if r20
                            if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                              r21 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Ee]')
                              r21 = nil
                            end
                            s0 << r21
                            if r21
                              r22 = _nt_space
                              s0 << r22
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMALLOWARCHETYPE2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ALLOW_ARCHETYPE][start_index] = r0

        r0
      end

      module SYMINCLUDE0
        def space
          elements[7]
        end
      end

      def _nt_SYM_INCLUDE
        start_index = index
        if node_cache[:SYM_INCLUDE].has_key?(index)
          cached = node_cache[:SYM_INCLUDE][index]
          if cached
            node_cache[:SYM_INCLUDE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Cc]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ll]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Uu]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Dd]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ee]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMINCLUDE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_INCLUDE][start_index] = r0

        r0
      end

      module SYMEXCLUDE0
        def space
          elements[7]
        end
      end

      def _nt_SYM_EXCLUDE
        start_index = index
        if node_cache[:SYM_EXCLUDE].has_key?(index)
          cached = node_cache[:SYM_EXCLUDE][index]
          if cached
            node_cache[:SYM_EXCLUDE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ee]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Xx]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Xx]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Cc]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ll]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Uu]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Dd]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ee]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMEXCLUDE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_EXCLUDE][start_index] = r0

        r0
      end

      module SYMTEMPLATECOMPONENT0
        def space
          elements[18]
        end
      end

      def _nt_SYM_TEMPLATE_COMPONENT
        start_index = index
        if node_cache[:SYM_TEMPLATE_COMPONENT].has_key?(index)
          cached = node_cache[:SYM_TEMPLATE_COMPONENT][index]
          if cached
            node_cache[:SYM_TEMPLATE_COMPONENT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Tt]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ee]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Mm]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Pp]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ll]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?(' _', false, index))
                          r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                          @index += match_len
                        else
                          terminal_parse_failure(' _')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Cc]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Oo]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
                                r12 = true
                                @index += 1
                              else
                                terminal_parse_failure('[Mm]')
                                r12 = nil
                              end
                              s0 << r12
                              if r12
                                if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                                  r13 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[Pp]')
                                  r13 = nil
                                end
                                s0 << r13
                                if r13
                                  if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                                    r14 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[Oo]')
                                    r14 = nil
                                  end
                                  s0 << r14
                                  if r14
                                    if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                                      r15 = true
                                      @index += 1
                                    else
                                      terminal_parse_failure('[Nn]')
                                      r15 = nil
                                    end
                                    s0 << r15
                                    if r15
                                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                                        r16 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[Ee]')
                                        r16 = nil
                                      end
                                      s0 << r16
                                      if r16
                                        if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                                          r17 = true
                                          @index += 1
                                        else
                                          terminal_parse_failure('[Nn]')
                                          r17 = nil
                                        end
                                        s0 << r17
                                        if r17
                                          if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                                            r18 = true
                                            @index += 1
                                          else
                                            terminal_parse_failure('[Tt]')
                                            r18 = nil
                                          end
                                          s0 << r18
                                          if r18
                                            r19 = _nt_space
                                            s0 << r19
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMTEMPLATECOMPONENT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_TEMPLATE_COMPONENT][start_index] = r0

        r0
      end

      module SYMTEMPLATE0
        def space
          elements[8]
        end
      end

      def _nt_SYM_TEMPLATE
        start_index = index
        if node_cache[:SYM_TEMPLATE].has_key?(index)
          cached = node_cache[:SYM_TEMPLATE][index]
          if cached
            node_cache[:SYM_TEMPLATE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Tt]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ee]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Mm]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Pp]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ll]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMTEMPLATE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_TEMPLATE][start_index] = r0

        r0
      end

      module SYMOPERATIONALTEMPLATE0
        def space
          elements[20]
        end
      end

      def _nt_SYM_OPERATIONAL_TEMPLATE
        start_index = index
        if node_cache[:SYM_OPERATIONAL_TEMPLATE].has_key?(index)
          cached = node_cache[:SYM_OPERATIONAL_TEMPLATE][index]
          if cached
            node_cache[:SYM_OPERATIONAL_TEMPLATE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Oo]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Pp]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ee]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Rr]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Aa]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Tt]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ii]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Oo]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Nn]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Aa]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Ll]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              if (match_len = has_terminal?('_', false, index))
                                r12 = true
                                @index += match_len
                              else
                                terminal_parse_failure('_')
                                r12 = nil
                              end
                              s0 << r12
                              if r12
                                if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                                  r13 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[Tt]')
                                  r13 = nil
                                end
                                s0 << r13
                                if r13
                                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                                    r14 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[Ee]')
                                    r14 = nil
                                  end
                                  s0 << r14
                                  if r14
                                    if has_terminal?(@regexps[gr = '\A[Mm]'] ||= Regexp.new(gr), :regexp, index)
                                      r15 = true
                                      @index += 1
                                    else
                                      terminal_parse_failure('[Mm]')
                                      r15 = nil
                                    end
                                    s0 << r15
                                    if r15
                                      if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                                        r16 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[Pp]')
                                        r16 = nil
                                      end
                                      s0 << r16
                                      if r16
                                        if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                                          r17 = true
                                          @index += 1
                                        else
                                          terminal_parse_failure('[Ll]')
                                          r17 = nil
                                        end
                                        s0 << r17
                                        if r17
                                          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                                            r18 = true
                                            @index += 1
                                          else
                                            terminal_parse_failure('[Aa]')
                                            r18 = nil
                                          end
                                          s0 << r18
                                          if r18
                                            if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                                              r19 = true
                                              @index += 1
                                            else
                                              terminal_parse_failure('[Tt]')
                                              r19 = nil
                                            end
                                            s0 << r19
                                            if r19
                                              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                                                r20 = true
                                                @index += 1
                                              else
                                                terminal_parse_failure('[Ee]')
                                                r20 = nil
                                              end
                                              s0 << r20
                                              if r20
                                                r21 = _nt_space
                                                s0 << r21
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMOPERATIONALTEMPLATE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_OPERATIONAL_TEMPLATE][start_index] = r0

        r0
      end

      module SYMADLVERSION0
        def space
          elements[11]
        end
      end

      def _nt_SYM_ADL_VERSION
        start_index = index
        if node_cache[:SYM_ADL_VERSION].has_key?(index)
          cached = node_cache[:SYM_ADL_VERSION][index]
          if cached
            node_cache[:SYM_ADL_VERSION][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Aa]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Dd]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ll]')
              r3 = nil
            end
            s0 << r3
            if r3
              if (match_len = has_terminal?('_', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('_')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Vv]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Vv]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ee]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Rr]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ss]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ii]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Oo]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Nn]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_space
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMADLVERSION0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ADL_VERSION][start_index] = r0

        r0
      end

      module SYMISCONTROLLED0
        def space
          elements[10]
        end
      end

      def _nt_SYM_IS_CONTROLLED
        start_index = index
        if node_cache[:SYM_IS_CONTROLLED].has_key?(index)
          cached = node_cache[:SYM_IS_CONTROLLED][index]
          if cached
            node_cache[:SYM_IS_CONTROLLED][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Cc]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Oo]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Nn]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Tt]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Oo]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ll]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ll]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ee]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Dd]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_space
                            s0 << r11
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMISCONTROLLED0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_IS_CONTROLLED][start_index] = r0

        r0
      end

      module SYMISGENERATED0
        def space
          elements[9]
        end
      end

      def _nt_SYM_IS_GENERATED
        start_index = index
        if node_cache[:SYM_IS_GENERATED].has_key?(index)
          cached = node_cache[:SYM_IS_GENERATED][index]
          if cached
            node_cache[:SYM_IS_GENERATED][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Gg]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Gg]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ee]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Nn]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ee]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Dd]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMISGENERATED0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_IS_GENERATED][start_index] = r0

        r0
      end

      module SYMSPECIALIZE0
        def space
          elements[10]
        end
      end

      def _nt_SYM_SPECIALIZE
        start_index = index
        if node_cache[:SYM_SPECIALIZE].has_key?(index)
          cached = node_cache[:SYM_SPECIALIZE][index]
          if cached
            node_cache[:SYM_SPECIALIZE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ss]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Pp]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ee]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Cc]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ii]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Ll]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ii]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[SsZz]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[SsZz]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Ee]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_space
                            s0 << r11
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMSPECIALIZE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_SPECIALIZE][start_index] = r0

        r0
      end

      module SYMCONCEPT0
        def space
          elements[7]
        end
      end

      def _nt_SYM_CONCEPT
        start_index = index
        if node_cache[:SYM_CONCEPT].has_key?(index)
          cached = node_cache[:SYM_CONCEPT][index]
          if cached
            node_cache[:SYM_CONCEPT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Cc]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Oo]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Nn]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Cc]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ee]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Pp]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_space
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMCONCEPT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_CONCEPT][start_index] = r0

        r0
      end

      module SYMLANGUAGE0
        def space
          elements[8]
        end
      end

      def _nt_SYM_LANGUAGE
        start_index = index
        if node_cache[:SYM_LANGUAGE].has_key?(index)
          cached = node_cache[:SYM_LANGUAGE][index]
          if cached
            node_cache[:SYM_LANGUAGE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ll]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Aa]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Nn]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Gg]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Gg]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Uu]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Uu]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Gg]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Gg]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ee]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMLANGUAGE0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_LANGUAGE][start_index] = r0

        r0
      end

      module SYMDESCRIPTION0
        def space
          elements[11]
        end
      end

      def _nt_SYM_DESCRIPTION
        start_index = index
        if node_cache[:SYM_DESCRIPTION].has_key?(index)
          cached = node_cache[:SYM_DESCRIPTION][index]
          if cached
            node_cache[:SYM_DESCRIPTION][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Dd]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ee]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ss]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Cc]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ii]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Pp]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Pp]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Tt]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Ii]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Oo]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Nn]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_space
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMDESCRIPTION0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_DESCRIPTION][start_index] = r0

        r0
      end

      module SYMDEFINITION0
        def space
          elements[10]
        end
      end

      def _nt_SYM_DEFINITION
        start_index = index
        if node_cache[:SYM_DEFINITION].has_key?(index)
          cached = node_cache[:SYM_DEFINITION][index]
          if cached
            node_cache[:SYM_DEFINITION][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Dd]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Ee]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Ff]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Ii]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Nn]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ii]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ii]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Oo]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Nn]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_space
                            s0 << r11
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMDEFINITION0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_DEFINITION][start_index] = r0

        r0
      end

      module SYMINVARIANT0
        def space
          elements[9]
        end
      end

      def _nt_SYM_INVARIANT
        start_index = index
        if node_cache[:SYM_INVARIANT].has_key?(index)
          cached = node_cache[:SYM_INVARIANT][index]
          if cached
            node_cache[:SYM_INVARIANT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Vv]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Vv]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Aa]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Rr]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Rr]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Ii]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Aa]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Nn]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Tt]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_space
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMINVARIANT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_INVARIANT][start_index] = r0

        r0
      end

      module SYMONTOLOGY0
        def space
          elements[8]
        end
      end

      def _nt_SYM_ONTOLOGY
        start_index = index
        if node_cache[:SYM_ONTOLOGY].has_key?(index)
          cached = node_cache[:SYM_ONTOLOGY][index]
          if cached
            node_cache[:SYM_ONTOLOGY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Oo]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Tt]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Oo]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Ll]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Ll]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Oo]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Gg]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Gg]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Yy]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Yy]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_space
                        s0 << r9
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMONTOLOGY0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ONTOLOGY][start_index] = r0

        r0
      end

      module SYMANNOTATIONS0
        def space
          elements[11]
        end
      end

      def _nt_SYM_ANNOTATIONS
        start_index = index
        if node_cache[:SYM_ANNOTATIONS].has_key?(index)
          cached = node_cache[:SYM_ANNOTATIONS][index]
          if cached
            node_cache[:SYM_ANNOTATIONS][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Aa]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[Nn]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[Nn]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[Oo]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[Tt]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[Aa]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[Tt]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[Tt]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[Ii]')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[Oo]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[Oo]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[Nn]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[Nn]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Ss]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Ss]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_space
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SYMANNOTATIONS0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:SYM_ANNOTATIONS][start_index] = r0

        r0
      end

      module VVERSIONSTRING0
      end

      module VVERSIONSTRING1
      end

      module VVERSIONSTRING2
        def value
          text_value
        end
      end

      def _nt_V_VERSION_STRING
        start_index = index
        if node_cache[:V_VERSION_STRING].has_key?(index)
          cached = node_cache[:V_VERSION_STRING][index]
          if cached
            node_cache[:V_VERSION_STRING][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('.', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('.')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
            if r4
              s6, i6 = [], index
              loop do
                i7, s7 = index, []
                if (match_len = has_terminal?('.', false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('.')
                  r8 = nil
                end
                s7 << r8
                if r8
                  s9, i9 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r10 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r10 = nil
                    end
                    if r10
                      s9 << r10
                    else
                      break
                    end
                  end
                  if s9.empty?
                    @index = i9
                    r9 = nil
                  else
                    r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                  end
                  s7 << r9
                end
                if s7.last
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                  r7.extend(VVERSIONSTRING0)
                else
                  @index = i7
                  r7 = nil
                end
                if r7
                  s6 << r7
                else
                  break
                end
              end
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              s0 << r6
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VVERSIONSTRING1)
          r0.extend(VVERSIONSTRING2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_VERSION_STRING][start_index] = r0

        r0
      end

      module VARCHETYPEID0
        def NAMESTR
          elements[1]
        end
      end

      module VARCHETYPEID1
        def NAMESTR
          elements[1]
        end
      end

      module VARCHETYPEID2
        def NAMESTR1
          elements[0]
        end

        def NAMESTR2
          elements[3]
        end

      end

      module VARCHETYPEID3
        def value
          text_value
        end
      end

      def _nt_V_ARCHETYPE_ID
        start_index = index
        if node_cache[:V_ARCHETYPE_ID].has_key?(index)
          cached = node_cache[:V_ARCHETYPE_ID][index]
          if cached
            node_cache[:V_ARCHETYPE_ID][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_NAMESTR
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?('-', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('-')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_NAMESTR
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(VARCHETYPEID0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
            if s2.size == 2
              break
            end
          end
          if s2.size < 2
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?('.', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('.')
              r6 = nil
            end
            s0 << r6
            if r6
              r7 = _nt_NAMESTR
              s0 << r7
              if r7
                s8, i8 = [], index
                loop do
                  i9, s9 = index, []
                  if (match_len = has_terminal?('-', false, index))
                    r10 = true
                    @index += match_len
                  else
                    terminal_parse_failure('-')
                    r10 = nil
                  end
                  s9 << r10
                  if r10
                    r11 = _nt_NAMESTR
                    s9 << r11
                  end
                  if s9.last
                    r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                    r9.extend(VARCHETYPEID1)
                  else
                    @index = i9
                    r9 = nil
                  end
                  if r9
                    s8 << r9
                  else
                    break
                  end
                end
                r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                s0 << r8
                if r8
                  if (match_len = has_terminal?('.v', false, index))
                    r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('.v')
                    r12 = nil
                  end
                  s0 << r12
                  if r12
                    if has_terminal?(@regexps[gr = '\A[1-9]'] ||= Regexp.new(gr), :regexp, index)
                      r13 = true
                      @index += 1
                    else
                      terminal_parse_failure('[1-9]')
                      r13 = nil
                    end
                    s0 << r13
                    if r13
                      s14, i14 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r15 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r15 = nil
                        end
                        if r15
                          s14 << r15
                        else
                          break
                        end
                      end
                      r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                      s0 << r14
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VARCHETYPEID2)
          r0.extend(VARCHETYPEID3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ARCHETYPE_ID][start_index] = r0

        r0
      end

      module VIDENTIFIER0
      end

      module VIDENTIFIER1
        def value
          text_value
        end
      end

      def _nt_V_IDENTIFIER
        start_index = index
        if node_cache[:V_IDENTIFIER].has_key?(index)
          cached = node_cache[:V_IDENTIFIER][index]
          if cached
            node_cache[:V_IDENTIFIER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[a-zA-Z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z0-9_]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VIDENTIFIER0)
          r0.extend(VIDENTIFIER1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_IDENTIFIER][start_index] = r0

        r0
      end

      module VURI0
      end

      module VURI1

        def value
          text_value
        end
      end

      def _nt_V_URI
        start_index = index
        if node_cache[:V_URI].has_key?(index)
          cached = node_cache[:V_URI][index]
          if cached
            node_cache[:V_URI][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[a-z]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[a-z]')
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('://', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('://')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[^<>|\\\\{}^~"\\[\\] ]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[^<>|\\\\{}^~"\\[\\] ]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VURI0)
          r0.extend(VURI1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_URI][start_index] = r0

        r0
      end

      module VQUALIFIEDTERMCODEREF0
        def ti
          elements[1]
        end

        def cs
          elements[3]
        end

      end

      module VQUALIFIEDTERMCODEREF1
        def value
          term_id = OpenEHR::RM::Support::Identification::TerminologyID.new(
            :value => ti.text_value)
          OpenEHR::RM::DataTypes::Text::CodePhrase.new(
            :terminology_id => term_id, :code_string => cs.text_value)
        end
      end

      def _nt_V_QUALIFIED_TERM_CODE_REF
        start_index = index
        if node_cache[:V_QUALIFIED_TERM_CODE_REF].has_key?(index)
          cached = node_cache[:V_QUALIFIED_TERM_CODE_REF][index]
          if cached
            node_cache[:V_QUALIFIED_TERM_CODE_REF][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_NAMECHAR_PAREN
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?('::', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('::')
              r4 = nil
            end
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                r6 = _nt_NAMECHAR
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
              if r5
                if (match_len = has_terminal?(']', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure(']')
                  r7 = nil
                end
                s0 << r7
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VQUALIFIEDTERMCODEREF0)
          r0.extend(VQUALIFIEDTERMCODEREF1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_QUALIFIED_TERM_CODE_REF][start_index] = r0

        r0
      end

      module ERRVQUALIFIEDTERMCODEREF0
      end

      module ERRVQUALIFIEDTERMCODEREF1
        def er
          elements[1]
        end

      end

      module ERRVQUALIFIEDTERMCODEREF2
        def value
          er.text_value
        end
      end

      def _nt_ERR_V_QUALIFIED_TERM_CODE_REF
        start_index = index
        if node_cache[:ERR_V_QUALIFIED_TERM_CODE_REF].has_key?(index)
          cached = node_cache[:ERR_V_QUALIFIED_TERM_CODE_REF][index]
          if cached
            node_cache[:ERR_V_QUALIFIED_TERM_CODE_REF][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          i2, s2 = index, []
          s3, i3 = [], index
          loop do
            r4 = _nt_NAMECHAR_PAREN
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s2 << r3
          if r3
            if (match_len = has_terminal?('::', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('::')
              r5 = nil
            end
            s2 << r5
            if r5
              s6, i6 = [], index
              loop do
                r7 = _nt_NAMECHAR_SPACE
                if r7
                  s6 << r7
                else
                  break
                end
              end
              if s6.empty?
                @index = i6
                r6 = nil
              else
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              end
              s2 << r6
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(ERRVQUALIFIEDTERMCODEREF0)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?(']', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure(']')
              r8 = nil
            end
            s0 << r8
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ERRVQUALIFIEDTERMCODEREF1)
          r0.extend(ERRVQUALIFIEDTERMCODEREF2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ERR_V_QUALIFIED_TERM_CODE_REF][start_index] = r0

        r0
      end

      module VLOCALTERMCODEREF0
        def ALPHANUM
          elements[0]
        end

      end

      module VLOCALTERMCODEREF1
        def lt
          elements[1]
        end

      end

      module VLOCALTERMCODEREF2
        def value
          lt.text_value
        end
      end

      def _nt_V_LOCAL_TERM_CODE_REF
        start_index = index
        if node_cache[:V_LOCAL_TERM_CODE_REF].has_key?(index)
          cached = node_cache[:V_LOCAL_TERM_CODE_REF][index]
          if cached
            node_cache[:V_LOCAL_TERM_CODE_REF][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          i2, s2 = index, []
          r3 = _nt_ALPHANUM
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              r5 = _nt_NAMECHAR
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(VLOCALTERMCODEREF0)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?(']', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure(']')
              r6 = nil
            end
            s0 << r6
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VLOCALTERMCODEREF1)
          r0.extend(VLOCALTERMCODEREF2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_LOCAL_TERM_CODE_REF][start_index] = r0

        r0
      end

      module VLOCALCODE0
      end

      module VLOCALCODE1
        def value
          text_value
        end
      end

      def _nt_V_LOCAL_CODE
        start_index = index
        if node_cache[:V_LOCAL_CODE].has_key?(index)
          cached = node_cache[:V_LOCAL_CODE][index]
          if cached
            node_cache[:V_LOCAL_CODE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('a', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('a')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[ct]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[ct]')
            r2 = nil
          end
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9\\.]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[0-9\\.]')
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            if s3.empty?
              @index = i3
              r3 = nil
            else
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VLOCALCODE0)
          r0.extend(VLOCALCODE1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_LOCAL_CODE][start_index] = r0

        r0
      end

      module VTERMCODE0
        def code
          elements[1]
        end

        def white_space
          elements[3]
        end
      end

      module VTERMCODE1
        def value
          ::OpenEHR::RM::Support::Identification::TerminologyID.new(
            :value => code.text_value)
        end
      end

      def _nt_V_TERM_CODE
        start_index = index
        if node_cache[:V_TERM_CODE].has_key?(index)
          cached = node_cache[:V_TERM_CODE][index]
          if cached
            node_cache[:V_TERM_CODE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9()._\\-]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[a-zA-Z0-9()._\\-]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?('::', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('::')
              r4 = nil
            end
            s0 << r4
            if r4
              r5 = _nt_white_space
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VTERMCODE0)
          r0.extend(VTERMCODE1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_TERM_CODE][start_index] = r0

        r0
      end

      module VISO8601EXTENDEDDATETIME0
      end

      module VISO8601EXTENDEDDATETIME1
      end

      module VISO8601EXTENDEDDATETIME2
      end

      module VISO8601EXTENDEDDATETIME3
      end

      module VISO8601EXTENDEDDATETIME4
      end

      module VISO8601EXTENDEDDATETIME5
      end

      module VISO8601EXTENDEDDATETIME6
      end

      def _nt_V_ISO8601_EXTENDED_DATE_TIME
        start_index = index
        if node_cache[:V_ISO8601_EXTENDED_DATE_TIME].has_key?(index)
          cached = node_cache[:V_ISO8601_EXTENDED_DATE_TIME][index]
          if cached
            node_cache[:V_ISO8601_EXTENDED_DATE_TIME][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
          if s2.size == 4
            break
          end
        end
        if s2.size < 4
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if (match_len = has_terminal?('-', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('-')
            r4 = nil
          end
          s1 << r4
          if r4
            if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[0-1]')
              r5 = nil
            end
            s1 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r6 = nil
              end
              s1 << r6
              if r6
                if (match_len = has_terminal?('-', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('-')
                  r7 = nil
                end
                s1 << r7
                if r7
                  if has_terminal?(@regexps[gr = '\A[0-3]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-3]')
                    r8 = nil
                  end
                  s1 << r8
                  if r8
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r9 = nil
                    end
                    s1 << r9
                    if r9
                      if (match_len = has_terminal?('T', false, index))
                        r10 = true
                        @index += match_len
                      else
                        terminal_parse_failure('T')
                        r10 = nil
                      end
                      s1 << r10
                      if r10
                        if has_terminal?(@regexps[gr = '\A[0-2]'] ||= Regexp.new(gr), :regexp, index)
                          r11 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-2]')
                          r11 = nil
                        end
                        s1 << r11
                        if r11
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r12 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r12 = nil
                          end
                          s1 << r12
                          if r12
                            if (match_len = has_terminal?(':', false, index))
                              r13 = true
                              @index += match_len
                            else
                              terminal_parse_failure(':')
                              r13 = nil
                            end
                            s1 << r13
                            if r13
                              if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                                r14 = true
                                @index += 1
                              else
                                terminal_parse_failure('[0-6]')
                                r14 = nil
                              end
                              s1 << r14
                              if r14
                                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                  r15 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[0-9]')
                                  r15 = nil
                                end
                                s1 << r15
                                if r15
                                  if (match_len = has_terminal?(':', false, index))
                                    r16 = true
                                    @index += match_len
                                  else
                                    terminal_parse_failure(':')
                                    r16 = nil
                                  end
                                  s1 << r16
                                  if r16
                                    if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                                      r17 = true
                                      @index += 1
                                    else
                                      terminal_parse_failure('[0-6]')
                                      r17 = nil
                                    end
                                    s1 << r17
                                    if r17
                                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                        r18 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[0-9]')
                                        r18 = nil
                                      end
                                      s1 << r18
                                      if r18
                                        i20, s20 = index, []
                                        if (match_len = has_terminal?(',', false, index))
                                          r21 = true
                                          @index += match_len
                                        else
                                          terminal_parse_failure(',')
                                          r21 = nil
                                        end
                                        s20 << r21
                                        if r21
                                          s22, i22 = [], index
                                          loop do
                                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                              r23 = true
                                              @index += 1
                                            else
                                              terminal_parse_failure('[0-9]')
                                              r23 = nil
                                            end
                                            if r23
                                              s22 << r23
                                            else
                                              break
                                            end
                                          end
                                          if s22.empty?
                                            @index = i22
                                            r22 = nil
                                          else
                                            r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                                          end
                                          s20 << r22
                                        end
                                        if s20.last
                                          r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                                          r20.extend(VISO8601EXTENDEDDATETIME0)
                                        else
                                          @index = i20
                                          r20 = nil
                                        end
                                        if r20
                                          r19 = r20
                                        else
                                          r19 = instantiate_node(SyntaxNode,input, index...index)
                                        end
                                        s1 << r19
                                        if r19
                                          i25 = index
                                          if (match_len = has_terminal?('Z', false, index))
                                            r26 = true
                                            @index += match_len
                                          else
                                            terminal_parse_failure('Z')
                                            r26 = nil
                                          end
                                          if r26
                                            r26 = SyntaxNode.new(input, (index-1)...index) if r26 == true
                                            r25 = r26
                                          else
                                            i27, s27 = index, []
                                            if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                                              r28 = true
                                              @index += 1
                                            else
                                              terminal_parse_failure('[+-]')
                                              r28 = nil
                                            end
                                            s27 << r28
                                            if r28
                                              s29, i29 = [], index
                                              loop do
                                                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                                  r30 = true
                                                  @index += 1
                                                else
                                                  terminal_parse_failure('[0-9]')
                                                  r30 = nil
                                                end
                                                if r30
                                                  s29 << r30
                                                else
                                                  break
                                                end
                                                if s29.size == 4
                                                  break
                                                end
                                              end
                                              if s29.size < 4
                                                @index = i29
                                                r29 = nil
                                              else
                                                r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                                              end
                                              s27 << r29
                                            end
                                            if s27.last
                                              r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                                              r27.extend(VISO8601EXTENDEDDATETIME1)
                                            else
                                              @index = i27
                                              r27 = nil
                                            end
                                            if r27
                                              r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                                              r25 = r27
                                            else
                                              @index = i25
                                              r25 = nil
                                            end
                                          end
                                          if r25
                                            r24 = r25
                                          else
                                            r24 = instantiate_node(SyntaxNode,input, index...index)
                                          end
                                          s1 << r24
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VISO8601EXTENDEDDATETIME2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i31, s31 = index, []
          s32, i32 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r33 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r33 = nil
            end
            if r33
              s32 << r33
            else
              break
            end
            if s32.size == 4
              break
            end
          end
          if s32.size < 4
            @index = i32
            r32 = nil
          else
            r32 = instantiate_node(SyntaxNode,input, i32...index, s32)
          end
          s31 << r32
          if r32
            if (match_len = has_terminal?('-', false, index))
              r34 = true
              @index += match_len
            else
              terminal_parse_failure('-')
              r34 = nil
            end
            s31 << r34
            if r34
              if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
                r35 = true
                @index += 1
              else
                terminal_parse_failure('[0-1]')
                r35 = nil
              end
              s31 << r35
              if r35
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r36 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r36 = nil
                end
                s31 << r36
                if r36
                  if (match_len = has_terminal?('-', false, index))
                    r37 = true
                    @index += match_len
                  else
                    terminal_parse_failure('-')
                    r37 = nil
                  end
                  s31 << r37
                  if r37
                    if has_terminal?(@regexps[gr = '\A[0-3]'] ||= Regexp.new(gr), :regexp, index)
                      r38 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-3]')
                      r38 = nil
                    end
                    s31 << r38
                    if r38
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r39 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r39 = nil
                      end
                      s31 << r39
                      if r39
                        if (match_len = has_terminal?('T', false, index))
                          r40 = true
                          @index += match_len
                        else
                          terminal_parse_failure('T')
                          r40 = nil
                        end
                        s31 << r40
                        if r40
                          if has_terminal?(@regexps[gr = '\A[0-2]'] ||= Regexp.new(gr), :regexp, index)
                            r41 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-2]')
                            r41 = nil
                          end
                          s31 << r41
                          if r41
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r42 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r42 = nil
                            end
                            s31 << r42
                            if r42
                              if (match_len = has_terminal?(':', false, index))
                                r43 = true
                                @index += match_len
                              else
                                terminal_parse_failure(':')
                                r43 = nil
                              end
                              s31 << r43
                              if r43
                                if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                                  r44 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[0-6]')
                                  r44 = nil
                                end
                                s31 << r44
                                if r44
                                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                    r45 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[0-9]')
                                    r45 = nil
                                  end
                                  s31 << r45
                                  if r45
                                    i47 = index
                                    if (match_len = has_terminal?('Z', false, index))
                                      r48 = true
                                      @index += match_len
                                    else
                                      terminal_parse_failure('Z')
                                      r48 = nil
                                    end
                                    if r48
                                      r48 = SyntaxNode.new(input, (index-1)...index) if r48 == true
                                      r47 = r48
                                    else
                                      i49, s49 = index, []
                                      if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                                        r50 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[+-]')
                                        r50 = nil
                                      end
                                      s49 << r50
                                      if r50
                                        s51, i51 = [], index
                                        loop do
                                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                            r52 = true
                                            @index += 1
                                          else
                                            terminal_parse_failure('[0-9]')
                                            r52 = nil
                                          end
                                          if r52
                                            s51 << r52
                                          else
                                            break
                                          end
                                          if s51.size == 4
                                            break
                                          end
                                        end
                                        if s51.size < 4
                                          @index = i51
                                          r51 = nil
                                        else
                                          r51 = instantiate_node(SyntaxNode,input, i51...index, s51)
                                        end
                                        s49 << r51
                                      end
                                      if s49.last
                                        r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                                        r49.extend(VISO8601EXTENDEDDATETIME3)
                                      else
                                        @index = i49
                                        r49 = nil
                                      end
                                      if r49
                                        r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                                        r47 = r49
                                      else
                                        @index = i47
                                        r47 = nil
                                      end
                                    end
                                    if r47
                                      r46 = r47
                                    else
                                      r46 = instantiate_node(SyntaxNode,input, index...index)
                                    end
                                    s31 << r46
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s31.last
            r31 = instantiate_node(SyntaxNode,input, i31...index, s31)
            r31.extend(VISO8601EXTENDEDDATETIME4)
          else
            @index = i31
            r31 = nil
          end
          if r31
            r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
            r0 = r31
          else
            i53, s53 = index, []
            s54, i54 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r55 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r55 = nil
              end
              if r55
                s54 << r55
              else
                break
              end
              if s54.size == 4
                break
              end
            end
            if s54.size < 4
              @index = i54
              r54 = nil
            else
              r54 = instantiate_node(SyntaxNode,input, i54...index, s54)
            end
            s53 << r54
            if r54
              if (match_len = has_terminal?('-', false, index))
                r56 = true
                @index += match_len
              else
                terminal_parse_failure('-')
                r56 = nil
              end
              s53 << r56
              if r56
                if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
                  r57 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-1]')
                  r57 = nil
                end
                s53 << r57
                if r57
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r58 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r58 = nil
                  end
                  s53 << r58
                  if r58
                    if (match_len = has_terminal?('-', false, index))
                      r59 = true
                      @index += match_len
                    else
                      terminal_parse_failure('-')
                      r59 = nil
                    end
                    s53 << r59
                    if r59
                      if has_terminal?(@regexps[gr = '\A[0-3]'] ||= Regexp.new(gr), :regexp, index)
                        r60 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-3]')
                        r60 = nil
                      end
                      s53 << r60
                      if r60
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r61 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r61 = nil
                        end
                        s53 << r61
                        if r61
                          if (match_len = has_terminal?('T', false, index))
                            r62 = true
                            @index += match_len
                          else
                            terminal_parse_failure('T')
                            r62 = nil
                          end
                          s53 << r62
                          if r62
                            if has_terminal?(@regexps[gr = '\A[0-2]'] ||= Regexp.new(gr), :regexp, index)
                              r63 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-2]')
                              r63 = nil
                            end
                            s53 << r63
                            if r63
                              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                r64 = true
                                @index += 1
                              else
                                terminal_parse_failure('[0-9]')
                                r64 = nil
                              end
                              s53 << r64
                              if r64
                                i66 = index
                                if (match_len = has_terminal?('Z', false, index))
                                  r67 = true
                                  @index += match_len
                                else
                                  terminal_parse_failure('Z')
                                  r67 = nil
                                end
                                if r67
                                  r67 = SyntaxNode.new(input, (index-1)...index) if r67 == true
                                  r66 = r67
                                else
                                  i68, s68 = index, []
                                  if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                                    r69 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[+-]')
                                    r69 = nil
                                  end
                                  s68 << r69
                                  if r69
                                    s70, i70 = [], index
                                    loop do
                                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                        r71 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[0-9]')
                                        r71 = nil
                                      end
                                      if r71
                                        s70 << r71
                                      else
                                        break
                                      end
                                      if s70.size == 4
                                        break
                                      end
                                    end
                                    if s70.size < 4
                                      @index = i70
                                      r70 = nil
                                    else
                                      r70 = instantiate_node(SyntaxNode,input, i70...index, s70)
                                    end
                                    s68 << r70
                                  end
                                  if s68.last
                                    r68 = instantiate_node(SyntaxNode,input, i68...index, s68)
                                    r68.extend(VISO8601EXTENDEDDATETIME5)
                                  else
                                    @index = i68
                                    r68 = nil
                                  end
                                  if r68
                                    r68 = SyntaxNode.new(input, (index-1)...index) if r68 == true
                                    r66 = r68
                                  else
                                    @index = i66
                                    r66 = nil
                                  end
                                end
                                if r66
                                  r65 = r66
                                else
                                  r65 = instantiate_node(SyntaxNode,input, index...index)
                                end
                                s53 << r65
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s53.last
              r53 = instantiate_node(SyntaxNode,input, i53...index, s53)
              r53.extend(VISO8601EXTENDEDDATETIME6)
            else
              @index = i53
              r53 = nil
            end
            if r53
              r53 = SyntaxNode.new(input, (index-1)...index) if r53 == true
              r0 = r53
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:V_ISO8601_EXTENDED_DATE_TIME][start_index] = r0

        r0
      end

      module VISO8601EXTENDEDTIME0
      end

      module VISO8601EXTENDEDTIME1
      end

      module VISO8601EXTENDEDTIME2
      end

      module VISO8601EXTENDEDTIME3
      end

      module VISO8601EXTENDEDTIME4
      end

      def _nt_V_ISO8601_EXTENDED_TIME
        start_index = index
        if node_cache[:V_ISO8601_EXTENDED_TIME].has_key?(index)
          cached = node_cache[:V_ISO8601_EXTENDED_TIME][index]
          if cached
            node_cache[:V_ISO8601_EXTENDED_TIME][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if has_terminal?(@regexps[gr = '\A[0-2]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[0-2]')
          r2 = nil
        end
        s1 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r3 = nil
          end
          s1 << r3
          if r3
            if (match_len = has_terminal?(':', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure(':')
              r4 = nil
            end
            s1 << r4
            if r4
              if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[0-6]')
                r5 = nil
              end
              s1 << r5
              if r5
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r6 = nil
                end
                s1 << r6
                if r6
                  if (match_len = has_terminal?(':', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure(':')
                    r7 = nil
                  end
                  s1 << r7
                  if r7
                    if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                      r8 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-6]')
                      r8 = nil
                    end
                    s1 << r8
                    if r8
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r9 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r9 = nil
                      end
                      s1 << r9
                      if r9
                        i11, s11 = index, []
                        if (match_len = has_terminal?(',', false, index))
                          r12 = true
                          @index += match_len
                        else
                          terminal_parse_failure(',')
                          r12 = nil
                        end
                        s11 << r12
                        if r12
                          s13, i13 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r14 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r14 = nil
                            end
                            if r14
                              s13 << r14
                            else
                              break
                            end
                          end
                          if s13.empty?
                            @index = i13
                            r13 = nil
                          else
                            r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                          end
                          s11 << r13
                        end
                        if s11.last
                          r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                          r11.extend(VISO8601EXTENDEDTIME0)
                        else
                          @index = i11
                          r11 = nil
                        end
                        if r11
                          r10 = r11
                        else
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s1 << r10
                        if r10
                          i16 = index
                          if (match_len = has_terminal?('Z', false, index))
                            r17 = true
                            @index += match_len
                          else
                            terminal_parse_failure('Z')
                            r17 = nil
                          end
                          if r17
                            r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                            r16 = r17
                          else
                            i18, s18 = index, []
                            if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                              r19 = true
                              @index += 1
                            else
                              terminal_parse_failure('[+-]')
                              r19 = nil
                            end
                            s18 << r19
                            if r19
                              s20, i20 = [], index
                              loop do
                                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                  r21 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[0-9]')
                                  r21 = nil
                                end
                                if r21
                                  s20 << r21
                                else
                                  break
                                end
                                if s20.size == 4
                                  break
                                end
                              end
                              if s20.size < 4
                                @index = i20
                                r20 = nil
                              else
                                r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                              end
                              s18 << r20
                            end
                            if s18.last
                              r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                              r18.extend(VISO8601EXTENDEDTIME1)
                            else
                              @index = i18
                              r18 = nil
                            end
                            if r18
                              r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
                              r16 = r18
                            else
                              @index = i16
                              r16 = nil
                            end
                          end
                          if r16
                            r15 = r16
                          else
                            r15 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s1 << r15
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VISO8601EXTENDEDTIME2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i22, s22 = index, []
          if has_terminal?(@regexps[gr = '\A[0-2]'] ||= Regexp.new(gr), :regexp, index)
            r23 = true
            @index += 1
          else
            terminal_parse_failure('[0-2]')
            r23 = nil
          end
          s22 << r23
          if r23
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r24 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r24 = nil
            end
            s22 << r24
            if r24
              if (match_len = has_terminal?(':', false, index))
                r25 = true
                @index += match_len
              else
                terminal_parse_failure(':')
                r25 = nil
              end
              s22 << r25
              if r25
                if has_terminal?(@regexps[gr = '\A[0-6]'] ||= Regexp.new(gr), :regexp, index)
                  r26 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-6]')
                  r26 = nil
                end
                s22 << r26
                if r26
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r27 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r27 = nil
                  end
                  s22 << r27
                  if r27
                    i29 = index
                    if (match_len = has_terminal?('Z', false, index))
                      r30 = true
                      @index += match_len
                    else
                      terminal_parse_failure('Z')
                      r30 = nil
                    end
                    if r30
                      r30 = SyntaxNode.new(input, (index-1)...index) if r30 == true
                      r29 = r30
                    else
                      i31, s31 = index, []
                      if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                        r32 = true
                        @index += 1
                      else
                        terminal_parse_failure('[+-]')
                        r32 = nil
                      end
                      s31 << r32
                      if r32
                        s33, i33 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r34 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r34 = nil
                          end
                          if r34
                            s33 << r34
                          else
                            break
                          end
                          if s33.size == 4
                            break
                          end
                        end
                        if s33.size < 4
                          @index = i33
                          r33 = nil
                        else
                          r33 = instantiate_node(SyntaxNode,input, i33...index, s33)
                        end
                        s31 << r33
                      end
                      if s31.last
                        r31 = instantiate_node(SyntaxNode,input, i31...index, s31)
                        r31.extend(VISO8601EXTENDEDTIME3)
                      else
                        @index = i31
                        r31 = nil
                      end
                      if r31
                        r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
                        r29 = r31
                      else
                        @index = i29
                        r29 = nil
                      end
                    end
                    if r29
                      r28 = r29
                    else
                      r28 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s22 << r28
                  end
                end
              end
            end
          end
          if s22.last
            r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
            r22.extend(VISO8601EXTENDEDTIME4)
          else
            @index = i22
            r22 = nil
          end
          if r22
            r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
            r0 = r22
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:V_ISO8601_EXTENDED_TIME][start_index] = r0

        r0
      end

      module VISO8601EXTENDEDDATE0
      end

      module VISO8601EXTENDEDDATE1
      end

      def _nt_V_ISO8601_EXTENDED_DATE
        start_index = index
        if node_cache[:V_ISO8601_EXTENDED_DATE].has_key?(index)
          cached = node_cache[:V_ISO8601_EXTENDED_DATE][index]
          if cached
            node_cache[:V_ISO8601_EXTENDED_DATE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
          if s2.size == 4
            break
          end
        end
        if s2.size < 4
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if (match_len = has_terminal?('-', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('-')
            r4 = nil
          end
          s1 << r4
          if r4
            if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
              r5 = true
              @index += 1
            else
              terminal_parse_failure('[0-1]')
              r5 = nil
            end
            s1 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r6 = nil
              end
              s1 << r6
              if r6
                if (match_len = has_terminal?('-', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('-')
                  r7 = nil
                end
                s1 << r7
                if r7
                  if has_terminal?(@regexps[gr = '\A[0-3]'] ||= Regexp.new(gr), :regexp, index)
                    r8 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-3]')
                    r8 = nil
                  end
                  s1 << r8
                  if r8
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r9 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r9 = nil
                    end
                    s1 << r9
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VISO8601EXTENDEDDATE0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i10, s10 = index, []
          s11, i11 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r12 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r12 = nil
            end
            if r12
              s11 << r12
            else
              break
            end
            if s11.size == 4
              break
            end
          end
          if s11.size < 4
            @index = i11
            r11 = nil
          else
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
          end
          s10 << r11
          if r11
            if (match_len = has_terminal?('-', false, index))
              r13 = true
              @index += match_len
            else
              terminal_parse_failure('-')
              r13 = nil
            end
            s10 << r13
            if r13
              if has_terminal?(@regexps[gr = '\A[0-1]'] ||= Regexp.new(gr), :regexp, index)
                r14 = true
                @index += 1
              else
                terminal_parse_failure('[0-1]')
                r14 = nil
              end
              s10 << r14
              if r14
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r15 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r15 = nil
                end
                s10 << r15
              end
            end
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(VISO8601EXTENDEDDATE1)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:V_ISO8601_EXTENDED_DATE][start_index] = r0

        r0
      end

      module VISO8601DURATION0
      end

      module VISO8601DURATION1
      end

      module VISO8601DURATION2
      end

      module VISO8601DURATION3
      end

      module VISO8601DURATION4
      end

      module VISO8601DURATION5
      end

      module VISO8601DURATION6
      end

      module VISO8601DURATION7
      end

      module VISO8601DURATION8
      end

      module VISO8601DURATION9
      end

      module VISO8601DURATION10
      end

      module VISO8601DURATION11
      end

      module VISO8601DURATION12
      end

      module VISO8601DURATION13
      end

      module VISO8601DURATION14
      end

      module VISO8601DURATION15
      end

      module VISO8601DURATION16
      end

      module VISO8601DURATION17
      end

      module VISO8601DURATION18
      end

      module VISO8601DURATION19
      end

      module VISO8601DURATION20
      end

      module VISO8601DURATION21
      end

      module VISO8601DURATION22
      end

      module VISO8601DURATION23
      end

      module VISO8601DURATION24
      end

      module VISO8601DURATION25
      end

      module VISO8601DURATION26
      end

      module VISO8601DURATION27
      end

      module VISO8601DURATION28
      end

      module VISO8601DURATION29
      end

      module VISO8601DURATION30
      end

      module VISO8601DURATION31
      end

      module VISO8601DURATION32
      end

      module VISO8601DURATION33
      end

      module VISO8601DURATION34
      end

      module VISO8601DURATION35
      end

      module VISO8601DURATION36
      end

      module VISO8601DURATION37
      end

      module VISO8601DURATION38
      end

      module VISO8601DURATION39
      end

      module VISO8601DURATION40
      end

      module VISO8601DURATION41
      end

      module VISO8601DURATION42
      end

      module VISO8601DURATION43
      end

      module VISO8601DURATION44
      end

      module VISO8601DURATION45
      end

      module VISO8601DURATION46
      end

      def _nt_V_ISO8601_DURATION
        start_index = index
        if node_cache[:V_ISO8601_DURATION].has_key?(index)
          cached = node_cache[:V_ISO8601_DURATION][index]
          if cached
            node_cache[:V_ISO8601_DURATION][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('P', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('P')
          r2 = nil
        end
        s1 << r2
        if r2
          i4, s4 = index, []
          s5, i5 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r6 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          if s5.empty?
            @index = i5
            r5 = nil
          else
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          end
          s4 << r5
          if r5
            if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
              r7 = true
              @index += 1
            else
              terminal_parse_failure('[yY]')
              r7 = nil
            end
            s4 << r7
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(VISO8601DURATION0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r3
          if r3
            i9, s9 = index, []
            s10, i10 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r11 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r11 = nil
              end
              if r11
                s10 << r11
              else
                break
              end
            end
            if s10.empty?
              @index = i10
              r10 = nil
            else
              r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            end
            s9 << r10
            if r10
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r12 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r12 = nil
              end
              s9 << r12
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(VISO8601DURATION1)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r8 = r9
            else
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r8
            if r8
              i14, s14 = index, []
              s15, i15 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r16 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r16 = nil
                end
                if r16
                  s15 << r16
                else
                  break
                end
              end
              if s15.empty?
                @index = i15
                r15 = nil
              else
                r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
              end
              s14 << r15
              if r15
                if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                  r17 = true
                  @index += 1
                else
                  terminal_parse_failure('[wW]')
                  r17 = nil
                end
                s14 << r17
              end
              if s14.last
                r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                r14.extend(VISO8601DURATION2)
              else
                @index = i14
                r14 = nil
              end
              if r14
                r13 = r14
              else
                r13 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r13
              if r13
                i19, s19 = index, []
                s20, i20 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r21 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r21 = nil
                  end
                  if r21
                    s20 << r21
                  else
                    break
                  end
                end
                if s20.empty?
                  @index = i20
                  r20 = nil
                else
                  r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                end
                s19 << r20
                if r20
                  if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                    r22 = true
                    @index += 1
                  else
                    terminal_parse_failure('[dD]')
                    r22 = nil
                  end
                  s19 << r22
                end
                if s19.last
                  r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                  r19.extend(VISO8601DURATION3)
                else
                  @index = i19
                  r19 = nil
                end
                if r19
                  r18 = r19
                else
                  r18 = instantiate_node(SyntaxNode,input, index...index)
                end
                s1 << r18
                if r18
                  if (match_len = has_terminal?('T', false, index))
                    r23 = true
                    @index += match_len
                  else
                    terminal_parse_failure('T')
                    r23 = nil
                  end
                  s1 << r23
                  if r23
                    i24, s24 = index, []
                    s25, i25 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r26 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r26 = nil
                      end
                      if r26
                        s25 << r26
                      else
                        break
                      end
                    end
                    if s25.empty?
                      @index = i25
                      r25 = nil
                    else
                      r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                    end
                    s24 << r25
                    if r25
                      if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                        r27 = true
                        @index += 1
                      else
                        terminal_parse_failure('[hH]')
                        r27 = nil
                      end
                      s24 << r27
                    end
                    if s24.last
                      r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                      r24.extend(VISO8601DURATION4)
                    else
                      @index = i24
                      r24 = nil
                    end
                    s1 << r24
                    if r24
                      i29, s29 = index, []
                      s30, i30 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r31 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r31 = nil
                        end
                        if r31
                          s30 << r31
                        else
                          break
                        end
                      end
                      if s30.empty?
                        @index = i30
                        r30 = nil
                      else
                        r30 = instantiate_node(SyntaxNode,input, i30...index, s30)
                      end
                      s29 << r30
                      if r30
                        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                          r32 = true
                          @index += 1
                        else
                          terminal_parse_failure('[mM]')
                          r32 = nil
                        end
                        s29 << r32
                      end
                      if s29.last
                        r29 = instantiate_node(SyntaxNode,input, i29...index, s29)
                        r29.extend(VISO8601DURATION5)
                      else
                        @index = i29
                        r29 = nil
                      end
                      if r29
                        r28 = r29
                      else
                        r28 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s1 << r28
                      if r28
                        i34, s34 = index, []
                        s35, i35 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r36 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r36 = nil
                          end
                          if r36
                            s35 << r36
                          else
                            break
                          end
                        end
                        if s35.empty?
                          @index = i35
                          r35 = nil
                        else
                          r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                        end
                        s34 << r35
                        if r35
                          i38, s38 = index, []
                          if (match_len = has_terminal?('.', false, index))
                            r39 = true
                            @index += match_len
                          else
                            terminal_parse_failure('.')
                            r39 = nil
                          end
                          s38 << r39
                          if r39
                            s40, i40 = [], index
                            loop do
                              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                r41 = true
                                @index += 1
                              else
                                terminal_parse_failure('[0-9]')
                                r41 = nil
                              end
                              if r41
                                s40 << r41
                              else
                                break
                              end
                            end
                            if s40.empty?
                              @index = i40
                              r40 = nil
                            else
                              r40 = instantiate_node(SyntaxNode,input, i40...index, s40)
                            end
                            s38 << r40
                          end
                          if s38.last
                            r38 = instantiate_node(SyntaxNode,input, i38...index, s38)
                            r38.extend(VISO8601DURATION6)
                          else
                            @index = i38
                            r38 = nil
                          end
                          if r38
                            r37 = r38
                          else
                            r37 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s34 << r37
                          if r37
                            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                              r42 = true
                              @index += 1
                            else
                              terminal_parse_failure('[sS]')
                              r42 = nil
                            end
                            s34 << r42
                          end
                        end
                        if s34.last
                          r34 = instantiate_node(SyntaxNode,input, i34...index, s34)
                          r34.extend(VISO8601DURATION7)
                        else
                          @index = i34
                          r34 = nil
                        end
                        if r34
                          r33 = r34
                        else
                          r33 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s1 << r33
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VISO8601DURATION8)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i43, s43 = index, []
          if (match_len = has_terminal?('P', false, index))
            r44 = true
            @index += match_len
          else
            terminal_parse_failure('P')
            r44 = nil
          end
          s43 << r44
          if r44
            i46, s46 = index, []
            s47, i47 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r48 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r48 = nil
              end
              if r48
                s47 << r48
              else
                break
              end
            end
            if s47.empty?
              @index = i47
              r47 = nil
            else
              r47 = instantiate_node(SyntaxNode,input, i47...index, s47)
            end
            s46 << r47
            if r47
              if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                r49 = true
                @index += 1
              else
                terminal_parse_failure('[yY]')
                r49 = nil
              end
              s46 << r49
            end
            if s46.last
              r46 = instantiate_node(SyntaxNode,input, i46...index, s46)
              r46.extend(VISO8601DURATION9)
            else
              @index = i46
              r46 = nil
            end
            if r46
              r45 = r46
            else
              r45 = instantiate_node(SyntaxNode,input, index...index)
            end
            s43 << r45
            if r45
              i51, s51 = index, []
              s52, i52 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r53 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r53 = nil
                end
                if r53
                  s52 << r53
                else
                  break
                end
              end
              if s52.empty?
                @index = i52
                r52 = nil
              else
                r52 = instantiate_node(SyntaxNode,input, i52...index, s52)
              end
              s51 << r52
              if r52
                if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                  r54 = true
                  @index += 1
                else
                  terminal_parse_failure('[mM]')
                  r54 = nil
                end
                s51 << r54
              end
              if s51.last
                r51 = instantiate_node(SyntaxNode,input, i51...index, s51)
                r51.extend(VISO8601DURATION10)
              else
                @index = i51
                r51 = nil
              end
              if r51
                r50 = r51
              else
                r50 = instantiate_node(SyntaxNode,input, index...index)
              end
              s43 << r50
              if r50
                i56, s56 = index, []
                s57, i57 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r58 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r58 = nil
                  end
                  if r58
                    s57 << r58
                  else
                    break
                  end
                end
                if s57.empty?
                  @index = i57
                  r57 = nil
                else
                  r57 = instantiate_node(SyntaxNode,input, i57...index, s57)
                end
                s56 << r57
                if r57
                  if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                    r59 = true
                    @index += 1
                  else
                    terminal_parse_failure('[wW]')
                    r59 = nil
                  end
                  s56 << r59
                end
                if s56.last
                  r56 = instantiate_node(SyntaxNode,input, i56...index, s56)
                  r56.extend(VISO8601DURATION11)
                else
                  @index = i56
                  r56 = nil
                end
                if r56
                  r55 = r56
                else
                  r55 = instantiate_node(SyntaxNode,input, index...index)
                end
                s43 << r55
                if r55
                  i61, s61 = index, []
                  s62, i62 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r63 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r63 = nil
                    end
                    if r63
                      s62 << r63
                    else
                      break
                    end
                  end
                  if s62.empty?
                    @index = i62
                    r62 = nil
                  else
                    r62 = instantiate_node(SyntaxNode,input, i62...index, s62)
                  end
                  s61 << r62
                  if r62
                    if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                      r64 = true
                      @index += 1
                    else
                      terminal_parse_failure('[dD]')
                      r64 = nil
                    end
                    s61 << r64
                  end
                  if s61.last
                    r61 = instantiate_node(SyntaxNode,input, i61...index, s61)
                    r61.extend(VISO8601DURATION12)
                  else
                    @index = i61
                    r61 = nil
                  end
                  if r61
                    r60 = r61
                  else
                    r60 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s43 << r60
                  if r60
                    if (match_len = has_terminal?('T', false, index))
                      r65 = true
                      @index += match_len
                    else
                      terminal_parse_failure('T')
                      r65 = nil
                    end
                    s43 << r65
                    if r65
                      i67, s67 = index, []
                      s68, i68 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r69 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r69 = nil
                        end
                        if r69
                          s68 << r69
                        else
                          break
                        end
                      end
                      if s68.empty?
                        @index = i68
                        r68 = nil
                      else
                        r68 = instantiate_node(SyntaxNode,input, i68...index, s68)
                      end
                      s67 << r68
                      if r68
                        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                          r70 = true
                          @index += 1
                        else
                          terminal_parse_failure('[hH]')
                          r70 = nil
                        end
                        s67 << r70
                      end
                      if s67.last
                        r67 = instantiate_node(SyntaxNode,input, i67...index, s67)
                        r67.extend(VISO8601DURATION13)
                      else
                        @index = i67
                        r67 = nil
                      end
                      if r67
                        r66 = r67
                      else
                        r66 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s43 << r66
                      if r66
                        i71, s71 = index, []
                        s72, i72 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r73 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r73 = nil
                          end
                          if r73
                            s72 << r73
                          else
                            break
                          end
                        end
                        if s72.empty?
                          @index = i72
                          r72 = nil
                        else
                          r72 = instantiate_node(SyntaxNode,input, i72...index, s72)
                        end
                        s71 << r72
                        if r72
                          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                            r74 = true
                            @index += 1
                          else
                            terminal_parse_failure('[mM]')
                            r74 = nil
                          end
                          s71 << r74
                        end
                        if s71.last
                          r71 = instantiate_node(SyntaxNode,input, i71...index, s71)
                          r71.extend(VISO8601DURATION14)
                        else
                          @index = i71
                          r71 = nil
                        end
                        s43 << r71
                        if r71
                          i76, s76 = index, []
                          s77, i77 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r78 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r78 = nil
                            end
                            if r78
                              s77 << r78
                            else
                              break
                            end
                          end
                          if s77.empty?
                            @index = i77
                            r77 = nil
                          else
                            r77 = instantiate_node(SyntaxNode,input, i77...index, s77)
                          end
                          s76 << r77
                          if r77
                            i80, s80 = index, []
                            if (match_len = has_terminal?('.', false, index))
                              r81 = true
                              @index += match_len
                            else
                              terminal_parse_failure('.')
                              r81 = nil
                            end
                            s80 << r81
                            if r81
                              s82, i82 = [], index
                              loop do
                                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                  r83 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[0-9]')
                                  r83 = nil
                                end
                                if r83
                                  s82 << r83
                                else
                                  break
                                end
                              end
                              if s82.empty?
                                @index = i82
                                r82 = nil
                              else
                                r82 = instantiate_node(SyntaxNode,input, i82...index, s82)
                              end
                              s80 << r82
                            end
                            if s80.last
                              r80 = instantiate_node(SyntaxNode,input, i80...index, s80)
                              r80.extend(VISO8601DURATION15)
                            else
                              @index = i80
                              r80 = nil
                            end
                            if r80
                              r79 = r80
                            else
                              r79 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s76 << r79
                            if r79
                              if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                                r84 = true
                                @index += 1
                              else
                                terminal_parse_failure('[sS]')
                                r84 = nil
                              end
                              s76 << r84
                            end
                          end
                          if s76.last
                            r76 = instantiate_node(SyntaxNode,input, i76...index, s76)
                            r76.extend(VISO8601DURATION16)
                          else
                            @index = i76
                            r76 = nil
                          end
                          if r76
                            r75 = r76
                          else
                            r75 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s43 << r75
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s43.last
            r43 = instantiate_node(SyntaxNode,input, i43...index, s43)
            r43.extend(VISO8601DURATION17)
          else
            @index = i43
            r43 = nil
          end
          if r43
            r43 = SyntaxNode.new(input, (index-1)...index) if r43 == true
            r0 = r43
          else
            i85, s85 = index, []
            if (match_len = has_terminal?('P', false, index))
              r86 = true
              @index += match_len
            else
              terminal_parse_failure('P')
              r86 = nil
            end
            s85 << r86
            if r86
              i88, s88 = index, []
              s89, i89 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r90 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r90 = nil
                end
                if r90
                  s89 << r90
                else
                  break
                end
              end
              if s89.empty?
                @index = i89
                r89 = nil
              else
                r89 = instantiate_node(SyntaxNode,input, i89...index, s89)
              end
              s88 << r89
              if r89
                if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                  r91 = true
                  @index += 1
                else
                  terminal_parse_failure('[yY]')
                  r91 = nil
                end
                s88 << r91
              end
              if s88.last
                r88 = instantiate_node(SyntaxNode,input, i88...index, s88)
                r88.extend(VISO8601DURATION18)
              else
                @index = i88
                r88 = nil
              end
              if r88
                r87 = r88
              else
                r87 = instantiate_node(SyntaxNode,input, index...index)
              end
              s85 << r87
              if r87
                i93, s93 = index, []
                s94, i94 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r95 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r95 = nil
                  end
                  if r95
                    s94 << r95
                  else
                    break
                  end
                end
                if s94.empty?
                  @index = i94
                  r94 = nil
                else
                  r94 = instantiate_node(SyntaxNode,input, i94...index, s94)
                end
                s93 << r94
                if r94
                  if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                    r96 = true
                    @index += 1
                  else
                    terminal_parse_failure('[mM]')
                    r96 = nil
                  end
                  s93 << r96
                end
                if s93.last
                  r93 = instantiate_node(SyntaxNode,input, i93...index, s93)
                  r93.extend(VISO8601DURATION19)
                else
                  @index = i93
                  r93 = nil
                end
                if r93
                  r92 = r93
                else
                  r92 = instantiate_node(SyntaxNode,input, index...index)
                end
                s85 << r92
                if r92
                  i98, s98 = index, []
                  s99, i99 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r100 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r100 = nil
                    end
                    if r100
                      s99 << r100
                    else
                      break
                    end
                  end
                  if s99.empty?
                    @index = i99
                    r99 = nil
                  else
                    r99 = instantiate_node(SyntaxNode,input, i99...index, s99)
                  end
                  s98 << r99
                  if r99
                    if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                      r101 = true
                      @index += 1
                    else
                      terminal_parse_failure('[wW]')
                      r101 = nil
                    end
                    s98 << r101
                  end
                  if s98.last
                    r98 = instantiate_node(SyntaxNode,input, i98...index, s98)
                    r98.extend(VISO8601DURATION20)
                  else
                    @index = i98
                    r98 = nil
                  end
                  if r98
                    r97 = r98
                  else
                    r97 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s85 << r97
                  if r97
                    i103, s103 = index, []
                    s104, i104 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r105 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r105 = nil
                      end
                      if r105
                        s104 << r105
                      else
                        break
                      end
                    end
                    if s104.empty?
                      @index = i104
                      r104 = nil
                    else
                      r104 = instantiate_node(SyntaxNode,input, i104...index, s104)
                    end
                    s103 << r104
                    if r104
                      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                        r106 = true
                        @index += 1
                      else
                        terminal_parse_failure('[dD]')
                        r106 = nil
                      end
                      s103 << r106
                    end
                    if s103.last
                      r103 = instantiate_node(SyntaxNode,input, i103...index, s103)
                      r103.extend(VISO8601DURATION21)
                    else
                      @index = i103
                      r103 = nil
                    end
                    if r103
                      r102 = r103
                    else
                      r102 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s85 << r102
                    if r102
                      if (match_len = has_terminal?('T', false, index))
                        r107 = true
                        @index += match_len
                      else
                        terminal_parse_failure('T')
                        r107 = nil
                      end
                      s85 << r107
                      if r107
                        i109, s109 = index, []
                        s110, i110 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r111 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r111 = nil
                          end
                          if r111
                            s110 << r111
                          else
                            break
                          end
                        end
                        if s110.empty?
                          @index = i110
                          r110 = nil
                        else
                          r110 = instantiate_node(SyntaxNode,input, i110...index, s110)
                        end
                        s109 << r110
                        if r110
                          if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                            r112 = true
                            @index += 1
                          else
                            terminal_parse_failure('[hH]')
                            r112 = nil
                          end
                          s109 << r112
                        end
                        if s109.last
                          r109 = instantiate_node(SyntaxNode,input, i109...index, s109)
                          r109.extend(VISO8601DURATION22)
                        else
                          @index = i109
                          r109 = nil
                        end
                        if r109
                          r108 = r109
                        else
                          r108 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s85 << r108
                        if r108
                          i114, s114 = index, []
                          s115, i115 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r116 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r116 = nil
                            end
                            if r116
                              s115 << r116
                            else
                              break
                            end
                          end
                          if s115.empty?
                            @index = i115
                            r115 = nil
                          else
                            r115 = instantiate_node(SyntaxNode,input, i115...index, s115)
                          end
                          s114 << r115
                          if r115
                            if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                              r117 = true
                              @index += 1
                            else
                              terminal_parse_failure('[mM]')
                              r117 = nil
                            end
                            s114 << r117
                          end
                          if s114.last
                            r114 = instantiate_node(SyntaxNode,input, i114...index, s114)
                            r114.extend(VISO8601DURATION23)
                          else
                            @index = i114
                            r114 = nil
                          end
                          if r114
                            r113 = r114
                          else
                            r113 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s85 << r113
                          if r113
                            i119, s119 = index, []
                            s120, i120 = [], index
                            loop do
                              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                r121 = true
                                @index += 1
                              else
                                terminal_parse_failure('[0-9]')
                                r121 = nil
                              end
                              if r121
                                s120 << r121
                              else
                                break
                              end
                            end
                            if s120.empty?
                              @index = i120
                              r120 = nil
                            else
                              r120 = instantiate_node(SyntaxNode,input, i120...index, s120)
                            end
                            s119 << r120
                            if r120
                              i123, s123 = index, []
                              if (match_len = has_terminal?('.', false, index))
                                r124 = true
                                @index += match_len
                              else
                                terminal_parse_failure('.')
                                r124 = nil
                              end
                              s123 << r124
                              if r124
                                s125, i125 = [], index
                                loop do
                                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                    r126 = true
                                    @index += 1
                                  else
                                    terminal_parse_failure('[0-9]')
                                    r126 = nil
                                  end
                                  if r126
                                    s125 << r126
                                  else
                                    break
                                  end
                                end
                                if s125.empty?
                                  @index = i125
                                  r125 = nil
                                else
                                  r125 = instantiate_node(SyntaxNode,input, i125...index, s125)
                                end
                                s123 << r125
                              end
                              if s123.last
                                r123 = instantiate_node(SyntaxNode,input, i123...index, s123)
                                r123.extend(VISO8601DURATION24)
                              else
                                @index = i123
                                r123 = nil
                              end
                              if r123
                                r122 = r123
                              else
                                r122 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s119 << r122
                              if r122
                                if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                                  r127 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[sS]')
                                  r127 = nil
                                end
                                s119 << r127
                              end
                            end
                            if s119.last
                              r119 = instantiate_node(SyntaxNode,input, i119...index, s119)
                              r119.extend(VISO8601DURATION25)
                            else
                              @index = i119
                              r119 = nil
                            end
                            if r119
                              r118 = r119
                            else
                              r118 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s85 << r118
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s85.last
              r85 = instantiate_node(SyntaxNode,input, i85...index, s85)
              r85.extend(VISO8601DURATION26)
            else
              @index = i85
              r85 = nil
            end
            if r85
              r85 = SyntaxNode.new(input, (index-1)...index) if r85 == true
              r0 = r85
            else
              i128, s128 = index, []
              if (match_len = has_terminal?('P', false, index))
                r129 = true
                @index += match_len
              else
                terminal_parse_failure('P')
                r129 = nil
              end
              s128 << r129
              if r129
                i130, s130 = index, []
                s131, i131 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r132 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r132 = nil
                  end
                  if r132
                    s131 << r132
                  else
                    break
                  end
                end
                if s131.empty?
                  @index = i131
                  r131 = nil
                else
                  r131 = instantiate_node(SyntaxNode,input, i131...index, s131)
                end
                s130 << r131
                if r131
                  if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                    r133 = true
                    @index += 1
                  else
                    terminal_parse_failure('[yY]')
                    r133 = nil
                  end
                  s130 << r133
                end
                if s130.last
                  r130 = instantiate_node(SyntaxNode,input, i130...index, s130)
                  r130.extend(VISO8601DURATION27)
                else
                  @index = i130
                  r130 = nil
                end
                s128 << r130
                if r130
                  i135, s135 = index, []
                  s136, i136 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r137 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r137 = nil
                    end
                    if r137
                      s136 << r137
                    else
                      break
                    end
                  end
                  if s136.empty?
                    @index = i136
                    r136 = nil
                  else
                    r136 = instantiate_node(SyntaxNode,input, i136...index, s136)
                  end
                  s135 << r136
                  if r136
                    if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                      r138 = true
                      @index += 1
                    else
                      terminal_parse_failure('[mM]')
                      r138 = nil
                    end
                    s135 << r138
                  end
                  if s135.last
                    r135 = instantiate_node(SyntaxNode,input, i135...index, s135)
                    r135.extend(VISO8601DURATION28)
                  else
                    @index = i135
                    r135 = nil
                  end
                  if r135
                    r134 = r135
                  else
                    r134 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s128 << r134
                  if r134
                    i140, s140 = index, []
                    s141, i141 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r142 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r142 = nil
                      end
                      if r142
                        s141 << r142
                      else
                        break
                      end
                    end
                    if s141.empty?
                      @index = i141
                      r141 = nil
                    else
                      r141 = instantiate_node(SyntaxNode,input, i141...index, s141)
                    end
                    s140 << r141
                    if r141
                      if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                        r143 = true
                        @index += 1
                      else
                        terminal_parse_failure('[wW]')
                        r143 = nil
                      end
                      s140 << r143
                    end
                    if s140.last
                      r140 = instantiate_node(SyntaxNode,input, i140...index, s140)
                      r140.extend(VISO8601DURATION29)
                    else
                      @index = i140
                      r140 = nil
                    end
                    if r140
                      r139 = r140
                    else
                      r139 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s128 << r139
                    if r139
                      i145, s145 = index, []
                      s146, i146 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r147 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r147 = nil
                        end
                        if r147
                          s146 << r147
                        else
                          break
                        end
                      end
                      if s146.empty?
                        @index = i146
                        r146 = nil
                      else
                        r146 = instantiate_node(SyntaxNode,input, i146...index, s146)
                      end
                      s145 << r146
                      if r146
                        if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                          r148 = true
                          @index += 1
                        else
                          terminal_parse_failure('[dD]')
                          r148 = nil
                        end
                        s145 << r148
                      end
                      if s145.last
                        r145 = instantiate_node(SyntaxNode,input, i145...index, s145)
                        r145.extend(VISO8601DURATION30)
                      else
                        @index = i145
                        r145 = nil
                      end
                      if r145
                        r144 = r145
                      else
                        r144 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s128 << r144
                    end
                  end
                end
              end
              if s128.last
                r128 = instantiate_node(SyntaxNode,input, i128...index, s128)
                r128.extend(VISO8601DURATION31)
              else
                @index = i128
                r128 = nil
              end
              if r128
                r128 = SyntaxNode.new(input, (index-1)...index) if r128 == true
                r0 = r128
              else
                i149, s149 = index, []
                if (match_len = has_terminal?('P', false, index))
                  r150 = true
                  @index += match_len
                else
                  terminal_parse_failure('P')
                  r150 = nil
                end
                s149 << r150
                if r150
                  i152, s152 = index, []
                  s153, i153 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r154 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r154 = nil
                    end
                    if r154
                      s153 << r154
                    else
                      break
                    end
                  end
                  if s153.empty?
                    @index = i153
                    r153 = nil
                  else
                    r153 = instantiate_node(SyntaxNode,input, i153...index, s153)
                  end
                  s152 << r153
                  if r153
                    if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                      r155 = true
                      @index += 1
                    else
                      terminal_parse_failure('[yY]')
                      r155 = nil
                    end
                    s152 << r155
                  end
                  if s152.last
                    r152 = instantiate_node(SyntaxNode,input, i152...index, s152)
                    r152.extend(VISO8601DURATION32)
                  else
                    @index = i152
                    r152 = nil
                  end
                  if r152
                    r151 = r152
                  else
                    r151 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s149 << r151
                  if r151
                    i156, s156 = index, []
                    s157, i157 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r158 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r158 = nil
                      end
                      if r158
                        s157 << r158
                      else
                        break
                      end
                    end
                    if s157.empty?
                      @index = i157
                      r157 = nil
                    else
                      r157 = instantiate_node(SyntaxNode,input, i157...index, s157)
                    end
                    s156 << r157
                    if r157
                      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                        r159 = true
                        @index += 1
                      else
                        terminal_parse_failure('[mM]')
                        r159 = nil
                      end
                      s156 << r159
                    end
                    if s156.last
                      r156 = instantiate_node(SyntaxNode,input, i156...index, s156)
                      r156.extend(VISO8601DURATION33)
                    else
                      @index = i156
                      r156 = nil
                    end
                    s149 << r156
                    if r156
                      i161, s161 = index, []
                      s162, i162 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r163 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r163 = nil
                        end
                        if r163
                          s162 << r163
                        else
                          break
                        end
                      end
                      if s162.empty?
                        @index = i162
                        r162 = nil
                      else
                        r162 = instantiate_node(SyntaxNode,input, i162...index, s162)
                      end
                      s161 << r162
                      if r162
                        if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                          r164 = true
                          @index += 1
                        else
                          terminal_parse_failure('[wW]')
                          r164 = nil
                        end
                        s161 << r164
                      end
                      if s161.last
                        r161 = instantiate_node(SyntaxNode,input, i161...index, s161)
                        r161.extend(VISO8601DURATION34)
                      else
                        @index = i161
                        r161 = nil
                      end
                      if r161
                        r160 = r161
                      else
                        r160 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s149 << r160
                      if r160
                        i166, s166 = index, []
                        s167, i167 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r168 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r168 = nil
                          end
                          if r168
                            s167 << r168
                          else
                            break
                          end
                        end
                        if s167.empty?
                          @index = i167
                          r167 = nil
                        else
                          r167 = instantiate_node(SyntaxNode,input, i167...index, s167)
                        end
                        s166 << r167
                        if r167
                          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                            r169 = true
                            @index += 1
                          else
                            terminal_parse_failure('[dD]')
                            r169 = nil
                          end
                          s166 << r169
                        end
                        if s166.last
                          r166 = instantiate_node(SyntaxNode,input, i166...index, s166)
                          r166.extend(VISO8601DURATION35)
                        else
                          @index = i166
                          r166 = nil
                        end
                        if r166
                          r165 = r166
                        else
                          r165 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s149 << r165
                      end
                    end
                  end
                end
                if s149.last
                  r149 = instantiate_node(SyntaxNode,input, i149...index, s149)
                  r149.extend(VISO8601DURATION36)
                else
                  @index = i149
                  r149 = nil
                end
                if r149
                  r149 = SyntaxNode.new(input, (index-1)...index) if r149 == true
                  r0 = r149
                else
                  i170, s170 = index, []
                  if (match_len = has_terminal?('P', false, index))
                    r171 = true
                    @index += match_len
                  else
                    terminal_parse_failure('P')
                    r171 = nil
                  end
                  s170 << r171
                  if r171
                    i173, s173 = index, []
                    s174, i174 = [], index
                    loop do
                      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                        r175 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9]')
                        r175 = nil
                      end
                      if r175
                        s174 << r175
                      else
                        break
                      end
                    end
                    if s174.empty?
                      @index = i174
                      r174 = nil
                    else
                      r174 = instantiate_node(SyntaxNode,input, i174...index, s174)
                    end
                    s173 << r174
                    if r174
                      if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                        r176 = true
                        @index += 1
                      else
                        terminal_parse_failure('[yY]')
                        r176 = nil
                      end
                      s173 << r176
                    end
                    if s173.last
                      r173 = instantiate_node(SyntaxNode,input, i173...index, s173)
                      r173.extend(VISO8601DURATION37)
                    else
                      @index = i173
                      r173 = nil
                    end
                    if r173
                      r172 = r173
                    else
                      r172 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s170 << r172
                    if r172
                      i178, s178 = index, []
                      s179, i179 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r180 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r180 = nil
                        end
                        if r180
                          s179 << r180
                        else
                          break
                        end
                      end
                      if s179.empty?
                        @index = i179
                        r179 = nil
                      else
                        r179 = instantiate_node(SyntaxNode,input, i179...index, s179)
                      end
                      s178 << r179
                      if r179
                        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                          r181 = true
                          @index += 1
                        else
                          terminal_parse_failure('[mM]')
                          r181 = nil
                        end
                        s178 << r181
                      end
                      if s178.last
                        r178 = instantiate_node(SyntaxNode,input, i178...index, s178)
                        r178.extend(VISO8601DURATION38)
                      else
                        @index = i178
                        r178 = nil
                      end
                      if r178
                        r177 = r178
                      else
                        r177 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s170 << r177
                      if r177
                        i182, s182 = index, []
                        s183, i183 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r184 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r184 = nil
                          end
                          if r184
                            s183 << r184
                          else
                            break
                          end
                        end
                        if s183.empty?
                          @index = i183
                          r183 = nil
                        else
                          r183 = instantiate_node(SyntaxNode,input, i183...index, s183)
                        end
                        s182 << r183
                        if r183
                          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                            r185 = true
                            @index += 1
                          else
                            terminal_parse_failure('[wW]')
                            r185 = nil
                          end
                          s182 << r185
                        end
                        if s182.last
                          r182 = instantiate_node(SyntaxNode,input, i182...index, s182)
                          r182.extend(VISO8601DURATION39)
                        else
                          @index = i182
                          r182 = nil
                        end
                        s170 << r182
                        if r182
                          i187, s187 = index, []
                          s188, i188 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r189 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r189 = nil
                            end
                            if r189
                              s188 << r189
                            else
                              break
                            end
                          end
                          if s188.empty?
                            @index = i188
                            r188 = nil
                          else
                            r188 = instantiate_node(SyntaxNode,input, i188...index, s188)
                          end
                          s187 << r188
                          if r188
                            if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                              r190 = true
                              @index += 1
                            else
                              terminal_parse_failure('[dD]')
                              r190 = nil
                            end
                            s187 << r190
                          end
                          if s187.last
                            r187 = instantiate_node(SyntaxNode,input, i187...index, s187)
                            r187.extend(VISO8601DURATION40)
                          else
                            @index = i187
                            r187 = nil
                          end
                          if r187
                            r186 = r187
                          else
                            r186 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s170 << r186
                        end
                      end
                    end
                  end
                  if s170.last
                    r170 = instantiate_node(SyntaxNode,input, i170...index, s170)
                    r170.extend(VISO8601DURATION41)
                  else
                    @index = i170
                    r170 = nil
                  end
                  if r170
                    r170 = SyntaxNode.new(input, (index-1)...index) if r170 == true
                    r0 = r170
                  else
                    i191, s191 = index, []
                    if (match_len = has_terminal?('P', false, index))
                      r192 = true
                      @index += match_len
                    else
                      terminal_parse_failure('P')
                      r192 = nil
                    end
                    s191 << r192
                    if r192
                      i194, s194 = index, []
                      s195, i195 = [], index
                      loop do
                        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                          r196 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9]')
                          r196 = nil
                        end
                        if r196
                          s195 << r196
                        else
                          break
                        end
                      end
                      if s195.empty?
                        @index = i195
                        r195 = nil
                      else
                        r195 = instantiate_node(SyntaxNode,input, i195...index, s195)
                      end
                      s194 << r195
                      if r195
                        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                          r197 = true
                          @index += 1
                        else
                          terminal_parse_failure('[yY]')
                          r197 = nil
                        end
                        s194 << r197
                      end
                      if s194.last
                        r194 = instantiate_node(SyntaxNode,input, i194...index, s194)
                        r194.extend(VISO8601DURATION42)
                      else
                        @index = i194
                        r194 = nil
                      end
                      if r194
                        r193 = r194
                      else
                        r193 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s191 << r193
                      if r193
                        i199, s199 = index, []
                        s200, i200 = [], index
                        loop do
                          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                            r201 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9]')
                            r201 = nil
                          end
                          if r201
                            s200 << r201
                          else
                            break
                          end
                        end
                        if s200.empty?
                          @index = i200
                          r200 = nil
                        else
                          r200 = instantiate_node(SyntaxNode,input, i200...index, s200)
                        end
                        s199 << r200
                        if r200
                          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                            r202 = true
                            @index += 1
                          else
                            terminal_parse_failure('[mM]')
                            r202 = nil
                          end
                          s199 << r202
                        end
                        if s199.last
                          r199 = instantiate_node(SyntaxNode,input, i199...index, s199)
                          r199.extend(VISO8601DURATION43)
                        else
                          @index = i199
                          r199 = nil
                        end
                        if r199
                          r198 = r199
                        else
                          r198 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s191 << r198
                        if r198
                          i204, s204 = index, []
                          s205, i205 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                              r206 = true
                              @index += 1
                            else
                              terminal_parse_failure('[0-9]')
                              r206 = nil
                            end
                            if r206
                              s205 << r206
                            else
                              break
                            end
                          end
                          if s205.empty?
                            @index = i205
                            r205 = nil
                          else
                            r205 = instantiate_node(SyntaxNode,input, i205...index, s205)
                          end
                          s204 << r205
                          if r205
                            if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                              r207 = true
                              @index += 1
                            else
                              terminal_parse_failure('[wW]')
                              r207 = nil
                            end
                            s204 << r207
                          end
                          if s204.last
                            r204 = instantiate_node(SyntaxNode,input, i204...index, s204)
                            r204.extend(VISO8601DURATION44)
                          else
                            @index = i204
                            r204 = nil
                          end
                          if r204
                            r203 = r204
                          else
                            r203 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s191 << r203
                          if r203
                            i208, s208 = index, []
                            s209, i209 = [], index
                            loop do
                              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                                r210 = true
                                @index += 1
                              else
                                terminal_parse_failure('[0-9]')
                                r210 = nil
                              end
                              if r210
                                s209 << r210
                              else
                                break
                              end
                            end
                            if s209.empty?
                              @index = i209
                              r209 = nil
                            else
                              r209 = instantiate_node(SyntaxNode,input, i209...index, s209)
                            end
                            s208 << r209
                            if r209
                              if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                                r211 = true
                                @index += 1
                              else
                                terminal_parse_failure('[dD]')
                                r211 = nil
                              end
                              s208 << r211
                            end
                            if s208.last
                              r208 = instantiate_node(SyntaxNode,input, i208...index, s208)
                              r208.extend(VISO8601DURATION45)
                            else
                              @index = i208
                              r208 = nil
                            end
                            s191 << r208
                          end
                        end
                      end
                    end
                    if s191.last
                      r191 = instantiate_node(SyntaxNode,input, i191...index, s191)
                      r191.extend(VISO8601DURATION46)
                    else
                      @index = i191
                      r191 = nil
                    end
                    if r191
                      r191 = SyntaxNode.new(input, (index-1)...index) if r191 == true
                      r0 = r191
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:V_ISO8601_DURATION][start_index] = r0

        r0
      end

      module VISO8601DATECONSTRAINTPATTERN0
      end

      def _nt_V_ISO8601_DATE_CONSTRAINT_PATTERN
        start_index = index
        if node_cache[:V_ISO8601_DATE_CONSTRAINT_PATTERN].has_key?(index)
          cached = node_cache[:V_ISO8601_DATE_CONSTRAINT_PATTERN][index]
          if cached
            node_cache[:V_ISO8601_DATE_CONSTRAINT_PATTERN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[yY]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[yY]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[yY]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[yY]')
                r4 = nil
              end
              s0 << r4
              if r4
                if (match_len = has_terminal?('-', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('-')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[mM?X]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[mM?X]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if (match_len = has_terminal?('-', false, index))
                        r8 = true
                        @index += match_len
                      else
                        terminal_parse_failure('-')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[dD?X]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[dD?X]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[dD?X]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[dD?X]')
                            r10 = nil
                          end
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VISO8601DATECONSTRAINTPATTERN0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ISO8601_DATE_CONSTRAINT_PATTERN][start_index] = r0

        r0
      end

      module VISO8601TIMECONSTRAINTPATTERN0
      end

      def _nt_V_ISO8601_TIME_CONSTRAINT_PATTERN
        start_index = index
        if node_cache[:V_ISO8601_TIME_CONSTRAINT_PATTERN].has_key?(index)
          cached = node_cache[:V_ISO8601_TIME_CONSTRAINT_PATTERN][index]
          if cached
            node_cache[:V_ISO8601_TIME_CONSTRAINT_PATTERN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[hH]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[hH]')
            r2 = nil
          end
          s0 << r2
          if r2
            if (match_len = has_terminal?(':', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure(':')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[mM?X]')
                r4 = nil
              end
              s0 << r4
              if r4
                if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                  r5 = true
                  @index += 1
                else
                  terminal_parse_failure('[mM?X]')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if (match_len = has_terminal?(':', false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure(':')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[sS?X]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[sS?X]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if has_terminal?(@regexps[gr = '\A[sS?X]'] ||= Regexp.new(gr), :regexp, index)
                        r8 = true
                        @index += 1
                      else
                        terminal_parse_failure('[sS?X]')
                        r8 = nil
                      end
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VISO8601TIMECONSTRAINTPATTERN0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ISO8601_TIME_CONSTRAINT_PATTERN][start_index] = r0

        r0
      end

      module VISO8601DATETIMECONSTRAINTPATTERN0
      end

      def _nt_V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN
        start_index = index
        if node_cache[:V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN].has_key?(index)
          cached = node_cache[:V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN][index]
          if cached
            node_cache[:V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[yY]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[yY]')
            r2 = nil
          end
          s0 << r2
          if r2
            if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[yY]')
              r3 = nil
            end
            s0 << r3
            if r3
              if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                r4 = true
                @index += 1
              else
                terminal_parse_failure('[yY]')
                r4 = nil
              end
              s0 << r4
              if r4
                if (match_len = has_terminal?('-', false, index))
                  r5 = true
                  @index += match_len
                else
                  terminal_parse_failure('-')
                  r5 = nil
                end
                s0 << r5
                if r5
                  if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                    r6 = true
                    @index += 1
                  else
                    terminal_parse_failure('[mM?X]')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                      r7 = true
                      @index += 1
                    else
                      terminal_parse_failure('[mM?X]')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      if (match_len = has_terminal?('-', false, index))
                        r8 = true
                        @index += match_len
                      else
                        terminal_parse_failure('-')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        if has_terminal?(@regexps[gr = '\A[dD?X]'] ||= Regexp.new(gr), :regexp, index)
                          r9 = true
                          @index += 1
                        else
                          terminal_parse_failure('[dD?X]')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          if has_terminal?(@regexps[gr = '\A[dD?X]'] ||= Regexp.new(gr), :regexp, index)
                            r10 = true
                            @index += 1
                          else
                            terminal_parse_failure('[dD?X]')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            if has_terminal?(@regexps[gr = '\A[Tt ]'] ||= Regexp.new(gr), :regexp, index)
                              r11 = true
                              @index += 1
                            else
                              terminal_parse_failure('[Tt ]')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              if has_terminal?(@regexps[gr = '\A[hH?X]'] ||= Regexp.new(gr), :regexp, index)
                                r12 = true
                                @index += 1
                              else
                                terminal_parse_failure('[hH?X]')
                                r12 = nil
                              end
                              s0 << r12
                              if r12
                                if has_terminal?(@regexps[gr = '\A[hH?X]'] ||= Regexp.new(gr), :regexp, index)
                                  r13 = true
                                  @index += 1
                                else
                                  terminal_parse_failure('[hH?X]')
                                  r13 = nil
                                end
                                s0 << r13
                                if r13
                                  if (match_len = has_terminal?(':', false, index))
                                    r14 = true
                                    @index += match_len
                                  else
                                    terminal_parse_failure(':')
                                    r14 = nil
                                  end
                                  s0 << r14
                                  if r14
                                    if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                                      r15 = true
                                      @index += 1
                                    else
                                      terminal_parse_failure('[mM?X]')
                                      r15 = nil
                                    end
                                    s0 << r15
                                    if r15
                                      if has_terminal?(@regexps[gr = '\A[mM?X]'] ||= Regexp.new(gr), :regexp, index)
                                        r16 = true
                                        @index += 1
                                      else
                                        terminal_parse_failure('[mM?X]')
                                        r16 = nil
                                      end
                                      s0 << r16
                                      if r16
                                        if (match_len = has_terminal?(':', false, index))
                                          r17 = true
                                          @index += match_len
                                        else
                                          terminal_parse_failure(':')
                                          r17 = nil
                                        end
                                        s0 << r17
                                        if r17
                                          if has_terminal?(@regexps[gr = '\A[sS?X]'] ||= Regexp.new(gr), :regexp, index)
                                            r18 = true
                                            @index += 1
                                          else
                                            terminal_parse_failure('[sS?X]')
                                            r18 = nil
                                          end
                                          s0 << r18
                                          if r18
                                            if has_terminal?(@regexps[gr = '\A[sS?X]'] ||= Regexp.new(gr), :regexp, index)
                                              r19 = true
                                              @index += 1
                                            else
                                              terminal_parse_failure('[sS?X]')
                                              r19 = nil
                                            end
                                            s0 << r19
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VISO8601DATETIMECONSTRAINTPATTERN0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ISO8601_DATE_TIME_CONSTRAINT_PATTERN][start_index] = r0

        r0
      end

      module VISO8601DURATIONCONSTRAINTPATTERN0
      end

      module VISO8601DURATIONCONSTRAINTPATTERN1
      end

      module VISO8601DURATIONCONSTRAINTPATTERN2
      end

      module VISO8601DURATIONCONSTRAINTPATTERN3
      end

      module VISO8601DURATIONCONSTRAINTPATTERN4
      end

      module VISO8601DURATIONCONSTRAINTPATTERN5
      end

      module VISO8601DURATIONCONSTRAINTPATTERN6
      end

      def _nt_V_ISO8601_DURATION_CONSTRAINT_PATTERN
        start_index = index
        if node_cache[:V_ISO8601_DURATION_CONSTRAINT_PATTERN].has_key?(index)
          cached = node_cache[:V_ISO8601_DURATION_CONSTRAINT_PATTERN][index]
          if cached
            node_cache[:V_ISO8601_DURATION_CONSTRAINT_PATTERN][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('P', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('P')
          r2 = nil
        end
        s1 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[yY]')
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r3
          if r3
            if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
              r6 = true
              @index += 1
            else
              terminal_parse_failure('[mM]')
              r6 = nil
            end
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                r8 = true
                @index += 1
              else
                terminal_parse_failure('[wW]')
                r8 = nil
              end
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r7
              if r7
                if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                  r10 = true
                  @index += 1
                else
                  terminal_parse_failure('[dD]')
                  r10 = nil
                end
                if r10
                  r9 = r10
                else
                  r9 = instantiate_node(SyntaxNode,input, index...index)
                end
                s1 << r9
                if r9
                  if (match_len = has_terminal?('T', false, index))
                    r11 = true
                    @index += match_len
                  else
                    terminal_parse_failure('T')
                    r11 = nil
                  end
                  s1 << r11
                  if r11
                    if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                      r12 = true
                      @index += 1
                    else
                      terminal_parse_failure('[hH]')
                      r12 = nil
                    end
                    s1 << r12
                    if r12
                      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                        r14 = true
                        @index += 1
                      else
                        terminal_parse_failure('[mM]')
                        r14 = nil
                      end
                      if r14
                        r13 = r14
                      else
                        r13 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s1 << r13
                      if r13
                        if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                          r16 = true
                          @index += 1
                        else
                          terminal_parse_failure('[sS]')
                          r16 = nil
                        end
                        if r16
                          r15 = r16
                        else
                          r15 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s1 << r15
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VISO8601DURATIONCONSTRAINTPATTERN0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i17, s17 = index, []
          if (match_len = has_terminal?('P', false, index))
            r18 = true
            @index += match_len
          else
            terminal_parse_failure('P')
            r18 = nil
          end
          s17 << r18
          if r18
            if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
              r20 = true
              @index += 1
            else
              terminal_parse_failure('[yY]')
              r20 = nil
            end
            if r20
              r19 = r20
            else
              r19 = instantiate_node(SyntaxNode,input, index...index)
            end
            s17 << r19
            if r19
              if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                r22 = true
                @index += 1
              else
                terminal_parse_failure('[mM]')
                r22 = nil
              end
              if r22
                r21 = r22
              else
                r21 = instantiate_node(SyntaxNode,input, index...index)
              end
              s17 << r21
              if r21
                if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                  r24 = true
                  @index += 1
                else
                  terminal_parse_failure('[wW]')
                  r24 = nil
                end
                if r24
                  r23 = r24
                else
                  r23 = instantiate_node(SyntaxNode,input, index...index)
                end
                s17 << r23
                if r23
                  if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                    r26 = true
                    @index += 1
                  else
                    terminal_parse_failure('[dD]')
                    r26 = nil
                  end
                  if r26
                    r25 = r26
                  else
                    r25 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s17 << r25
                  if r25
                    if (match_len = has_terminal?('T', false, index))
                      r27 = true
                      @index += match_len
                    else
                      terminal_parse_failure('T')
                      r27 = nil
                    end
                    s17 << r27
                    if r27
                      if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                        r29 = true
                        @index += 1
                      else
                        terminal_parse_failure('[hH]')
                        r29 = nil
                      end
                      if r29
                        r28 = r29
                      else
                        r28 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s17 << r28
                      if r28
                        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                          r30 = true
                          @index += 1
                        else
                          terminal_parse_failure('[mM]')
                          r30 = nil
                        end
                        s17 << r30
                        if r30
                          if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                            r32 = true
                            @index += 1
                          else
                            terminal_parse_failure('[sS]')
                            r32 = nil
                          end
                          if r32
                            r31 = r32
                          else
                            r31 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s17 << r31
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s17.last
            r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
            r17.extend(VISO8601DURATIONCONSTRAINTPATTERN1)
          else
            @index = i17
            r17 = nil
          end
          if r17
            r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
            r0 = r17
          else
            i33, s33 = index, []
            if (match_len = has_terminal?('P', false, index))
              r34 = true
              @index += match_len
            else
              terminal_parse_failure('P')
              r34 = nil
            end
            s33 << r34
            if r34
              if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                r36 = true
                @index += 1
              else
                terminal_parse_failure('[yY]')
                r36 = nil
              end
              if r36
                r35 = r36
              else
                r35 = instantiate_node(SyntaxNode,input, index...index)
              end
              s33 << r35
              if r35
                if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                  r38 = true
                  @index += 1
                else
                  terminal_parse_failure('[mM]')
                  r38 = nil
                end
                if r38
                  r37 = r38
                else
                  r37 = instantiate_node(SyntaxNode,input, index...index)
                end
                s33 << r37
                if r37
                  if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                    r40 = true
                    @index += 1
                  else
                    terminal_parse_failure('[wW]')
                    r40 = nil
                  end
                  if r40
                    r39 = r40
                  else
                    r39 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s33 << r39
                  if r39
                    if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                      r42 = true
                      @index += 1
                    else
                      terminal_parse_failure('[dD]')
                      r42 = nil
                    end
                    if r42
                      r41 = r42
                    else
                      r41 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s33 << r41
                    if r41
                      if (match_len = has_terminal?('T', false, index))
                        r43 = true
                        @index += match_len
                      else
                        terminal_parse_failure('T')
                        r43 = nil
                      end
                      s33 << r43
                      if r43
                        if has_terminal?(@regexps[gr = '\A[hH]'] ||= Regexp.new(gr), :regexp, index)
                          r45 = true
                          @index += 1
                        else
                          terminal_parse_failure('[hH]')
                          r45 = nil
                        end
                        if r45
                          r44 = r45
                        else
                          r44 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s33 << r44
                        if r44
                          if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                            r47 = true
                            @index += 1
                          else
                            terminal_parse_failure('[mM]')
                            r47 = nil
                          end
                          if r47
                            r46 = r47
                          else
                            r46 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s33 << r46
                          if r46
                            if has_terminal?(@regexps[gr = '\A[sS]'] ||= Regexp.new(gr), :regexp, index)
                              r48 = true
                              @index += 1
                            else
                              terminal_parse_failure('[sS]')
                              r48 = nil
                            end
                            s33 << r48
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if s33.last
              r33 = instantiate_node(SyntaxNode,input, i33...index, s33)
              r33.extend(VISO8601DURATIONCONSTRAINTPATTERN2)
            else
              @index = i33
              r33 = nil
            end
            if r33
              r33 = SyntaxNode.new(input, (index-1)...index) if r33 == true
              r0 = r33
            else
              i49, s49 = index, []
              if (match_len = has_terminal?('P', false, index))
                r50 = true
                @index += match_len
              else
                terminal_parse_failure('P')
                r50 = nil
              end
              s49 << r50
              if r50
                if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                  r51 = true
                  @index += 1
                else
                  terminal_parse_failure('[yY]')
                  r51 = nil
                end
                s49 << r51
                if r51
                  if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                    r53 = true
                    @index += 1
                  else
                    terminal_parse_failure('[mM]')
                    r53 = nil
                  end
                  if r53
                    r52 = r53
                  else
                    r52 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s49 << r52
                  if r52
                    if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                      r55 = true
                      @index += 1
                    else
                      terminal_parse_failure('[wW]')
                      r55 = nil
                    end
                    if r55
                      r54 = r55
                    else
                      r54 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s49 << r54
                    if r54
                      if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                        r57 = true
                        @index += 1
                      else
                        terminal_parse_failure('[dD]')
                        r57 = nil
                      end
                      if r57
                        r56 = r57
                      else
                        r56 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s49 << r56
                    end
                  end
                end
              end
              if s49.last
                r49 = instantiate_node(SyntaxNode,input, i49...index, s49)
                r49.extend(VISO8601DURATIONCONSTRAINTPATTERN3)
              else
                @index = i49
                r49 = nil
              end
              if r49
                r49 = SyntaxNode.new(input, (index-1)...index) if r49 == true
                r0 = r49
              else
                i58, s58 = index, []
                if (match_len = has_terminal?('P', false, index))
                  r59 = true
                  @index += match_len
                else
                  terminal_parse_failure('P')
                  r59 = nil
                end
                s58 << r59
                if r59
                  if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                    r61 = true
                    @index += 1
                  else
                    terminal_parse_failure('[yY]')
                    r61 = nil
                  end
                  if r61
                    r60 = r61
                  else
                    r60 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s58 << r60
                  if r60
                    if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                      r62 = true
                      @index += 1
                    else
                      terminal_parse_failure('[mM]')
                      r62 = nil
                    end
                    s58 << r62
                    if r62
                      if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                        r64 = true
                        @index += 1
                      else
                        terminal_parse_failure('[wW]')
                        r64 = nil
                      end
                      if r64
                        r63 = r64
                      else
                        r63 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s58 << r63
                      if r63
                        if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                          r66 = true
                          @index += 1
                        else
                          terminal_parse_failure('[dD]')
                          r66 = nil
                        end
                        if r66
                          r65 = r66
                        else
                          r65 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s58 << r65
                      end
                    end
                  end
                end
                if s58.last
                  r58 = instantiate_node(SyntaxNode,input, i58...index, s58)
                  r58.extend(VISO8601DURATIONCONSTRAINTPATTERN4)
                else
                  @index = i58
                  r58 = nil
                end
                if r58
                  r58 = SyntaxNode.new(input, (index-1)...index) if r58 == true
                  r0 = r58
                else
                  i67, s67 = index, []
                  if (match_len = has_terminal?('P', false, index))
                    r68 = true
                    @index += match_len
                  else
                    terminal_parse_failure('P')
                    r68 = nil
                  end
                  s67 << r68
                  if r68
                    if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                      r70 = true
                      @index += 1
                    else
                      terminal_parse_failure('[yY]')
                      r70 = nil
                    end
                    if r70
                      r69 = r70
                    else
                      r69 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s67 << r69
                    if r69
                      if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                        r72 = true
                        @index += 1
                      else
                        terminal_parse_failure('[mM]')
                        r72 = nil
                      end
                      if r72
                        r71 = r72
                      else
                        r71 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s67 << r71
                      if r71
                        if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                          r73 = true
                          @index += 1
                        else
                          terminal_parse_failure('[wW]')
                          r73 = nil
                        end
                        s67 << r73
                        if r73
                          if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                            r75 = true
                            @index += 1
                          else
                            terminal_parse_failure('[dD]')
                            r75 = nil
                          end
                          if r75
                            r74 = r75
                          else
                            r74 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s67 << r74
                        end
                      end
                    end
                  end
                  if s67.last
                    r67 = instantiate_node(SyntaxNode,input, i67...index, s67)
                    r67.extend(VISO8601DURATIONCONSTRAINTPATTERN5)
                  else
                    @index = i67
                    r67 = nil
                  end
                  if r67
                    r67 = SyntaxNode.new(input, (index-1)...index) if r67 == true
                    r0 = r67
                  else
                    i76, s76 = index, []
                    if (match_len = has_terminal?('P', false, index))
                      r77 = true
                      @index += match_len
                    else
                      terminal_parse_failure('P')
                      r77 = nil
                    end
                    s76 << r77
                    if r77
                      if has_terminal?(@regexps[gr = '\A[yY]'] ||= Regexp.new(gr), :regexp, index)
                        r79 = true
                        @index += 1
                      else
                        terminal_parse_failure('[yY]')
                        r79 = nil
                      end
                      if r79
                        r78 = r79
                      else
                        r78 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s76 << r78
                      if r78
                        if has_terminal?(@regexps[gr = '\A[mM]'] ||= Regexp.new(gr), :regexp, index)
                          r81 = true
                          @index += 1
                        else
                          terminal_parse_failure('[mM]')
                          r81 = nil
                        end
                        if r81
                          r80 = r81
                        else
                          r80 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s76 << r80
                        if r80
                          if has_terminal?(@regexps[gr = '\A[wW]'] ||= Regexp.new(gr), :regexp, index)
                            r83 = true
                            @index += 1
                          else
                            terminal_parse_failure('[wW]')
                            r83 = nil
                          end
                          if r83
                            r82 = r83
                          else
                            r82 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s76 << r82
                          if r82
                            if has_terminal?(@regexps[gr = '\A[dD]'] ||= Regexp.new(gr), :regexp, index)
                              r84 = true
                              @index += 1
                            else
                              terminal_parse_failure('[dD]')
                              r84 = nil
                            end
                            s76 << r84
                          end
                        end
                      end
                    end
                    if s76.last
                      r76 = instantiate_node(SyntaxNode,input, i76...index, s76)
                      r76.extend(VISO8601DURATIONCONSTRAINTPATTERN6)
                    else
                      @index = i76
                      r76 = nil
                    end
                    if r76
                      r76 = SyntaxNode.new(input, (index-1)...index) if r76 == true
                      r0 = r76
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:V_ISO8601_DURATION_CONSTRAINT_PATTERN][start_index] = r0

        r0
      end

      module VTYPEIDENTIFIER0
      end

      module VTYPEIDENTIFIER1
        def value
          text_value
        end
      end

      def _nt_V_TYPE_IDENTIFIER
        start_index = index
        if node_cache[:V_TYPE_IDENTIFIER].has_key?(index)
          cached = node_cache[:V_TYPE_IDENTIFIER][index]
          if cached
            node_cache[:V_TYPE_IDENTIFIER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[A-Z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[A-Z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_IDCHAR
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VTYPEIDENTIFIER0)
          r0.extend(VTYPEIDENTIFIER1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_TYPE_IDENTIFIER][start_index] = r0

        r0
      end

      module VGENERICTYPEIDENTIFIER0
      end

      module VGENERICTYPEIDENTIFIER1
        # <>
                def value
                  text_value
                end
      end

      def _nt_V_GENERIC_TYPE_IDENTIFIER
        start_index = index
        if node_cache[:V_GENERIC_TYPE_IDENTIFIER].has_key?(index)
          cached = node_cache[:V_GENERIC_TYPE_IDENTIFIER][index]
          if cached
            node_cache[:V_GENERIC_TYPE_IDENTIFIER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[A-Z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[A-Z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_IDCHAR
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('<', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('<')
              r4 = nil
            end
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9,_]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[a-zA-Z0-9,_]')
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              if s5.empty?
                @index = i5
                r5 = nil
              else
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              end
              s0 << r5
              if r5
                if (match_len = has_terminal?('>', false, index))
                  r7 = true
                  @index += match_len
                else
                  terminal_parse_failure('>')
                  r7 = nil
                end
                s0 << r7
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VGENERICTYPEIDENTIFIER0)
          r0.extend(VGENERICTYPEIDENTIFIER1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_GENERIC_TYPE_IDENTIFIER][start_index] = r0

        r0
      end

      module VATTRIBUTEIDENTIFIER0
      end

      module VATTRIBUTEIDENTIFIER1
        def value
          text_value
        end
      end

      def _nt_V_ATTRIBUTE_IDENTIFIER
        start_index = index
        if node_cache[:V_ATTRIBUTE_IDENTIFIER].has_key?(index)
          cached = node_cache[:V_ATTRIBUTE_IDENTIFIER][index]
          if cached
            node_cache[:V_ATTRIBUTE_IDENTIFIER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[a-z]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[a-z]')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_IDCHAR
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VATTRIBUTEIDENTIFIER0)
          r0.extend(VATTRIBUTEIDENTIFIER1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_ATTRIBUTE_IDENTIFIER][start_index] = r0

        r0
      end

      module VINTEGER0
      end

      module VINTEGER1
        def value
          text_value.to_i
        end
      end

      module VINTEGER2
      end

      module VINTEGER3
        def value
          text_value.to_i
        end
      end

      module VINTEGER4
        def value
          text_value.to_i
        end
      end

      def _nt_V_INTEGER
        start_index = index
        if node_cache[:V_INTEGER].has_key?(index)
          cached = node_cache[:V_INTEGER][index]
          if cached
            node_cache[:V_INTEGER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        if s2.empty?
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
            r4 = true
            @index += 1
          else
            terminal_parse_failure('[eE]')
            r4 = nil
          end
          s1 << r4
          if r4
            if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
              r6 = true
              @index += 1
            else
              terminal_parse_failure('[+-]')
              r6 = nil
            end
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r7 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r7 = nil
              end
              s1 << r7
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VINTEGER0)
          r1.extend(VINTEGER1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          if has_terminal?(@regexps[gr = '\A[1-9]'] ||= Regexp.new(gr), :regexp, index)
            r9 = true
            @index += 1
          else
            terminal_parse_failure('[1-9]')
            r9 = nil
          end
          s8 << r9
          if r9
            s10, i10 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r11 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r11 = nil
              end
              if r11
                s10 << r11
              else
                break
              end
            end
            if s10.empty?
              @index = i10
              r10 = nil
            else
              r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            end
            s8 << r10
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(VINTEGER2)
            r8.extend(VINTEGER3)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
              r12.extend(VINTEGER4)
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r12 = nil
            end
            if r12
              r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
              r0 = r12
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:V_INTEGER][start_index] = r0

        r0
      end

      module VREAL0
      end

      module VREAL1
      end

      module VREAL2
      end

      module VREAL3
        def value
          text_value.to_f
        end
      end

      def _nt_V_REAL
        start_index = index
        if node_cache[:V_REAL].has_key?(index)
          cached = node_cache[:V_REAL][index]
          if cached
            node_cache[:V_REAL][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        if s2.empty?
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if (match_len = has_terminal?('.', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('.')
            r4 = nil
          end
          s1 << r4
          if r4
            s5, i5 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r6 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r6 = nil
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            if s5.empty?
              @index = i5
              r5 = nil
            else
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            end
            s1 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
                r7 = true
                @index += 1
              else
                terminal_parse_failure('[eE]')
                r7 = nil
              end
              s1 << r7
              if r7
                if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
                  r9 = true
                  @index += 1
                else
                  terminal_parse_failure('[+-]')
                  r9 = nil
                end
                if r9
                  r8 = r9
                else
                  r8 = instantiate_node(SyntaxNode,input, index...index)
                end
                s1 << r8
                if r8
                  s10, i10 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                      r11 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9]')
                      r11 = nil
                    end
                    if r11
                      s10 << r11
                    else
                      break
                    end
                  end
                  if s10.empty?
                    @index = i10
                    r10 = nil
                  else
                    r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                  end
                  s1 << r10
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(VREAL0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i12, s12 = index, []
          if has_terminal?(@regexps[gr = '\A[1-9]'] ||= Regexp.new(gr), :regexp, index)
            r13 = true
            @index += 1
          else
            terminal_parse_failure('[1-9]')
            r13 = nil
          end
          s12 << r13
          if r13
            s14, i14 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r15 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r15 = nil
              end
              if r15
                s14 << r15
              else
                break
              end
            end
            if s14.empty?
              @index = i14
              r14 = nil
            else
              r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
            end
            s12 << r14
            if r14
              if (match_len = has_terminal?('.', false, index))
                r16 = true
                @index += match_len
              else
                terminal_parse_failure('.')
                r16 = nil
              end
              s12 << r16
              if r16
                s17, i17 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r18 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r18 = nil
                  end
                  if r18
                    s17 << r18
                  else
                    break
                  end
                end
                if s17.empty?
                  @index = i17
                  r17 = nil
                else
                  r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                end
                s12 << r17
              end
            end
          end
          if s12.last
            r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
            r12.extend(VREAL1)
          else
            @index = i12
            r12 = nil
          end
          if r12
            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
            r0 = r12
          else
            i19, s19 = index, []
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r20 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r20 = nil
            end
            s19 << r20
            if r20
              if (match_len = has_terminal?('.', false, index))
                r21 = true
                @index += match_len
              else
                terminal_parse_failure('.')
                r21 = nil
              end
              s19 << r21
              if r21
                s22, i22 = [], index
                loop do
                  if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                    r23 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9]')
                    r23 = nil
                  end
                  if r23
                    s22 << r23
                  else
                    break
                  end
                end
                if s22.empty?
                  @index = i22
                  r22 = nil
                else
                  r22 = instantiate_node(SyntaxNode,input, i22...index, s22)
                end
                s19 << r22
              end
            end
            if s19.last
              r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
              r19.extend(VREAL2)
              r19.extend(VREAL3)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
              r0 = r19
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:V_REAL][start_index] = r0

        r0
      end

      module VCHAR0
        def value
          text_value
        end
      end

      def _nt_V_CHAR
        start_index = index
        if node_cache[:V_CHAR].has_key?(index)
          cached = node_cache[:V_CHAR][index]
          if cached
            node_cache[:V_CHAR][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[^\\\\\\n\\"]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          r0.extend(VCHAR0)
          @index += 1
        else
          terminal_parse_failure('[^\\\\\\n\\"]')
          r0 = nil
        end

        node_cache[:V_CHAR][start_index] = r0

        r0
      end

      module VSTRING0
      end

      module VSTRING1
        def str
          elements[1]
        end

      end

      module VSTRING2
        def value
          str.text_value.tr_s('\\\\', '\\')
        end
      end

      def _nt_V_STRING
        start_index = index
        if node_cache[:V_STRING].has_key?(index)
          cached = node_cache[:V_STRING][index]
          if cached
            node_cache[:V_STRING][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('"', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            if (match_len = has_terminal?('\"', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\"')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              i5, s5 = index, []
              i6 = index
              if (match_len = has_terminal?('"', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('"')
                r7 = nil
              end
              if r7
                r6 = nil
              else
                @index = i6
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s5 << r6
              if r6
                if index < input_length
                  r8 = true
                  @index += 1
                else
                  terminal_parse_failure("any character")
                  r8 = nil
                end
                s5 << r8
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(VSTRING0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('"', false, index))
              r9 = true
              @index += match_len
            else
              terminal_parse_failure('"')
              r9 = nil
            end
            s0 << r9
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VSTRING1)
          r0.extend(VSTRING2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:V_STRING][start_index] = r0

        r0
      end

    end

    class ADLGrammarParser < Treetop::Runtime::CompiledParser
      include ADLGrammar
    end
 # of ADLGrammar
  end # of Parser
end # of openEHR
